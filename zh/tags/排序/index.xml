<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>排序 on 绯想天</title><link>https://www.flandre.love/zh/tags/%E6%8E%92%E5%BA%8F/</link><description>Recent content in 排序 on 绯想天</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>Copyright © 2020 - 2023 Fei Pan</copyright><lastBuildDate>Wed, 05 Jul 2023 15:30:59 +0800</lastBuildDate><atom:link href="https://www.flandre.love/zh/tags/%E6%8E%92%E5%BA%8F/index.xml" rel="self" type="application/rss+xml"/><item><title>TUCS：最终的比较排序法</title><link>https://www.flandre.love/zh/posts/tucs/</link><pubDate>Wed, 05 Jul 2023 15:30:59 +0800</pubDate><guid>https://www.flandre.love/zh/posts/tucs/</guid><description>&lt;p>我们所知的所有基于比较的排序算法（Comparison Sorting Algorithm）都有 $\Omega(n\log n)$ 的最坏情况下的复杂度下界。仅有桶排序和基数排序等一类非比较排序算法可以得到更好的复杂度。&lt;/p>
&lt;p>那么，是否存在一个 $o(n\log n)$ 的比较排序算法，只是我们没有发现呢？假定存在这样的算法，我们称之为 TUCS（the Ultimate Comparison Sort）。我们一眼就能看出，TUCS 的运行时间 $R(n)$ 满足 $R(n)\in O(n\log n), R(n) \in \Omega(n)$；上界由归并排序给出，下界则是由于序列中的每个元素都起码要被访问一次。&lt;/p>
&lt;p>我们发现，当序列中元素均不相等时，它们可能的大小关系有 $n!$ 种。假定在第 $m$ 次比较前，我们已能确定序列元素的大小关系一定是这 $n!$ 种中的某 $p$ 种（记作 $C_m$）中的一个，那么在经过比较 $a_i &amp;lt; a_j$ 后，若结果为真，则我们可以进一步确认实际的大小关系是这 $p$ 种中的某 $q$ 种（记作 $C_q$）中的一个；若结果为非，则我们进一步确认实际的大小关系是这 $p$ 种中的某 $r$ 种（记作 $C_r$）中的一个。$C_m$ 中每一种大小关系都至少符合 $C_q$ 和 $C_r$ 中的一种，且只符合一种，故 $p=q+r$。&lt;/p>
&lt;p>我们完全可以让每次比较后可能的大小关系的集合变为 $C_q$ 和 $C_r$ 中大小较大的那一个，即 $|C_{m+1}|=\max(q,r)\ge\dfrac{|C_m|}{2}$；在此种情况下，将可能的大小关系的集合的大小削减至 $1$ 所需的比较次数是 $\Theta(\log |C_0|)=\Theta(\log n!)$ 级别的。于是 $R(n) \in \Omega(\log n!)$。&lt;/p>
&lt;p>接下来我们研究 $\Theta(\log n!)$ 是什么。由放缩 $\left(\dfrac{n}{2}\right)^{n/2} \le n! \le n^n$ 以及 $\log (n^n)\in \Theta(n\log n),\log\left(\dfrac{n}{2}\right)^{n/2}=\dfrac{n\log\dfrac{n}{2}}{2}\in \Theta(n\log n)$ 可知 $\log n!\in \Theta(n\log n)$，即 $\Theta(\log n!)=\Theta(n\log n)$。&lt;/p>
&lt;p>也就是说，TUCS 的复杂度就是 $\Theta(n\log n)$。世界上再没有最坏情况下复杂度更好的比较排序算法了！&lt;/p></description></item><item><title>BFPRT：线性选择算法</title><link>https://www.flandre.love/zh/posts/bfprt/</link><pubDate>Tue, 04 Jul 2023 14:30:00 +0800</pubDate><guid>https://www.flandre.love/zh/posts/bfprt/</guid><description>&lt;p>选择算法（Selection Algorithm）是在一系列可比较元素中找到第 $k$ 小元素的算法。选择算法查找元素最典型的特例就是最大值和最小值，均可以 $O(n)$ 的时间复杂度完成。对于平凡的 $k$，显然也可通过排序在 $O(n \log n)$，或是堆在 $O(n \log k)$ 的时间复杂度内解决。本文章将介绍一个复杂度优于它们的选择算法，BFPRT 算法，其时间复杂度为 $O(n)$。&lt;/p>
&lt;p>让我们先了解快速选择法（Quickselect），这是快速排序的发明者 Tony Hoare 发明的另一算法。它和快速排序唯一的区别就是其只递归第 $k$ 小值所在的一侧。在理想情况下，每次取到一个接近中位数的 Pivot，可以实现 $O(n)$ 的优秀复杂度；但在最坏情况下，复杂度可达 $O(n^2)$。&lt;/p>
&lt;p>$$
\begin{array}{ll}
1 &amp;amp; \textbf{Input. }\text{1-indexed array of comparable elements } A_1, A_2, \ldots, A_n\newline
&amp;amp; \text{and positive integer } k \text{ indicating the index of the required element}\newline
2 &amp;amp; \textbf{Output. }k \text{-th smallest element of } A\newline
3 &amp;amp; \textbf{Method. }\newline
4 &amp;amp; \textbf{Function}\text{ quickselect(}A, k\text{)}\newline
5 &amp;amp; \qquad \text{select an integer } x \in [1, |A|]\newline
6 &amp;amp; \qquad \text{move all elements less than }x\text{ to the front}\newline
7 &amp;amp; \qquad \text{move all elements greater than }x\text{ to the back}\newline
8 &amp;amp; \qquad i \leftarrow \operatorname{rank}(A, x)\newline
9 &amp;amp; \qquad \textbf{if } k = i\newline
10 &amp;amp; \qquad \qquad \textbf{return } x\newline
11 &amp;amp; \qquad \textbf{else if } k &amp;lt; i\newline
12 &amp;amp; \qquad \qquad \textbf{return }\text{quickselect(}A[1&amp;hellip;i-1], k\text{)}\newline
13 &amp;amp; \qquad \textbf{else}\newline
14 &amp;amp; \qquad \qquad \textbf{return }\text{quickselect(}A[i+1&amp;hellip;|A|], k-i\text{)}\newline
15 &amp;amp; \textbf{End}\newline
16 &amp;amp; \textbf{return }\text{quickselect(}A,k\text{)}
\end{array}
$$&lt;/p>
&lt;p>问题就在于我们如何选择 Pivot。我们当然可以随机地从序列中选取 Pivot，从而取得 $O(n)$ 的期望复杂度，但我们希望有一个确定性算法。一种朴素的想法是取头、中、尾三者的中位数作为 Pivot，但内省排序的发明者 David Musser 给出了数据使这种算法达到最坏复杂度。&lt;/p>
&lt;p>包括我们熟悉的 Floyd 和 Tarjan 在内的姓氏缩写为 BFPRT 的五人给出一种选择 Pivot 的方法，使得快速选择的复杂度在最坏情况下达到 $O(n)$。&lt;/p>
&lt;p>将原序列分为 $\left\lfloor\dfrac{n}{5}\right\rfloor$ 组，每组 $5$ 个元素（多余的元素舍去），暴力算出这 $\left\lfloor\dfrac{n}{5}\right\rfloor$ 组的中位数，记作 $a_1, a_2, \ldots, a_{\lfloor n/5 \rfloor}$。递归算出 $a$ 的中位数，作为 Pivot。&lt;/p>
&lt;p>让我们来统计时间复杂度。暴力计算 $\left\lfloor\dfrac{n}{5}\right\rfloor$ 组中位数的复杂度为 $\sum O(5\log 5) = O(n)$，递归计算 $a$ 中位数的复杂度为 $T(\frac{n}{5})$，得到的 Pivot 至少大于等于 $\dfrac{n}{4}$、小于等于 $\dfrac{n}{4}$ 的数，故下一层递归至少排除了 $\dfrac{n}{4}$ 的数，复杂度为 $T(\frac{3n}{4})$。总复杂度由主定理可得为&lt;/p>
&lt;p>$$\begin{aligned}
T(n) &amp;amp;= T\left(\frac{3}{4}n\right) + T\left(\frac{n}{5}\right) + O(n)\newline
&amp;amp;= O(n)
\end{aligned}$$&lt;/p>
&lt;p>为什么分每组 $5$ 个元素而不是 $4$ 个或 $6$ 个呢？记我们分每组 $a$ 个元素，由上面的式子可知 $a&amp;gt;4$。当 $a&amp;gt;4$ 时，比较次数 $f(n)$ 满足&lt;/p>
&lt;p>$$
f(n)=
\begin{cases}
f\left(\left(\dfrac{3}{4} + \dfrac{1}{a}\right)n\right) + n \log a &amp;amp;\text{if } n \ge 5 \newline
n \log n &amp;amp;\text{if } n &amp;lt; 5
\end{cases}
$$&lt;/p>
&lt;p>得 $f(n) = \dfrac{4na\log a}{a-4}$，由 $\dfrac{\partial f}{\partial a}=4n\dfrac{a-4\log a-4}{(4-a)^2}$ 发现 $f(n)$ 在 $n=15$ 处取得最小值。退一步讲，就算我们取暴力中位数的复杂度为 $O(na)$，那最优值也应是 $8$ 而非 $5$。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;iostream&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;chrono&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;vector&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;numeric&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;cassert&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;random&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> N &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1e6&lt;/span>, K &lt;span style="color:#f92672">=&lt;/span> N &lt;span style="color:#f92672">/&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>std&lt;span style="color:#f92672">::&lt;/span>vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> src(N);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">bruteforce_kth&lt;/span>(std&lt;span style="color:#f92672">::&lt;/span>vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> arr, &lt;span style="color:#66d9ef">int&lt;/span> k) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>sort(arr.begin(), arr.end());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> arr[k &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">get_kth&lt;/span>(&lt;span style="color:#66d9ef">const&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>, &lt;span style="color:#66d9ef">int&lt;/span>, &lt;span style="color:#66d9ef">int&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">get_median&lt;/span>(&lt;span style="color:#66d9ef">const&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>arr, &lt;span style="color:#66d9ef">int&lt;/span> a) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> get_kth(arr, arr.size() &lt;span style="color:#f92672">/&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>, a);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">get_kth&lt;/span>(&lt;span style="color:#66d9ef">const&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>arr, &lt;span style="color:#66d9ef">int&lt;/span> k, &lt;span style="color:#66d9ef">int&lt;/span> a) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (arr.size() &lt;span style="color:#f92672">&amp;lt;=&lt;/span> a) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> bruteforce_kth(arr, k);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> medians;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">+&lt;/span> a &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span> arr.size(); i &lt;span style="color:#f92672">+=&lt;/span> a) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> tmp(a);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> j &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; j &lt;span style="color:#f92672">&amp;lt;&lt;/span> a; &lt;span style="color:#f92672">++&lt;/span>j) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> tmp[j] &lt;span style="color:#f92672">=&lt;/span> arr[i &lt;span style="color:#f92672">+&lt;/span> j];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> medians.push_back(bruteforce_kth(tmp, tmp.size() &lt;span style="color:#f92672">/&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> pivot &lt;span style="color:#f92672">=&lt;/span> get_median(medians, a);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> less, greater;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i : arr) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (i &lt;span style="color:#f92672">&amp;lt;&lt;/span> pivot) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> less.push_back(i);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (i &lt;span style="color:#f92672">&amp;gt;&lt;/span> pivot) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> greater.push_back(i);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (k &lt;span style="color:#f92672">&amp;lt;=&lt;/span> less.size()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> get_kth(less, k, a);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (k &lt;span style="color:#f92672">&amp;lt;=&lt;/span> arr.size() &lt;span style="color:#f92672">-&lt;/span> greater.size()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> pivot;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> get_kth(greater, k &lt;span style="color:#f92672">-&lt;/span> (arr.size() &lt;span style="color:#f92672">-&lt;/span> greater.size()), a);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">run&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> a) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">auto&lt;/span> start &lt;span style="color:#f92672">=&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>chrono&lt;span style="color:#f92672">::&lt;/span>high_resolution_clock&lt;span style="color:#f92672">::&lt;/span>now();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> assert(get_kth(src, K, a) &lt;span style="color:#f92672">==&lt;/span> K &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">auto&lt;/span> end &lt;span style="color:#f92672">=&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>chrono&lt;span style="color:#f92672">::&lt;/span>high_resolution_clock&lt;span style="color:#f92672">::&lt;/span>now();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>chrono&lt;span style="color:#f92672">::&lt;/span>duration&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">double&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> duration &lt;span style="color:#f92672">=&lt;/span> end &lt;span style="color:#f92672">-&lt;/span> start;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;a: &amp;#34;&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> a &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34; time: &amp;#34;&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> duration.count() &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34; seconds&amp;#34;&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>endl;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>mt19937 rng(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>chrono&lt;span style="color:#f92672">::&lt;/span>high_resolution_clock&lt;span style="color:#f92672">::&lt;/span>now().time_since_epoch().count());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>iota(src.begin(), src.end(), &lt;span style="color:#ae81ff">0&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>shuffle(src.begin(), src.end(), rng);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">5&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;=&lt;/span> &lt;span style="color:#ae81ff">2000&lt;/span>; &lt;span style="color:#f92672">++&lt;/span>i)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> run(i);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在实际情况下存在各种其他因子的干扰，使得 $a$ 的最优值无法简单通过理论算出。通过运行以上代码，我们可以得到对于 $10^6$ 长度的随机序列求 $k$ 最小值的用时与 $a$ 的取值的关系图像。&lt;/p>
&lt;p>&lt;img src="https://www.flandre.love/zh/images/bfprt1.png" alt="">
&lt;img src="https://www.flandre.love/zh/images/bfprt2.png" alt="">&lt;/p>
&lt;p>似乎在 $100$ 到 $200$ 之间取得较优的效率。在其他机器上运行相同代码，最优值都不同，有在 $13$ 处取得最优值的。值得一提的是，以上实现即使在最优的 $a$ 取值下相比 $O(n\log n)$ 的 &lt;code>std::sort&lt;/code> 仍然不具有显著优势。&lt;/p>
&lt;p>上述代码本可以 in-place 分割从而得到更好的效率。也许我改天会重写并测试 in-place 版的 BFPRT 算法，或许能有新的发现。&lt;/p>
&lt;h2 id="credits">Credits&lt;/h2>
&lt;p>&lt;em>&lt;a href="https://www.cs.princeton.edu/~wayne/cs423/lectures/selection-4up.pdf">Linear Time Selection&lt;/a>&lt;/em>, COS 423 Spring 2002, Kevin Wayne&lt;/p></description></item></channel></rss>