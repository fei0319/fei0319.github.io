<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>渐进复杂度 on 绯想天</title><link>https://blog.fei.ac/zh/tags/%E6%B8%90%E8%BF%9B%E5%A4%8D%E6%9D%82%E5%BA%A6/</link><description>Recent content in 渐进复杂度 on 绯想天</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>Copyright © 2020 - 2023 Fei Pan</copyright><lastBuildDate>Sun, 16 Jul 2023 23:42:10 +0800</lastBuildDate><atom:link href="https://blog.fei.ac/zh/tags/%E6%B8%90%E8%BF%9B%E5%A4%8D%E6%9D%82%E5%BA%A6/index.xml" rel="self" type="application/rss+xml"/><item><title>柯尔莫哥洛夫复杂度</title><link>https://blog.fei.ac/zh/posts/kolmogorov_complexity/</link><pubDate>Sun, 16 Jul 2023 23:42:10 +0800</pubDate><guid>https://blog.fei.ac/zh/posts/kolmogorov_complexity/</guid><description>&lt;p>柯尔莫哥洛夫复杂度（Kolmogorov Complexity）也称描述复杂度（Descriptive Complexity）、算法熵（Algorithmic Entropy），是一个衡量描述一个对象所需资源的量。具体地，对于一编程语言 $L$，对象 $s$ 的柯尔莫哥洛夫复杂度可记作 $K(s)$；它表示一个输出 $s$ 的 $L$ 程序的最小长度。&lt;/p>
&lt;p>对于 $s=\text{hellohellohellohellohello}$，用 Python 可描述为 &lt;code>'hello'*5&lt;/code>，并且我们假定这是最短的描述方法，那么对于 Python 来说 $K(s)=9$（或者，以二进制位数计的话，$K(s)=72$）。对于一些有规律或是重复性高的对象 $s$，$K(s)$ 相比 $|s|$ 大概会比较小；反之 $K(s)$ 大概会比较大。&lt;/p>
&lt;p>我们注意到对于不同语言 $L$，同一对象的柯尔莫哥洛夫复杂度的复杂度是不同的。但这无关紧要，因为对于任意语言 $L, M$ 都存在一个仅由 $L,M$ 决定的常数 $C$ 使得 $\forall s, K_M(s) \le K_L(s) + C$：以 Python 和 C 为例，我们只要一个 CPython（以及一些其他的配套设施）的额外长度，就可以用 C 语言以 Python 的柯尔莫哥洛夫复杂度表示任何对象。由以上定理，任一对象在任何两个语言下的柯尔莫哥洛夫复杂度的差都是有确定上限的，因此对于足够大的对象来讲，区分不同语言下的柯尔莫哥洛夫复杂度是无意义的。&lt;/p>
&lt;h2 id="柯尔莫哥洛夫复杂度的不可计算性">柯尔莫哥洛夫复杂度的不可计算性&lt;/h2>
&lt;p>似乎这样一个程序可以计算任一对象 $s$ 的柯尔莫哥洛夫复杂度：&lt;/p>
&lt;p>$$
\begin{array}{ll}
1 &amp;amp; \textbf{Input. }\text{Object } s\newline
2 &amp;amp; \textbf{Output. } k\text{, length of the shortest program that yields }s\newline
3 &amp;amp; \textbf{Method. }\newline
4 &amp;amp; \textbf{Function}\text{ kolmogorov(}s{)}\newline
5 &amp;amp; \qquad \textbf{for }i\text{ from }1\text{ to }+\infty\newline
6 &amp;amp; \qquad \qquad \textbf{for }\text{each }p\text{ of length }i\newline
7 &amp;amp; \qquad \qquad \qquad \textbf{if }p\text{ is a valid program and eval}(p)=s\newline
8 &amp;amp; \qquad \qquad \qquad \qquad \textbf{return }p\newline
9 &amp;amp; \textbf{End}\newline
10 &amp;amp; \textbf{return }\text{kolmogorov(}s\text{)}\newline
\end{array}
$$&lt;/p>
&lt;p>但这事实上并不可行，因为枚举的 $p$ 并不一定能在有限时间内结束，而停机问题（Halting Problem）的结论也告诉我们 $p$ 是否能在有限时间内结束是无法用算法确定的。&lt;/p>
&lt;p>柯尔莫哥洛夫复杂度是不可计算的，哪怕是在理论上。假定存在一个程序 $K$ 可以计算任意对象的柯尔莫哥洛夫复杂度，那么这样一个程序 $P$ 可以输出一个柯尔莫哥洛夫复杂度不小于 $|K|+100000$ 的对象：&lt;/p>
&lt;p>$$
\begin{array}{ll}
1 &amp;amp; \textbf{for }i\text{ from }1\text{ to }+\infty\newline
2 &amp;amp; \qquad \textbf{for }\text{each }s\text{ of length }i\newline
3 &amp;amp; \qquad \qquad \textbf{if }K(s)\ge |K|+100000\newline
4 &amp;amp; \qquad \qquad \qquad \textbf{return }s\newline
\end{array}
$$&lt;/p>
&lt;p>然而该对象事实上可以被 $K$ 和 $P$ 输出，即其可以被一个长度为 $|K|+|P|$ 小于 $|K|+100000$ 的程序输出，和其柯尔莫哥洛夫复杂度不小于 $|K|+100000$ 的性质矛盾。&lt;/p></description></item><item><title>TUCS：最终的比较排序法</title><link>https://blog.fei.ac/zh/posts/tucs/</link><pubDate>Wed, 05 Jul 2023 15:30:59 +0800</pubDate><guid>https://blog.fei.ac/zh/posts/tucs/</guid><description>&lt;p>我们所知的所有基于比较的排序算法（Comparison Sorting Algorithm）都有 $\Omega(n\log n)$ 的最坏情况下的复杂度下界。仅有桶排序和基数排序等一类非比较排序算法可以得到更好的复杂度。&lt;/p>
&lt;p>那么，是否存在一个 $o(n\log n)$ 的比较排序算法，只是我们没有发现呢？假定存在这样的算法，我们称之为 TUCS（the Ultimate Comparison Sort）。我们一眼就能看出，TUCS 的运行时间 $R(n)$ 满足 $R(n)\in O(n\log n), R(n) \in \Omega(n)$；上界由归并排序给出，下界则是由于序列中的每个元素都起码要被访问一次。&lt;/p>
&lt;p>我们发现，当序列中元素均不相等时，它们可能的大小关系有 $n!$ 种。假定在第 $m$ 次比较前，我们已能确定序列元素的大小关系一定是这 $n!$ 种中的某 $p$ 种（记作 $C_m$）中的一个，那么在经过比较 $a_i &amp;lt; a_j$ 后，若结果为真，则我们可以进一步确认实际的大小关系是这 $p$ 种中的某 $q$ 种（记作 $C_q$）中的一个；若结果为非，则我们进一步确认实际的大小关系是这 $p$ 种中的某 $r$ 种（记作 $C_r$）中的一个。$C_m$ 中每一种大小关系都至少符合 $C_q$ 和 $C_r$ 中的一种，且只符合一种，故 $p=q+r$。&lt;/p>
&lt;p>我们完全可以让每次比较后可能的大小关系的集合变为 $C_q$ 和 $C_r$ 中大小较大的那一个，即 $|C_{m+1}|=\max(q,r)\ge\dfrac{|C_m|}{2}$；在此种情况下，将可能的大小关系的集合的大小削减至 $1$ 所需的比较次数是 $\Theta(\log |C_0|)=\Theta(\log n!)$ 级别的。于是 $R(n) \in \Omega(\log n!)$。&lt;/p>
&lt;p>接下来我们研究 $\Theta(\log n!)$ 是什么。由放缩 $\left(\dfrac{n}{2}\right)^{n/2} \le n! \le n^n$ 以及 $\log (n^n)\in \Theta(n\log n),\log\left(\dfrac{n}{2}\right)^{n/2}=\dfrac{n\log\dfrac{n}{2}}{2}\in \Theta(n\log n)$ 可知 $\log n!\in \Theta(n\log n)$，即 $\Theta(\log n!)=\Theta(n\log n)$。&lt;/p>
&lt;p>也就是说，TUCS 的复杂度就是 $\Theta(n\log n)$。世界上再没有最坏情况下复杂度更好的比较排序算法了！&lt;/p></description></item></channel></rss>