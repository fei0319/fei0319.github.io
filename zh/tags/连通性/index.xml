<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>连通性 on 绯想天</title><link>https://blog.fei.ac/zh/tags/%E8%BF%9E%E9%80%9A%E6%80%A7/</link><description>Recent content in 连通性 on 绯想天</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>Copyright © 2020 - 2023 Fei Pan</copyright><lastBuildDate>Wed, 18 Jan 2023 15:24:00 +0800</lastBuildDate><atom:link href="https://blog.fei.ac/zh/tags/%E8%BF%9E%E9%80%9A%E6%80%A7/index.xml" rel="self" type="application/rss+xml"/><item><title>强连通分量和点双连通分量</title><link>https://blog.fei.ac/zh/posts/connected-component/</link><pubDate>Wed, 18 Jan 2023 15:24:00 +0800</pubDate><guid>https://blog.fei.ac/zh/posts/connected-component/</guid><description>&lt;p>强连通分量和点双连通分量是图论中常见的两个概念。算法竞赛中，我们处理它们时都要使用 Tarjan 算法，因而这二者常常被混淆。强连通分量常常被缩点代称，而点双连通分量则常被割点代称。事实上，缩点和割点并不是一组对应的概念；缩点在点双连通分量中对应的概念是圆方树，割点在强连通分量中对应的概念是割边（桥）。因此，我们要么说“强连通分量和点双连通分量”，要么说“缩点和圆方树”，要么说“割边和割点”，但是不要说“缩点和割点”。人们常将缩点和割点并称的原因可能是洛谷，其关于构造强连通分量和点双连通分量的模板题的名称分别为“缩点”和“割点”，具有很强的误导性。尤其是“缩点”和“割点”都含有“点”字，容易让初学者以为它们是对应的概念，看不透二者的真正关系。&lt;/p>
&lt;p>那么，强连通分量和点双连通分量的真正关系是什么呢？或者说，怎样才能最好地理解它们的相似性和差异性呢？&lt;/p>
&lt;p>割边和割点的关系。强连通分量是割边分隔出的点集，点双连通分量是割点分割出的点集（特别地，割点本身同时属于它四周的点双连通分量）。因此它们都可以使用 Tarjan 算法处理。在 DFS 树上，一条边 $E$ 是割边当且仅当其儿子的子树中没有指向 $E$ 的祖先（注意这里不是子树外而是祖先，因为有向图的 DFS 树形态特别）的返祖边，一个结点 $V$ 是割点当且仅当其&lt;strong>某个&lt;/strong>儿子的子树中没有指向 $V$ 的祖先的返祖边。删去强连通分量中的任何边得到的生成子图仍然连通（弱连通），删去点双连通分量中的任何结点得到的导出子图仍然连通。&lt;/p>
&lt;p>有向图和无向图的关系。强连通分量在有向图中定义，点双连通分量在无向图中定义。“任意两个结点都能够互相到达的极大子图”这一定义不能够在无向图中定义强连通分量，因为这实际上指的是连通块；但我们可以用强连通分量的另一个定义“割边分割出的点集”在无向图中定义一个与强连通分量相似的概念，即边双连通分量。因此，“割边分割出的点集”是最适合强连通分量和边双连通分量的定义，它同时适用于有向图和无向图，而强连通分量“任意两个结点都能够互相到达的极大子图”和边双连通分量“删去任意边后任意两个结点仍然连通的极大子图”这两个常见定义则只适用于有向图或无向图。&lt;/p>
&lt;p>对于有向图，我们发现，一个节点 $v$ 的父边是割边，当且仅当从 $v$ 出发无法离开 $v$ 的子树；一个节点 $v$ 是割点，当且仅当从 $v$ 出发，且不经过从 $v$ 出发的返祖边，无法离开 $v$ 的子树。&lt;/p>
&lt;p>关于为什么求强连通分量可以写 &lt;code>low[node]=min(low[node],low[to])&lt;/code> 而求点双连通分量却只能写 &lt;code>low[node]=min(low[node],dfn[node]&lt;/code> 的原因，想必读者也已经懂了。当然 &lt;code>low[node]=min(low[node],low[to])&lt;/code> 也不是一定就不能用于求割点，比如下面的代码就是可行的。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">dfs&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> node) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dfn[node] &lt;span style="color:#f92672">=&lt;/span> low[node] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">++&lt;/span>ind;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> head[node]; i; i &lt;span style="color:#f92672">=&lt;/span> edge[i].next) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>dfn[edge[i].to]) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dfs(edge[i].to);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (low[edge[i].to] &lt;span style="color:#f92672">==&lt;/span> dfn[node]) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> is_cut[node] &lt;span style="color:#f92672">=&lt;/span> true;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> head[node]; i; i &lt;span style="color:#f92672">=&lt;/span> edge[i].next) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> low[node] &lt;span style="color:#f92672">=&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>min(low[node], low[edge[i].to]);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item></channel></rss>