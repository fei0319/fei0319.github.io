<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>绯想天</title><link>https://blog.fei.ac/zh/</link><description>Recent content on 绯想天</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>Copyright © 2020 - 2023 Fei Pan</copyright><lastBuildDate>Sun, 15 Sep 2024 22:54:28 +0800</lastBuildDate><atom:link href="https://blog.fei.ac/zh/index.xml" rel="self" type="application/rss+xml"/><item><title>The 3rd Universal Cup. Stage 3: Ukraine 口胡</title><link>https://blog.fei.ac/zh/posts/ucup-3-stage-3/</link><pubDate>Sun, 15 Sep 2024 22:54:28 +0800</pubDate><guid>https://blog.fei.ac/zh/posts/ucup-3-stage-3/</guid><description>&lt;h2 id="g-goodman">G. Goodman&lt;/h2>
&lt;p>略&lt;/p>
&lt;h2 id="a-aibohphobia">A. Aibohphobia&lt;/h2>
&lt;p>对于 $n = 1$ 的情况特判。以下讨论 $n \ge 2$ 的情况。&lt;/p>
&lt;ul>
&lt;li>若仅出现一种字符，答案为负。&lt;/li>
&lt;li>若仅出现两种字符，当且仅当有一种字符出现次数为 $1$ 时答案为正。&lt;/li>
&lt;li>若出现三及以上种字符，答案为正，构造如下：所有字符出现次数均为 $1$，则构造显然；否则，存在出现次数多于 $2$ 的字符 $\texttt{a}$，构造 $\texttt{abca&amp;hellip;}$ 即满足条件。&lt;/li>
&lt;/ul>
&lt;h2 id="d-daily-disinfection">D. Daily Disinfection&lt;/h2>
&lt;p>考虑由 $\texttt{1}$ 组成的极长连续子段个数 $x$。若 $x$ 小于等于空位的个数，显然可以花费 $\texttt{1}$ 的个数的代价完成打扫。&lt;/p>
&lt;p>否则，必定有 $x - 1$ 个空位插在这 $x$ 个子段之间。设这些子段中最短者的长度为 $l$，显然可以花费 $\texttt{1}$ 的个数 + $l$ 的代价完成打扫。接下来证明这个代价是最小的：若存在一种方案，代价比上述值更小，则所有的子段都一定未完全归位；于是第 $1$ 个空位被第 $1$ 个子段的最右侧书本占据，第 $2$ 个空位被第 $2$ 个子段的最右侧书本占据，&amp;hellip;，第 $n$ 个空位被第 $n$ 个子段的最右侧书本占据，与仅有 $n - 1$ 个空位的事实不符。&lt;/p>
&lt;h2 id="e-equalizer-ehrmantraut">E. Equalizer Ehrmantraut&lt;/h2>
&lt;p>不妨令 $a_1$ 为最小的数，那么以下至少成立一个：&lt;/p>
&lt;ul>
&lt;li>$b_1 = a_1$&lt;/li>
&lt;li>$\forall i &amp;gt; 1: a_i = a_1$&lt;/li>
&lt;/ul>
&lt;p>推广该结论，得到：$(a, b)$ 合法当且仅当对于 $x = \max{a_i}$，当 $a_i &amp;lt; x$ 时 $b_i = a_i$，当 $a_i = x$ 时 $b_i \ge x$。&lt;/p>
&lt;h2 id="c-chemistry-class">C. Chemistry Class&lt;/h2>
&lt;p>将 $a$ 排序，显然答案为 $-1$ 当且仅当存在一个 $i$ 使得 $|a_{2i} - a_{2i + 1}| &amp;gt; A$。&lt;/p>
&lt;p>容易发现不存在交叉的匹配，即将 $a$ 排序后，不存在两个匹配 $(i, j)$、$(k, l)$ 使得 $i &amp;lt; k &amp;lt; j &amp;lt; l$，同时嵌套的匹配仅可嵌套一层，且外层仅能为 $A$ 型匹配，内层仅能为若干个彼此不交的 $B$ 型匹配。&lt;/p>
&lt;p>对于这种 $ABB\ldots BBA$ 型，可以证明我们要使之极长。于是可以 DP。&lt;/p>
&lt;h2 id="j-jesses-job">J. Jesse&amp;rsquo;s Job&lt;/h2>
&lt;p>若排列存在多个置换环，则显然可以将其中一个置换环染黄，其余染蓝，达成 $n$ 的分数。&lt;/p>
&lt;p>考虑排列仅有一个置换环的情况。此时对于每种颜色，都至少有一个错位，因此分数至多为 $n - 2$。接下来给出一个达成 $n - 2$ 分的分组方案：考虑将置换环分为两条链，设两条链的链头分别为 $p$ 和 $q$，则一条链多一个 $p$ 数和 $q$ 位置，另一条链多一个 $q$ 数和 $p$ 位置，我们希望这两条链都能将 $p$ 和 $q$ 在排序后匹配上，这样其余的 $n - 2$ 个匹配就都能得分。发现 $|p - q| = 1$ 时可以达成。&lt;/p>
&lt;h2 id="h-highway-hoax">H. Highway Hoax&lt;/h2>
&lt;p>将 $\texttt{F}$ 视为空，$\texttt{S}$ 视为棋子，则原题相当于：在树上有一系列棋子和有向边，棋子可以沿有向边移动并使之反向，求棋子可能的布局数。&lt;/p>
&lt;p>显然每条边至多只会被使用一次。则可以设计树形 DP：$dp_{x, 0/1}$ 表示 $x$ 所在子树，在连接 $x$ 及其父亲的边是/否使用时的布局数。该 DP 可用 FFT 优化，复杂度为 $O(n \log n)$。&lt;/p>
&lt;h2 id="f-formal-fring">F. Formal Fring&lt;/h2>
&lt;p>当 $n$ 仅有一位时（即 $n = 1$），答案为 $1$。&lt;/p>
&lt;p>否则 $n$ 至少有两位。考虑将 $n$ 二进制拆分，得到一系列形如 $2^{b_i}$ 的数（$b_0 &amp;gt; b_1 &amp;gt; \ldots &amp;gt; b_k$），可以证明所有的拆分方案都可通过对这 $k$ 个数进一步拆分得到。&lt;/p>
&lt;p>若 $b_0 &amp;gt; b_1 + 1$，即 $n$ 的最高两位为 $10$，则拆分方案合法当且仅当 $2^{b_0}$ 不被拆分。因为当 $2^{b_0}$ 被拆分为两个 $2^{b_0-1}$ 后，其中一个 $2^{b_0-1}$ 单独成组，其余数共成一组，即构成违例，在此基础上任何进一步的拆分得到的方案也同样违例。令 $f(x)$ 为对 $x$ 任意拆分的方案数，则此情况下答案为 $f(n - 2^{b_0})$。&lt;/p>
&lt;p>若 $b_0 = b_1 + 1$，即 $n$ 的最高两位为 $11$，则 $2^{b_0}$ 不拆分时合法。接下来讨论 $2^{b_0}$ 被拆分的情况，即有三个 $2^{b_1}$。若不拆分这三个 $2^{b_1}$，则方案显然合法；若拆分这三个 $2^{b_1}$ 中的一或更多个，则方案不合法，证明如下：&lt;/p>
&lt;p>拆分方案合法当且仅当任意一部分数的和与其余数的和的差都大于 $n - 2^{b_0}$。若拆分三个 $2^{b_1}$ 中的一个，即可将得到的 $[2^{b_1}, 2^{b_1}, 2^{b_1-1}, 2^{b_1-1}]$ 平均分配到两组，其余数统一分配给某一组，此时两组之差为 $n - 2^{b_0} - 2^{b_1}$，是为违例。若拆分更多 $2^{b_1}$ 同样违例。&lt;/p>
&lt;h2 id="i-increasing-income">I. Increasing Income&lt;/h2>
&lt;p>原题意可以抽象为：给定一系列二维点 $(x_i, y_i)$，寻找一个排列最大化前缀最大 $x$ 和前缀最大 $y$ 的总数。&lt;/p>
&lt;p>该问题显然有多项式复杂度解法：设 $dp_{x, y}$ 表示已选的数中第一维最大值为 $x$，第二维最大值为 $y$ 时前缀最大值总数的最大值，有转移方程：&lt;/p>
&lt;p>$$dp_{\max{x, x_i}, \max{y, y_i}} = \max{dp_{x, y} + [x_i &amp;gt; x] + [y_i &amp;gt; y] | x_i &amp;gt; x \lor y_i &amp;gt; y }$$&lt;/p>
&lt;p>该 DP 可用树状数组优化至 $O(n \log n)$ 的时间复杂度。&lt;/p>
&lt;h2 id="b-breaking-bad">B. Breaking Bad&lt;/h2>
&lt;p>若存在某四个格子 $(x, y), (u, v), (x, v), (u, y)$ 满足 $a_{x, y} + a_{u, v} \neq a_{x, v} + a_{u, y} \pmod 5$，则显然至少存在两种结果。进一步地，若存在四个彼此不共行列的四元组，则答案为 $\texttt{YYYYY}$。&lt;/p>
&lt;p>若四元组个数小于等于三个，则将他们对应的至多 $6$ 行和 $6$ 列交换至左上角。由于右下角的 $n - 6$ 行 $n - 6$ 列无论如何选择结果均相同，能够用状压 DP 求出最终能得到的数。&lt;/p>
&lt;h2 id="k-knocker">K. Knocker&lt;/h2>
&lt;p>如果我们要求每次操作的参数 $x$ 需满足 $x &amp;gt; \lfloor\max{a_i}/2\rfloor$，那么依然能够得到原本能够得到的所有结果。证明：要求操作 $x$ 前，必须操作一遍 $2x, 3x, \ldots \lfloor 500/x \rfloor \cdot x$，这对结果无影响，同时也能保证 $x &amp;gt; \lfloor\max{a_i}/2\rfloor$。&lt;/p>
&lt;p>于是操作不再视作对所有数取模，而是对所有大于等于 $x$ 的 $a_i$ 减去 $x$。进一步地，我们发现能够在仅对每个数操作一次的情况下达成所有可能的结果。证明：假设第 $i$ 个数最终一共被减去了 $d_i$，将 ${d_i}$ 中元素从大到小依次操作，任意时刻必然仍满足 $d &amp;gt; \lfloor\max{a_i}/2\rfloor$。此外，由于 $\min{d_i} &amp;gt; \max{a_i - d_i}$，任何一个 $a_i$ 也不会被多个 $d_i$ 减。&lt;/p>
&lt;p>于是可以 DP 求解。&lt;/p></description></item><item><title>luogu/P9170 [省选联考 2023] 填数游戏</title><link>https://blog.fei.ac/zh/posts/luogu/p9170/</link><pubDate>Sat, 08 Jun 2024 20:08:21 +0800</pubDate><guid>https://blog.fei.ac/zh/posts/luogu/p9170/</guid><description>&lt;blockquote>
&lt;p>对于 $i = 1 \ldots n$，Alice 需要从 $S_i$ 中选择一个数作为 $a_i$；在这之后，Bob 需要从 $T_i$ 中选择 $b_i$。其中 $1 \le |S_i|, |T_i| \le 2$。&lt;/p>
&lt;p>设 $X = \sum\limits_{i=1}^n [a_i = b_i]$。Alice 的目标是最大化 $X$，Bob 的目标是在保证 $b_i$ 互不相同的前提下最小化 $X$。判断 Bob 能否保证 $b_i$ 互不相同，并在他能时求最终 $X$ 的值。&lt;/p>
&lt;/blockquote>
&lt;p>将每个 $T_i = \{u_i, v_i\}$ 转化为一条边 $(u_i, v_i)$ (特别的，$|T_i| = 1$ 时转化为一条自环)，则显然 Bob 能保证 $b_i$ 互不相同的充要条件是图为一个由基环树或树构成的森林 (即每个连通块 $C$ 含有的边数小于等于 $|C|$)。&lt;/p>
&lt;p>接下来考虑 $X$。对于基环树，树边只有一种选法，所有环边作为一个整体共有两种选法。对于 Alice 的每个 $S_i$，记录 $S_i$ 中选项对 Bob 选法的贡献，最大化其对 Bob 两种选法产生的总贡献的最小值，贪心即可。&lt;/p>
&lt;p>对于树，显然其中恰好有一个节点未被任何边占用，每个节点未被占用都对应 Bob 的一种选法，故 Bob 共有 $|C|$ 种选法，记其中不占用节点 $x$ 的选法为 $D_x$。对于 Alice 的一条边 $(u_i, v_i)$，若其选择了 $u_i$，则对于所有 $u_i$ 子树外的节点 $x$，当 Bob 使用 $D_x$ 时，Alice 的这种选法都会对 $X$ 产生 $1$ 的贡献。形式化地，记 Bob 选用 $D_x$ 时 $X$ 的值为 $F_x$，则 Alice 选用 $u_i$ 的效果为：$\forall x \notin \mathrm{subtree}(u_i): F_x \gets F_x + 1$。Alice 的目标是最大化 $\min\limits_{x} F_x$。&lt;/p>
&lt;p>显然这个问题可以利用树形 DP 在 $O(n^3)$ 的时间复杂度内解决。然而我们需要更快的解法。&lt;/p>
&lt;p>通过观察不难发现存在一个 Alice 的最优选法，其中存在一个点 $x$，将树以 $x$ 为根，Alice 所有边都选用深度较大的节点。因为对于两个 Alice 的边 $(p, q)$ 和 $(q, r)$，不应两条边都选取 $q$，这样劣于两条边分别选取 $p$、$r$；根据这样的决策原则，可以确定存在一个最优选法为所有边都选深度较大的节点。于是我们可以在 $O(n\log n)$ 的时间内通过 DFS 和线段树得到以所有点为根时 $\min\limits_{x} F_x$ 的值。&lt;/p>
&lt;p>代码：&lt;a href="https://github.com/fei0319/competitive-programming/blob/main/code/luogu/P9170.cpp">https://github.com/fei0319/competitive-programming/blob/main/code/luogu/P10547.cpp&lt;/a>&lt;/p></description></item><item><title>luogu/P10547 [THUPC2024] 排列游戏</title><link>https://blog.fei.ac/zh/posts/luogu/p10547/</link><pubDate>Mon, 03 Jun 2024 19:45:40 +0800</pubDate><guid>https://blog.fei.ac/zh/posts/luogu/p10547/</guid><description>&lt;blockquote>
&lt;p>对于一 $1$ 至 $n$ 的排列 $p$，若交换 $p_i$ 和 $p_j$ 的代价为 $|i - j|$，则定义 $p$ 的值为将 $p$ 变为 $1, 2, \ldots, n$ 的最小代价。&lt;/p>
&lt;p>求能够由 $1, 2, \ldots, n$ 进行恰好 $n$ 次交换得到，且值小于等于 $m$ 的排列的个数。&lt;/p>
&lt;/blockquote>
&lt;p>显然 $p$ 的值小于等于 $m$ 等价于 $\sum\limits_{i=1}^n |p_i - i| \le 2m$。其必要性显然，充分性可由直接沿置换环交换证明。&lt;/p>
&lt;p>对 $\sum\limits_{i=1}^n |p_i - i| \le 2m$ 进行转化后可得：$n$ 个点分别位于数轴 $1, 2, \ldots, n$ 处，计算每个点出度入度均为 $1$ 且总边长不大于 $2m$ 的连边方案数。考虑前 $i$ 个点，若有 $x$ 条边起点终点都在前 $i$ 个点，则有 $j = i - x$ 条边从后 $n - i$ 个点连向前 $i$ 个点，$j$ 条边从前 $i$ 个点连向后 $n - i$ 个点。&lt;/p>
&lt;p>将起点终点都在前 $i$ 个点的边称为内边，起点终点中恰好有一个在前 $i$ 个点的边称为外边（恰好有 $2j$ 个），可以设计动态规划状态：$dp_{i, j, k}$ 表示前 $i$ 个点共有 $j$ 条外边，且内边长度以及外边在第 $i$ 个点之前的长度的和为 $k$ 的方案数。这样有转移方程 $dp_{i, j, k} \rightarrow dp_{i + 1, j - 1 | j | j + 1, k + 2j}$ ($j \pm 1 \ge 0$)，可以 $O(n^2m)$ 求解。&lt;/p>
&lt;p>进一步研究，发现对于任意满足 $dp_{i, j, k} \neq 0$ 的 $i, j, k$，都有 $k \ge j(j + 1)$，故 $j$ 这一维只需要枚举到 $\sqrt{m}$ 级别，复杂度优化为 $O(nm\sqrt{m})$，可以通过本题不限制交换 $n$ 次的版本。在状态中加入置换环的个数的奇偶性，即可通过本题。&lt;/p>
&lt;p>代码：&lt;a href="https://github.com/fei0319/competitive-programming/blob/main/code/luogu/P10547.cpp">https://github.com/fei0319/competitive-programming/blob/main/code/luogu/P10547.cpp&lt;/a>&lt;/p></description></item><item><title>定阶矩阵计数</title><link>https://blog.fei.ac/zh/posts/matrix-rank/</link><pubDate>Thu, 25 Jan 2024 01:27:31 +0800</pubDate><guid>https://blog.fei.ac/zh/posts/matrix-rank/</guid><description>&lt;p>考虑这样一类问题：有多少个在模 $p$ 的剩余系中的 $n \times m$（$n \ge m$）矩阵阶为 $r$？容易设计一个 $O(nr)$ 的动态规划来解决该问题，而本文将介绍一个 $O(r)$ 的算法。&lt;/p>
&lt;p>原题等价于在 $n$ 维向量空间中确定 $m$ 个向量，使其线性生成空间的维度为 $r$。则可以通过先确定 $n$ 维空间的一个 $r$ 维子空间，再在 $r$ 维子空间中确定包含 $m$ 个向量的秩为 $r$ 的向量组。于是原题的答案为以下两个子问题的答案的积：&lt;/p>
&lt;ol>
&lt;li>$n$ 维向量空间有多少个不同的 $r$ 维子空间？&lt;/li>
&lt;li>$r$ 维空间中有多少个秩为 $r$、大小为 $m$ 的向量组？&lt;/li>
&lt;/ol>
&lt;h2 id="子问题-1">子问题 1&lt;/h2>
&lt;p>要在 $n$ 维空间中确定一个 $r$ 维子空间，不妨先确定一组大小为 $r$ 的基向量。对于该组基向量中的第 $i$ 个向量 $v_i$，其不能表示为 $v_1, v_2, \ldots, v_{i-1}$ 的线性组合，但可以取任意其他值，于是其可选的值有 $p^n - p^{i-1}$ 个，于是 $n$ 维向量空间中总共有 $\prod_{i=1}^r \left(p^n - p^{i-1}\right)$ 组基。&lt;/p>
&lt;p>不过这并不是 $r$ 维子空间的个数，因为每个 $r$ 维子空间都可以被不止一组基确认。具体地，每个 $r$ 维子空间都可以被 $\prod_{i=1}^r \left(p^r - p^{i-1}\right)$ 组基确定，于是 $n$ 维向量空间中的 $r$ 维子空间个数为&lt;/p>
&lt;p>$$
\dfrac{\prod_{i=1}^r \left(p^n - p^{i-1}\right)}{\prod_{i=1}^r \left(p^r - p^{i-1}\right)}
$$&lt;/p>
&lt;h2 id="子问题-2">子问题 2&lt;/h2>
&lt;p>该子问题等价于求秩为 $r$ 的 $m \times r$ 矩阵个数。类似于子问题 1，该矩阵的第 $i$ 列要与前 $i-1$ 列线性无关，有 $p^m - p^{i-1}$ 种取值；矩阵总个数为 $\prod_{i=1}^r \left(p^m - p^{i-1}\right)$。&lt;/p>
&lt;p>整合上述两问题的结果，得到原题的答案为&lt;/p>
&lt;p>$$
\dfrac{\prod_{i=1}^r \left(p^n - p^{i-1}\right)\prod_{i=1}^r \left(p^m - p^{i-1}\right)}{\prod_{i=1}^r \left(p^r - p^{i-1}\right)}
$$&lt;/p>
&lt;p>如果将求逆元视作常数复杂度的，则该数可 $O(r)$ 求出。稍作处理，亦可 $O(n)$ 时间内求出 $r=1,2,\ldots,n$ 时的所有答案；见 &lt;a href="https://codeforces.com/contest/1916/problem/H2">CF1916H2&lt;/a>。&lt;/p></description></item><item><title>生成函数幂科技</title><link>https://blog.fei.ac/zh/posts/power-of-gf/</link><pubDate>Sun, 06 Aug 2023 13:10:58 +0800</pubDate><guid>https://blog.fei.ac/zh/posts/power-of-gf/</guid><description>&lt;p>给定 $F(z) = \sum\limits_{i=0}^n f_i x^i$，如何求出 $F^k \bmod x^m$？这样一个问题可以用快速幂在 $O(m\log m\log k)$ 的时间复杂度内解决，亦可以通过&lt;a href="https://blog.fei.ac/zh/posts/polylog/">多项式对数指数&lt;/a>在 $O(m \log m)$ 的时间复杂度内解决。但假定 $m$ 特别大，$n$ 特别小（$m=10^7,n=5$），那我们如何解决？&lt;/p>
&lt;p>这就需要这样一个 $O(nm)$ 的生成函数幂科技了。令 $G=F^k$，我们有 $G^\prime=kF^\prime F^{k-1}$，故 $FG^\prime = kF^\prime G$。考虑 $x^i$ 项的系数，有&lt;/p>
&lt;p>$$
\sum_{j=0}^{i+1} jf_{i-j+1} g_{j} = \sum_{j=0}^{i+1}k(i-j+1)f_{i-j+1} g_{j}
$$&lt;/p>
&lt;p>根据 $g_{0}, g_{1}, \ldots, g_i$ 就可以 $O(m)$ 地计算 $g_{i+1}$ 了；而常数项 $g_0=f_0^k$。&lt;/p>
&lt;p>这个方法不止适用于整数的 $k$，还适用于有理数的 $k$；不止适用于 OGF，还适用于 DGF。下面介绍一个计算 DGF 的 $k$ 次方根的例子。&lt;/p>
&lt;p>给定 $F(z) = \sum\limits_{i=1}^n \dfrac{f_i}{i^z}$，求 $G$ 使得 $F=G^k$。不失一般性，我们只需求 $F^k$（$k$ 为有理数）；令 $G=F^k$，由上题结论可知 $FG^\prime = kF^\prime G$。考察 $F^\prime$，可知 $F^\prime = \sum\limits_{i=1}^n -\dfrac{\ln if_i}{i^z}$，故&lt;/p>
&lt;p>$$
\sum_{d\mid i} \ln d f_{i/d}g_d = \sum_{d\mid i} k\ln\frac{i}{d} f_{i/d}g_d
$$&lt;/p>
&lt;p>只要知道前面的 $g$，就可以 $O(\log n)$ 的平均复杂度求 $g_i$ 了。不过有一个问题仍待解决：在剩余系中 $\ln i$ 是什么？这甚至都不是离散对数，因为它的底不在剩余系中。为了规避这个问题，我们需要另一个 $\operatorname{t}$ 算子来取代微分算子。它需要具有某些和微分算子相同的特性，从而可以有 $F\operatorname{t}(G) = k\operatorname{t}(F) G$。&lt;/p>
&lt;p>$F\operatorname{t}(G) = k\operatorname{t}(F) G$ 可以由 $\operatorname{d} uv = v\operatorname{d}u + u\operatorname{d}v$ 推出，故只要我们的 $\operatorname{t}$ 算子也满足 $\operatorname{t} uv = v\operatorname{t}u + u\operatorname{t}v$ 即可。如果我们规定 $\operatorname{t}(F)=\sum\limits_{i=1}^n \dfrac{\Omega(i)f_i}{i^z}$，其中 $\Omega(i)$ 为 $i$ 的质因子幂次和，那么我们就得到了一个满足条件的 $\operatorname{t}$ 算子，于是&lt;/p>
&lt;p>$$
\sum_{d\mid i} \Omega(d) f_{i/d}g_d = \sum_{d\mid i} k\Omega\left(\frac{i}{d}\right) f_{i/d}g_d
$$&lt;/p>
&lt;p>事实上任何满足 $p(xy) = p(x) + p(y)$ 且 $\forall x &amp;gt; 0, p(x) \neq 0$ 的数论函数都可用于取代 $\Omega$。&lt;/p>
&lt;h2 id="credits">Credits&lt;/h2>
&lt;p>&lt;em>&lt;a href="https://codeforces.com/blog/entry/76447">A problem collection of ODE and differential technique&lt;/a>&lt;/em>, amiya&lt;/p></description></item><item><title>柯尔莫哥洛夫复杂度</title><link>https://blog.fei.ac/zh/posts/kolmogorov-complexity/</link><pubDate>Sun, 16 Jul 2023 23:42:10 +0800</pubDate><guid>https://blog.fei.ac/zh/posts/kolmogorov-complexity/</guid><description>&lt;p>柯尔莫哥洛夫复杂度（Kolmogorov Complexity）也称描述复杂度（Descriptive Complexity）、算法熵（Algorithmic Entropy），是一个衡量描述一个对象所需资源的量。具体地，对于一编程语言 $L$，对象 $s$ 的柯尔莫哥洛夫复杂度可记作 $K(s)$；它表示一个输出 $s$ 的 $L$ 程序的最小长度。&lt;/p>
&lt;p>对于 $s=\text{hellohellohellohellohello}$，用 Python 可描述为 &lt;code>'hello'*5&lt;/code>，并且我们假定这是最短的描述方法，那么对于 Python 来说 $K(s)=9$（或者，以二进制位数计的话，$K(s)=72$）。对于一些有规律或是重复性高的对象 $s$，$K(s)$ 相比 $|s|$ 大概会比较小；反之 $K(s)$ 大概会比较大。&lt;/p>
&lt;p>我们注意到对于不同语言 $L$，同一对象的柯尔莫哥洛夫复杂度的复杂度是不同的。但这无关紧要，因为对于任意语言 $L, M$ 都存在一个仅由 $L,M$ 决定的常数 $C$ 使得 $\forall s, K_M(s) \le K_L(s) + C$：以 Python 和 C 为例，我们只要一个 CPython（以及一些其他的配套设施）的额外长度，就可以用 C 语言以 Python 的柯尔莫哥洛夫复杂度表示任何对象。由以上定理，任一对象在任何两个语言下的柯尔莫哥洛夫复杂度的差都是有确定上限的，因此对于足够大的对象来讲，区分不同语言下的柯尔莫哥洛夫复杂度是无意义的。&lt;/p>
&lt;h2 id="柯尔莫哥洛夫复杂度的不可计算性">柯尔莫哥洛夫复杂度的不可计算性&lt;/h2>
&lt;p>似乎这样一个程序可以计算任一对象 $s$ 的柯尔莫哥洛夫复杂度：&lt;/p>
&lt;p>$$
\begin{array}{ll}
1 &amp;amp; \textbf{Input. }\text{Object } s\newline
2 &amp;amp; \textbf{Output. } k\text{, length of the shortest program that yields }s\newline
3 &amp;amp; \textbf{Method. }\newline
4 &amp;amp; \textbf{Function}\text{ kolmogorov(}s{)}\newline
5 &amp;amp; \qquad \textbf{for }i\text{ from }1\text{ to }+\infty\newline
6 &amp;amp; \qquad \qquad \textbf{for }\text{each }p\text{ of length }i\newline
7 &amp;amp; \qquad \qquad \qquad \textbf{if }p\text{ is a valid program and eval}(p)=s\newline
8 &amp;amp; \qquad \qquad \qquad \qquad \textbf{return }p\newline
9 &amp;amp; \textbf{End}\newline
10 &amp;amp; \textbf{return }\text{kolmogorov(}s\text{)}\newline
\end{array}
$$&lt;/p>
&lt;p>但这事实上并不可行，因为枚举的 $p$ 并不一定能在有限时间内结束，而停机问题（Halting Problem）的结论也告诉我们 $p$ 是否能在有限时间内结束是无法用算法确定的。&lt;/p>
&lt;p>柯尔莫哥洛夫复杂度是不可计算的，哪怕是在理论上。假定存在一个程序 $K$ 可以计算任意对象的柯尔莫哥洛夫复杂度，那么这样一个程序 $P$ 可以输出一个柯尔莫哥洛夫复杂度不小于 $|K|+100000$ 的对象：&lt;/p>
&lt;p>$$
\begin{array}{ll}
1 &amp;amp; \textbf{for }i\text{ from }1\text{ to }+\infty\newline
2 &amp;amp; \qquad \textbf{for }\text{each }s\text{ of length }i\newline
3 &amp;amp; \qquad \qquad \textbf{if }K(s)\ge |K|+100000\newline
4 &amp;amp; \qquad \qquad \qquad \textbf{return }s\newline
\end{array}
$$&lt;/p>
&lt;p>然而该对象事实上可以被 $K$ 和 $P$ 输出，即其可以被一个长度为 $|K|+|P|$ 小于 $|K|+100000$ 的程序输出，和其柯尔莫哥洛夫复杂度不小于 $|K|+100000$ 的性质矛盾。&lt;/p></description></item><item><title>无损压缩算法基础及效率分析</title><link>https://blog.fei.ac/zh/posts/compression-complexity/</link><pubDate>Fri, 14 Jul 2023 16:43:08 +0800</pubDate><guid>https://blog.fei.ac/zh/posts/compression-complexity/</guid><description>&lt;h2 id="前缀码">前缀码&lt;/h2>
&lt;p>在数据压缩时，我们为每个符号分配一个编码，实现源数据和压缩数据的互相转换。然而，在解压缩（Decompression）的过程中，对编码的不同划分方式会造成歧义。例如，对于如下编码表&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">符号&lt;/th>
&lt;th style="text-align:center">编码&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">a&lt;/td>
&lt;td style="text-align:center">0&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">b&lt;/td>
&lt;td style="text-align:center">1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">c&lt;/td>
&lt;td style="text-align:center">01&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>编码串 01 既可解码为 ab 也可解码为 c。一种解决方法是人为增加分隔符，这样就要引入 0 和 1 之外的第三种编码符，需要占用约 $\log_2 3 \approx 1.58$ 倍于二进制编码的空间。于是我们寻求一种不需要分割符的编码方式。&lt;/p>
&lt;p>如果任意一个编码都不是另一编码的前缀，则任意编码串都只有唯一的解码方式。具体地，对于下标从 $1$ 起计的编码串 $s$（$\Sigma=\{0, 1\}$），显然至少存在一个正整数 $k$ 使得 $s_{1\dots k}$ 是合法编码；若存在另一正整数 $k^\prime$ 使 $s_{1\dots k^\prime}$ 是合法编码，则某一编码是另一编码的前缀，与条件矛盾，故 $s$ 能且仅能在第 $1$ 个至 $k$ 个编码符间划分出第一个符号；归纳地推导，可知 $s$ 有唯一的解码方式。&lt;/p>
&lt;p>这样互相不为前缀的编码系统被称为前缀码（Prefix Code）。为了不成为其他编码的前缀，某些编码不能够被使用，导致前缀码的编码平均长度大于朴素的二进制编码；但这种代价相比分隔符带来的代价是可接受的。&lt;/p>
&lt;h2 id="香农-范诺编码">香农-范诺编码&lt;/h2>
&lt;p>香农-范诺编码（Shannon-Fano Coding）是一种为符号集构造前缀码的算法。在香农-范诺编码算法中，我们需要构造一棵有 $|\Sigma|$ 个叶子节点的树，每条指向左儿子的路径代表 0，指向右儿子的路径代表 1，从根节点到符号对应的叶子节点的路径上的数码构成了该符号的编码。显然这种构造方法能够保证前缀码互不为前缀的性质。&lt;/p>
&lt;p>为了使最终编码的压缩数据最小，香农-范诺编码算法还要求我们统计每个符号在原数据中的出现频率 $f_c$。每次将当前节点的所有字符分为出现频率总和接近的两组，分别放入左儿子和右儿子；这样，出现频率较高的符号所在节点的深度“应该”会浅一些。&lt;/p>
&lt;p>$$
\begin{array}{ll}
1 &amp;amp; \textbf{Input. }\text{Symbolset to be encoded } \Sigma \text{ where } |\Sigma|&amp;gt;1\newline
&amp;amp; \text{and symbols&amp;rsquo; frequencies in original data }f\newline
2 &amp;amp; \textbf{Output. } \text{A mapping from symbols in } \Sigma \text{ to binary codes}\newline
3 &amp;amp; \textbf{Method. }\newline
3 &amp;amp; \text{Creat an empty mapping }m\newline
5 &amp;amp; \textbf{Function}\text{ encode(}\Sigma, s\text{)}\newline
6 &amp;amp; \qquad \textbf{if } |\Sigma|=1\newline
7 &amp;amp; \qquad \qquad c \text{ is the only symbol in }\Sigma\newline
8 &amp;amp; \qquad \qquad m[c]\leftarrow s\newline
9 &amp;amp; \qquad \qquad \textbf{return}\newline
10 &amp;amp; \qquad \text{Divide } \Sigma \text{ into two parts } \Sigma_0, \Sigma_1 \text{ such that } \left|\sum\limits_{\Sigma_0}f-\sum\limits_{\Sigma_1}f\right| \text{ is minimized}\newline
11 &amp;amp; \qquad \text{encode(}\Sigma_0, \overline{s0}\text{)}\newline
12 &amp;amp; \qquad \text{encode(}\Sigma_1, \overline{s1}\text{)}\newline
13 &amp;amp; \qquad \textbf{return}\newline
14 &amp;amp; \textbf{End}\newline
15 &amp;amp; \text{encode(}\Sigma, \sigma\text{)}\newline
16 &amp;amp; \textbf{return }m
\end{array}
$$&lt;/p>
&lt;h2 id="哈夫曼编码">哈夫曼编码&lt;/h2>
&lt;p>哈夫曼编码（Huffman Coding）是一种更为简单的编码算法。每次我们选择子树中总频率最小的两个节点，作为一个新节点的两个儿子；经过 $n-1$ 次合并后，得到一颗编码树。&lt;/p>
&lt;p>哈夫曼编码构造的编码在所有的前缀单字符编码中具有最小的加权平均编码长度。注意到所有的编码树都可以通过这种自底到顶合并子树的方法构造，因此我们只需要证明哈夫曼编码给出了最优的合并方法。&lt;/p>
&lt;p>&lt;strong>引理 1.&lt;/strong> 对于两组数量相同的节点 $A,B$，若 $A$ 中除了两个节点外，其余节点均可以与 $B$ 中节点一一组成总频率相同的配对，设 $A,B$ 中两个未配对节点的总频率分别为 $a_1,a_2,b_1,b_2$，形式化地，&lt;/p>
&lt;p>$$\begin{aligned}
f(A)=\{x_1,x_2,\ldots,x_n,a_1,a_2\},\newline
f(B)=\{x_1,x_2,\ldots,x_n,b_1,b_2\},\newline
a_1\le a_2, b_1\le b_2,\newline
a_1\neq b_1, a_2\neq b_2,\newline
\sum x_i + \sum a_i=\sum x_i + \sum b_i=1
\end{aligned}$$&lt;/p>
&lt;p>若有 $a_1&amp;lt;b_1$ (同时 $a_2&amp;gt;b_2$)，则 $A$ 的最优的加权平均编码长度不大于 $B$ 的。&lt;/p>
&lt;p>&lt;strong>证明 1.&lt;/strong> 假定 $B$ 取得最优的加权平均编码长度时，其各节点对应的长度分别为 $l_1,l_2,\ldots,l_n,L_1,L_2$。易知 $L_1\le L_2$，否则 $l_1,l_2,\ldots,l_n,L_2,L_1$ 更优。令 $A$ 以相同方式编码，则 $A$ 的加权平均编码长度为&lt;/p>
&lt;p>$$\sum x_il_i + a_1L_1 + a_2L_2$$&lt;/p>
&lt;p>由 $a_1\le a_2, b_1 \le b_2, a_1+a_2=b_1+b_2, a_1&amp;lt;b_1, L_1\le L_2$ 可知 $a_1L_1+a_2L_2 \le b_1L_1 + b_2L_2$，即在该编码方式下$A$ 的加权平均编码长度不大于 $B$ 的最优的加权平均编码长度。&lt;/p>
&lt;p>&lt;strong>引理 2.&lt;/strong> 对于一系列总数多于 $3$ 的、总频率为 $f(A)=\{a_1,a_2,\ldots,a_n\}$（$a_1\le a_2\le\ldots\le a_n$）的节点 $A$，在其所有最优的编码方式中，至少有一种直接合并了 $a_1,a_2$。&lt;/p>
&lt;p>&lt;strong>证明 2.&lt;/strong> 通过以下三种合并方式，可以得到所有的不直接合并 $a_1, a_2$ 的编码方式：&lt;/p>
&lt;p>&lt;strong>I.&lt;/strong> 先合并 $a_1,a_i$，再合并 $a_2,a_j$（$i\neq j,i &amp;gt; 2,j&amp;gt;2$），再合并剩余节点&lt;/p>
&lt;p>设在这种情况下得到了总频率为 $x_1,x_2,\ldots,x_{n-2},a_1+a_i,a_2+a_j$ 的一系列节点。若先合并 $a_1,a_2$，再合并 $a_i,a_j$，可以得到总频率为 $x_1,x_2,\ldots,x_{n-2},a_1+a_2,a_i+a_j$ 的一系列节点。两种方式的前两次合并都增加了 $a_1+a_2+a_i+a_j$ 的等量加权平均编码长度，由引理 1 可知在后续合并中后者得到的加权平均编码长度不多于前者；故后者是一种至少不劣于前者的合并方式。&lt;/p>
&lt;p>&lt;strong>II.&lt;/strong> 先合并 $a_1,a_i$，再合并 $a_2,a_1+a_i$（$i&amp;gt;2$），再合并剩余节点&lt;/p>
&lt;p>设在这种情况下得到了总频率为 $x_1,x_2,\ldots,x_{n-2},a_1+a_2+a_i$ 的一系列节点。若先合并 $a_1,a_2$，再合并 $a_1+a_2,a_i$，则同样可以得到总频率为 $x_1,x_2,\ldots,x_{n-2},a_1+a_2+a_i$ 的一系列节点，且在前两次合并中得到的加权平均编码长度 $a_1+a_2+a_1+a_2+a_i \le a_1+a_i+a_1+a_2+a_i$。&lt;/p>
&lt;p>&lt;strong>III.&lt;/strong> 先合并 $a_2,a_i$，再合并 $a_1,a_2+a_i$（$i&amp;gt;2$），再合并剩余节点&lt;/p>
&lt;p>同 II，直接合并 $a_1,a_2$ 可以得到不大于 III 的加权平均编码长度。&lt;/p>
&lt;p>即对于所有的不直接合并 $a_1, a_2$ 的编码方式，都存在至少一种直接合并 $a_1, a_2$ 的编码方式不劣于之，故在所有最优的编码方式中，至少有一种直接合并了 $a_1,a_2$。&lt;/p>
&lt;p>有了引理 2，就可以用数学归纳法证明哈夫曼编码的最优性了。&lt;/p>
&lt;h2 id="兰波-立夫-卫曲编码">兰波-立夫-卫曲编码&lt;/h2></description></item><item><title>TUCS：最终的比较排序法</title><link>https://blog.fei.ac/zh/posts/tucs/</link><pubDate>Wed, 05 Jul 2023 15:30:59 +0800</pubDate><guid>https://blog.fei.ac/zh/posts/tucs/</guid><description>&lt;p>我们所知的所有基于比较的排序算法（Comparison Sorting Algorithm）都有 $\Omega(n\log n)$ 的最坏情况下的复杂度下界。仅有桶排序和基数排序等一类非比较排序算法可以得到更好的复杂度。&lt;/p>
&lt;p>那么，是否存在一个 $o(n\log n)$ 的比较排序算法，只是我们没有发现呢？假定存在这样的算法，我们称之为 TUCS（the Ultimate Comparison Sort）。我们一眼就能看出，TUCS 的运行时间 $R(n)$ 满足 $R(n)\in O(n\log n), R(n) \in \Omega(n)$；上界由归并排序给出，下界则是由于序列中的每个元素都起码要被访问一次。&lt;/p>
&lt;p>我们发现，当序列中元素均不相等时，它们可能的大小关系有 $n!$ 种。假定在第 $m$ 次比较前，我们已能确定序列元素的大小关系一定是这 $n!$ 种中的某 $p$ 种（记作 $C_m$）中的一个，那么在经过比较 $a_i &amp;lt; a_j$ 后，若结果为真，则我们可以进一步确认实际的大小关系是这 $p$ 种中的某 $q$ 种（记作 $C_q$）中的一个；若结果为非，则我们进一步确认实际的大小关系是这 $p$ 种中的某 $r$ 种（记作 $C_r$）中的一个。$C_m$ 中每一种大小关系都至少符合 $C_q$ 和 $C_r$ 中的一种，且只符合一种，故 $p=q+r$。&lt;/p>
&lt;p>我们完全可以让每次比较后可能的大小关系的集合变为 $C_q$ 和 $C_r$ 中大小较大的那一个，即 $|C_{m+1}|=\max(q,r)\ge\dfrac{|C_m|}{2}$；在此种情况下，将可能的大小关系的集合的大小削减至 $1$ 所需的比较次数是 $\Theta(\log |C_0|)=\Theta(\log n!)$ 级别的。于是 $R(n) \in \Omega(\log n!)$。&lt;/p>
&lt;p>接下来我们研究 $\Theta(\log n!)$ 是什么。由放缩 $\left(\dfrac{n}{2}\right)^{n/2} \le n! \le n^n$ 以及 $\log (n^n)\in \Theta(n\log n),\log\left(\dfrac{n}{2}\right)^{n/2}=\dfrac{n\log\dfrac{n}{2}}{2}\in \Theta(n\log n)$ 可知 $\log n!\in \Theta(n\log n)$，即 $\Theta(\log n!)=\Theta(n\log n)$。&lt;/p>
&lt;p>也就是说，TUCS 的复杂度就是 $\Theta(n\log n)$。世界上再没有最坏情况下复杂度更好的比较排序算法了！&lt;/p></description></item><item><title>BFPRT：线性选择算法</title><link>https://blog.fei.ac/zh/posts/bfprt/</link><pubDate>Tue, 04 Jul 2023 14:30:00 +0800</pubDate><guid>https://blog.fei.ac/zh/posts/bfprt/</guid><description>&lt;p>选择算法（Selection Algorithm）是在一系列可比较元素中找到第 $k$ 小元素的算法。选择算法查找元素最典型的特例就是最大值和最小值，均可以 $O(n)$ 的时间复杂度完成。对于平凡的 $k$，显然也可通过排序在 $O(n \log n)$，或是堆在 $O(n \log k)$ 的时间复杂度内解决。本文章将介绍一个复杂度优于它们的选择算法，BFPRT 算法，其时间复杂度为 $O(n)$。&lt;/p>
&lt;p>让我们先了解快速选择法（Quickselect），这是快速排序的发明者 Tony Hoare 发明的另一算法。它和快速排序唯一的区别就是其只递归第 $k$ 小值所在的一侧。在理想情况下，每次取到一个接近中位数的 Pivot，可以实现 $O(n)$ 的优秀复杂度；但在最坏情况下，复杂度可达 $O(n^2)$。&lt;/p>
&lt;p>$$
\begin{array}{ll}
1 &amp;amp; \textbf{Input. }\text{1-indexed array of comparable elements } A_1, A_2, \ldots, A_n\newline
&amp;amp; \text{and positive integer } k \text{ indicating the index of the required element}\newline
2 &amp;amp; \textbf{Output. }k \text{-th smallest element of } A\newline
3 &amp;amp; \textbf{Method. }\newline
4 &amp;amp; \textbf{Function}\text{ quickselect(}A, k\text{)}\newline
5 &amp;amp; \qquad \text{select an integer } x \in [1, |A|]\newline
6 &amp;amp; \qquad \text{move all elements less than }x\text{ to the front}\newline
7 &amp;amp; \qquad \text{move all elements greater than }x\text{ to the back}\newline
8 &amp;amp; \qquad i \leftarrow \operatorname{rank}(A, x)\newline
9 &amp;amp; \qquad \textbf{if } k = i\newline
10 &amp;amp; \qquad \qquad \textbf{return } x\newline
11 &amp;amp; \qquad \textbf{else if } k &amp;lt; i\newline
12 &amp;amp; \qquad \qquad \textbf{return }\text{quickselect(}A[1&amp;hellip;i-1], k\text{)}\newline
13 &amp;amp; \qquad \textbf{else}\newline
14 &amp;amp; \qquad \qquad \textbf{return }\text{quickselect(}A[i+1&amp;hellip;|A|], k-i\text{)}\newline
15 &amp;amp; \textbf{End}\newline
16 &amp;amp; \textbf{return }\text{quickselect(}A,k\text{)}
\end{array}
$$&lt;/p>
&lt;p>问题就在于我们如何选择 Pivot。我们当然可以随机地从序列中选取 Pivot，从而取得 $O(n)$ 的期望复杂度，但我们希望有一个确定性算法。一种朴素的想法是取头、中、尾三者的中位数作为 Pivot，但内省排序的发明者 David Musser 给出了数据使这种算法达到最坏复杂度。&lt;/p>
&lt;p>包括我们熟悉的 Floyd 和 Tarjan 在内的姓氏缩写为 BFPRT 的五人给出一种选择 Pivot 的方法，使得快速选择的复杂度在最坏情况下达到 $O(n)$。&lt;/p>
&lt;p>将原序列分为 $\left\lfloor\dfrac{n}{5}\right\rfloor$ 组，每组 $5$ 个元素（多余的元素舍去），暴力算出这 $\left\lfloor\dfrac{n}{5}\right\rfloor$ 组的中位数，记作 $a_1, a_2, \ldots, a_{\lfloor n/5 \rfloor}$。递归算出 $a$ 的中位数，作为 Pivot。&lt;/p>
&lt;p>让我们来统计时间复杂度。暴力计算 $\left\lfloor\dfrac{n}{5}\right\rfloor$ 组中位数的复杂度为 $\sum O(5\log 5) = O(n)$，递归计算 $a$ 中位数的复杂度为 $T(\frac{n}{5})$，得到的 Pivot 至少大于等于 $\dfrac{n}{4}$、小于等于 $\dfrac{n}{4}$ 的数，故下一层递归至少排除了 $\dfrac{n}{4}$ 的数，复杂度为 $T(\frac{3n}{4})$。总复杂度由主定理可得为&lt;/p>
&lt;p>$$\begin{aligned}
T(n) &amp;amp;= T\left(\frac{3}{4}n\right) + T\left(\frac{n}{5}\right) + O(n)\newline
&amp;amp;= O(n)
\end{aligned}$$&lt;/p>
&lt;p>为什么分每组 $5$ 个元素而不是 $4$ 个或 $6$ 个呢？记我们分每组 $a$ 个元素，由上面的式子可知 $a&amp;gt;4$。当 $a&amp;gt;4$ 时，比较次数 $f(n)$ 满足&lt;/p>
&lt;p>$$
f(n)=
\begin{cases}
f\left(\left(\dfrac{3}{4} + \dfrac{1}{a}\right)n\right) + n \log a &amp;amp;\text{if } n \ge 5 \newline
n \log n &amp;amp;\text{if } n &amp;lt; 5
\end{cases}
$$&lt;/p>
&lt;p>得 $f(n) = \dfrac{4na\log a}{a-4}$，由 $\dfrac{\partial f}{\partial a}=4n\dfrac{a-4\log a-4}{(4-a)^2}$ 发现 $f(n)$ 在 $n=15$ 处取得最小值。退一步讲，就算我们取暴力中位数的复杂度为 $O(na)$，那最优值也应是 $8$ 而非 $5$。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;iostream&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;chrono&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;vector&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;numeric&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;cassert&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;random&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> N &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1e6&lt;/span>, K &lt;span style="color:#f92672">=&lt;/span> N &lt;span style="color:#f92672">/&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>std&lt;span style="color:#f92672">::&lt;/span>vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> src(N);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">bruteforce_kth&lt;/span>(std&lt;span style="color:#f92672">::&lt;/span>vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> arr, &lt;span style="color:#66d9ef">int&lt;/span> k) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>sort(arr.begin(), arr.end());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> arr[k &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">get_kth&lt;/span>(&lt;span style="color:#66d9ef">const&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>, &lt;span style="color:#66d9ef">int&lt;/span>, &lt;span style="color:#66d9ef">int&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">get_median&lt;/span>(&lt;span style="color:#66d9ef">const&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>arr, &lt;span style="color:#66d9ef">int&lt;/span> a) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> get_kth(arr, arr.size() &lt;span style="color:#f92672">/&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>, a);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">get_kth&lt;/span>(&lt;span style="color:#66d9ef">const&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>arr, &lt;span style="color:#66d9ef">int&lt;/span> k, &lt;span style="color:#66d9ef">int&lt;/span> a) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (arr.size() &lt;span style="color:#f92672">&amp;lt;=&lt;/span> a) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> bruteforce_kth(arr, k);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> medians;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">+&lt;/span> a &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span> arr.size(); i &lt;span style="color:#f92672">+=&lt;/span> a) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> tmp(a);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> j &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; j &lt;span style="color:#f92672">&amp;lt;&lt;/span> a; &lt;span style="color:#f92672">++&lt;/span>j) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> tmp[j] &lt;span style="color:#f92672">=&lt;/span> arr[i &lt;span style="color:#f92672">+&lt;/span> j];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> medians.push_back(bruteforce_kth(tmp, tmp.size() &lt;span style="color:#f92672">/&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> pivot &lt;span style="color:#f92672">=&lt;/span> get_median(medians, a);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> less, greater;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i : arr) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (i &lt;span style="color:#f92672">&amp;lt;&lt;/span> pivot) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> less.push_back(i);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (i &lt;span style="color:#f92672">&amp;gt;&lt;/span> pivot) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> greater.push_back(i);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (k &lt;span style="color:#f92672">&amp;lt;=&lt;/span> less.size()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> get_kth(less, k, a);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (k &lt;span style="color:#f92672">&amp;lt;=&lt;/span> arr.size() &lt;span style="color:#f92672">-&lt;/span> greater.size()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> pivot;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> get_kth(greater, k &lt;span style="color:#f92672">-&lt;/span> (arr.size() &lt;span style="color:#f92672">-&lt;/span> greater.size()), a);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">run&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> a) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">auto&lt;/span> start &lt;span style="color:#f92672">=&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>chrono&lt;span style="color:#f92672">::&lt;/span>high_resolution_clock&lt;span style="color:#f92672">::&lt;/span>now();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> assert(get_kth(src, K, a) &lt;span style="color:#f92672">==&lt;/span> K &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">auto&lt;/span> end &lt;span style="color:#f92672">=&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>chrono&lt;span style="color:#f92672">::&lt;/span>high_resolution_clock&lt;span style="color:#f92672">::&lt;/span>now();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>chrono&lt;span style="color:#f92672">::&lt;/span>duration&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">double&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> duration &lt;span style="color:#f92672">=&lt;/span> end &lt;span style="color:#f92672">-&lt;/span> start;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;a: &amp;#34;&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> a &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34; time: &amp;#34;&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> duration.count() &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34; seconds&amp;#34;&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>endl;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>mt19937 rng(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>chrono&lt;span style="color:#f92672">::&lt;/span>high_resolution_clock&lt;span style="color:#f92672">::&lt;/span>now().time_since_epoch().count());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>iota(src.begin(), src.end(), &lt;span style="color:#ae81ff">0&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>shuffle(src.begin(), src.end(), rng);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">5&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;=&lt;/span> &lt;span style="color:#ae81ff">2000&lt;/span>; &lt;span style="color:#f92672">++&lt;/span>i)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> run(i);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在实际情况下存在各种其他因子的干扰，使得 $a$ 的最优值无法简单通过理论算出。通过运行以上代码，我们可以得到对于 $10^6$ 长度的随机序列求 $k$ 最小值的用时与 $a$ 的取值的关系图像。&lt;/p>
&lt;p>&lt;img src="https://blog.fei.ac/zh/images/bfprt1.png" alt="">
&lt;img src="https://blog.fei.ac/zh/images/bfprt2.png" alt="">&lt;/p>
&lt;p>似乎在 $100$ 到 $200$ 之间取得较优的效率。在其他机器上运行相同代码，最优值都不同，有在 $13$ 处取得最优值的。值得一提的是，以上实现即使在最优的 $a$ 取值下相比 $O(n\log n)$ 的 &lt;code>std::sort&lt;/code> 仍然不具有显著优势。&lt;/p>
&lt;p>上述代码本可以 in-place 分割从而得到更好的效率。也许我改天会重写并测试 in-place 版的 BFPRT 算法，或许能有新的发现。&lt;/p>
&lt;h2 id="credits">Credits&lt;/h2>
&lt;p>&lt;em>&lt;a href="https://www.cs.princeton.edu/~wayne/cs423/lectures/selection-4up.pdf">Linear Time Selection&lt;/a>&lt;/em>, COS 423 Spring 2002, Kevin Wayne&lt;/p></description></item><item><title>狄利克雷卷积和莫比乌斯反演</title><link>https://blog.fei.ac/zh/posts/arithmetic-functions/</link><pubDate>Wed, 28 Jun 2023 10:07:00 +0800</pubDate><guid>https://blog.fei.ac/zh/posts/arithmetic-functions/</guid><description>&lt;p>数论函数是定义域为 $\mathbb{N}^{+}$，陪域为 $\mathbb{C}$ 的一类函数。常见的数论函数有：&lt;/p>
&lt;ul>
&lt;li>单位函数 $\epsilon(n)=[n=1]$&lt;/li>
&lt;li>欧拉函数 $\varphi(n)=\sum\limits_{i=1}^n[(i,n)=1]$&lt;/li>
&lt;li>恒等函数 $\operatorname{id}(n)=n$&lt;/li>
&lt;li>常值函数 $1(n)=1$&lt;/li>
&lt;li>约数函数 $\tau(n)=\sum\limits_{i=1}^n[i\mid n]$ （亦可记作 $d(n)$、$\sigma_0(n)$）&lt;/li>
&lt;li>莫比乌斯函数 $\mu(n)=\begin{cases}1&amp;amp;\text{if }n=1\newline 0&amp;amp;\text{if }p\text{ contains square prime divisor}\newline (-1)^{\omega(n)}&amp;amp;\text{otherwise}\end{cases}$，其中 $\omega(n)$ 代表 $n$ 的质因子个数。&lt;/li>
&lt;/ul>
&lt;p>若 $\forall x, y\in \mathbb{N}^{+}, (x, y)=1$ 都有 $f(xy)=f(x)f(y)$，则称数论函数 $f$ 为积性函数。若 $f$ 对 $\forall x, y\in \mathbb{N}^{+}, (x, y)\neq 1$ 也满足 $f(xy)=f(x)f(y)$ 则称 $f$ 为完全积性函数。上面给出的数论函数都是积性函数。&lt;/p>
&lt;p>积性函数可以通过欧拉筛法线性求值，伪代码如下：&lt;/p>
&lt;p>$$
\begin{array}{ll}
1 &amp;amp; \textbf{Input.}\text{ Positive integer }N\text{ and multiplicative function }f\newline
2 &amp;amp; \textbf{Output.}\text{ }f(n)\text{ for every positive integer }n\text{ that is less than or equal to } N\newline
3 &amp;amp; \textbf{Method.}\newline
4 &amp;amp; \textbf{Function}\text{ sieve(}N, f\text{)}\newline
5 &amp;amp; \qquad F\text{ is a 1-indexed array of length }N\newline
7 &amp;amp; \qquad\textbf{for}\text{ each integer }i\text{ in }[1, N]\newline
8 &amp;amp; \qquad\qquad\textbf{if }i\text{ is prime}\newline
9 &amp;amp; \qquad\qquad\qquad F_i \leftarrow f(i)\newline
10 &amp;amp; \qquad\qquad \textbf{for}\text{ each prime number }j\newline
11 &amp;amp; \qquad\qquad\qquad \textbf{if}\text{ }j\nmid i\newline
12 &amp;amp; \qquad\qquad\qquad\qquad F_{ij} \leftarrow F_iF_j\newline
13 &amp;amp; \qquad\qquad\qquad \textbf{else}\newline
14 &amp;amp; \qquad\qquad\qquad\qquad F_{ij} \leftarrow f(ij)\newline
15 &amp;amp; \qquad\qquad\qquad\qquad \textbf{break}\newline
16 &amp;amp; \qquad\textbf{return }F\newline
17 &amp;amp; \textbf{End}\newline
18 &amp;amp; \textbf{return }\text{sieve(}N,f\text{)}
\end{array}
$$&lt;/p>
&lt;h2 id="狄利克雷卷积">狄利克雷卷积&lt;/h2>
&lt;p>定义两个数论函数 $f$ 和 $g$ 的狄利克雷卷积 $f*g$ 为&lt;/p>
&lt;p>$$(f*g)(n)=\sum\limits_{d\mid n}f(d)g\left(\dfrac{n}{d}\right)$$&lt;/p>
&lt;p>事先了解生成函数（特别是狄利克雷型生成函数）有助于理解狄利克雷卷积。&lt;/p>
&lt;p>狄利克雷卷积是离散卷积的一种，满足三种主要运算律：&lt;/p>
&lt;ul>
&lt;li>交换律 $f\ast g=g\ast f$&lt;/li>
&lt;li>结合律 $(f\ast g)\ast h=f\ast (g\ast h)$&lt;/li>
&lt;li>分配律 $f\ast(g+h)=f\ast g+f\ast h$&lt;/li>
&lt;/ul>
&lt;p>正如 $1$ 是乘法的单位元（$x\times 1=x$），单位函数 $\epsilon$ 是狄利克雷卷积的单位元（$f*\epsilon=f$），任何数论函数 $f$ 与 $\epsilon$ 的狄利克雷卷积都是其本身。&lt;/p>
&lt;h2 id="莫比乌斯反演--其一">莫比乌斯反演 · 其一&lt;/h2>
&lt;p>莫比乌斯反演有两个形式，在此先介绍其第一个形式，即&lt;/p>
&lt;p>$$f(n)=\sum\limits_{d\mid n}g(n)\iff g(n)=\sum\limits_{d\mid n}\mu\left(\dfrac{n}{d}\right)f(d)$$&lt;/p>
&lt;p>用狄利克雷卷积的形式表达就是&lt;/p>
&lt;p>$$f=1*g\iff g=\mu * f$$&lt;/p>
&lt;p>我们当即发现，莫比乌斯函数 $\mu$ 与单位函数 $1$ 之间似乎有非常紧密的关系，$\mu$ 似乎可以被视作是 $1$ 的逆元。换句话讲&lt;/p>
&lt;p>$$1*\mu=\epsilon$$&lt;/p>
&lt;p>$$\sum\limits_{d\mid n}\mu(d)=[n=1]$$&lt;/p>
&lt;h3 id="证明">证明&lt;/h3>
&lt;p>由于含有平方质因子的数的莫比乌斯函数值为 $0$，设 $n=\prod {p_i}^{k_i},n^\prime=\prod p_i$，满足 $(1*\varphi)(n)=(1*\varphi)(n^\prime)$。&lt;/p>
&lt;p>于是&lt;/p>
&lt;p>$$(1*\varphi)(n)=(1*\varphi)(n^\prime)=\sum\binom{\omega(n^\prime)}{i}\cdot (-1)^i=0^{\omega(n^\prime)}$$&lt;/p>
&lt;p>只有当 $n^\prime$ 的质因子数为 $0$，即 $n=n^\prime=1$ 时，才有 $(1*\varphi)(n)=1$。&lt;/p>
&lt;p>当然，由于 $1*\varphi=\epsilon$ 和莫比乌斯反演的第一种形式是等价的，我们同时也证明了莫比乌斯反演的第一种形式。&lt;/p>
&lt;h2 id="莫比乌斯反演--其二">莫比乌斯反演 · 其二&lt;/h2>
&lt;p>莫比乌斯反演的第二个形式是&lt;/p>
&lt;p>$$
f(n)=\sum\limits_{n\mid d}g(d)\iff g(n)=\sum\limits_{n\mid d}\mu\left(\dfrac{d}{n}\right)f(d)
$$&lt;/p>
&lt;p>我们发现它和第一个形式具有高度的对称性。接下来阐述如何在 $\sum\limits_{n=1}^\infty f(n)$ 和 $\sum\limits_{n=1}^\infty g(n)$ 均绝对收敛的条件下将第二种形式转化为第一种形式，从而证明之。&lt;/p>
&lt;p>设 $N$ 为正整数， $M = N!$，且&lt;/p>
&lt;p>$$
\begin{aligned}
F_N(x) = \begin{cases}f(n) &amp;amp;\text{ if }\exists n \in \mathbb N^+, n \le N, x = \dfrac{M}{n}\newline 0&amp;amp;\text{ else}\end{cases}\newline
G_N(x) = \begin{cases}g(n) &amp;amp;\text{ if }\exists n \in \mathbb N^+, n \le N, x = \dfrac{M}{n}\newline 0&amp;amp;\text{ else}\end{cases}
\end{aligned}
\qquad\left(n \le N\right)
$$&lt;/p>
&lt;p>则对于任意 $N$ 和 $n \le N$ 有&lt;/p>
&lt;p>$$
\begin{aligned}
\forall n \le N, f(n)=\sum\limits_{n\mid d}g(d)
&amp;amp;\iff F_N\left(\frac{M}{n}\right)-\sum\limits_{\frac{M}{d}\mid \frac{M}{n}}G_N\left(\frac{M}{d}\right) - \sum\limits_{n\mid d \land d&amp;gt;N}g(d) = 0\newline
&amp;amp;\iff F_N\left(n\right)-\sum\limits_{d\mid n}G_N\left(d\right) - \sum\limits_{n\mid d \land d&amp;gt;N}g(d) = 0
\end{aligned}
$$&lt;/p>
&lt;p>其中余项满足 $\left|\sum\limits_{n\mid d \land d&amp;gt;N}g(d)\right| \le \sum\limits_{n\mid d \land d&amp;gt;N}|g(d)| \le \sum\limits_{n &amp;gt; N}|g(n)|$。由于 $\sum\limits_{n=1}^\infty g(n)$ 绝对收敛，则 $\forall \epsilon &amp;gt; 0, \exists N, \left|\sum\limits_{n\mid d \land d&amp;gt;N}g(d)\right| &amp;lt; \epsilon$。那么&lt;/p>
&lt;p>$$
\begin{aligned}
N\to+\infty, \forall n \le N, f(n)=\sum\limits_{n\mid d}g(d)
&amp;amp;\iff
F_N\left(n\right)-\sum\limits_{d\mid n}G_N\left(d\right) - \sum\limits_{n\mid d \land d&amp;gt;N}g(d) = 0 \newline
&amp;amp;\iff
F_N\left(n\right)-\sum\limits_{d\mid n}G_N\left(d\right) = 0
\end{aligned}
$$&lt;/p>
&lt;p>类似地，&lt;/p>
&lt;p>$$
\begin{aligned}
\forall n\le N, g(n)=\sum\limits_{n\mid d}\mu\left(\dfrac{d}{n}\right)f(d)
&amp;amp;\iff G_N\left(\frac{M}{n}\right)-\sum\limits_{\frac{M}{d}\mid \frac{M}{n}}\mu\left(\frac{\frac{M}{n}}{\frac{M}{d}}\right)F_N\left(\frac{M}{d} \right)-\newline
&amp;amp;\sum_{n\mid d \land d &amp;gt; N}\mu\left(\dfrac{d}{n}\right)f(d)=0\newline
&amp;amp;\iff G_N\left(n\right)-\sum\limits_{d\mid n}\mu\left(\frac{n}{d}\right)F_N\left(d \right) -\newline
&amp;amp;\sum_{n\mid d \land d &amp;gt; N}\mu\left(\dfrac{d}{n}\right)f(d)=0
\end{aligned}
$$&lt;/p>
&lt;p>由于 $|\mu(n)| \le 1$，余项 $\left|\sum\limits_{n\mid d \land d &amp;gt; N}\mu\left(\dfrac{d}{n}\right)f(d)\right| \le \sum\limits_{n\mid d \land d &amp;gt; N}|f(d)|\le \sum\limits_{n &amp;gt; N}|f(n)|$。由于 $\sum\limits_{n=1}^\infty f(n)$ 绝对收敛，类似上面的推理，可以得到&lt;/p>
&lt;p>$$
N\to+\infty,\forall n\le N, g(n)=\sum\limits_{n\mid d}\mu\left(\dfrac{d}{n}\right)f(d)\iff
G_N\left(n\right)-\sum\limits_{d\mid n}\mu\left(\frac{n}{d}\right)F_N\left(d \right)=0
$$&lt;/p>
&lt;p>由莫比乌斯反演的第一种形式，可以得到 $N\to\infty, n\le N$ 时&lt;/p>
&lt;p>$$
f(n)=\sum\limits_{n\mid d}g(d)\iff g(n)=\sum\limits_{n\mid d}\mu\left(\dfrac{d}{n}\right)f(d)
$$&lt;/p>
&lt;h2 id="欧拉反演">欧拉反演&lt;/h2>
&lt;p>$$n=\sum\limits_{d\mid n}\varphi(d)$$&lt;/p>
&lt;p>用狄利克雷卷积的形式表达就是&lt;/p>
&lt;p>$$\operatorname{id}=\varphi\ast 1$$&lt;/p>
&lt;h3 id="证明-1">证明&lt;/h3>
&lt;p>由 $\epsilon = 1\ast \mu$ 可得 $[(i, n) = 1] = \sum\limits_{d\mid (i,n)}\mu(d)$，于是&lt;/p>
&lt;p>$$
\begin{aligned}
\varphi(n) &amp;amp;= \sum_{i=1}^n\sum_{d\mid (i, n)}\mu(d)\newline
&amp;amp;= \sum_{d\mid n}\sum_{d\mid i\land i\le n}\mu(d)\newline
&amp;amp;= \sum_{d\mid n}\frac{n}{d}\mu(d)
\end{aligned}
$$&lt;/p>
&lt;p>故&lt;/p>
&lt;p>$$\varphi = \operatorname{id}\ast \mu$$&lt;/p>
&lt;p>结合 $\mu \ast 1 = \epsilon$ 得&lt;/p>
&lt;p>$$\operatorname{id}=\varphi\ast 1$$&lt;/p></description></item><item><title>Scheme 解释器原理</title><link>https://blog.fei.ac/zh/posts/theory-of-scheme-interpretation/</link><pubDate>Tue, 16 May 2023 16:25:00 +0800</pubDate><guid>https://blog.fei.ac/zh/posts/theory-of-scheme-interpretation/</guid><description>&lt;p>Scheme 是 Lisp 的一种方言，其语法极为简洁。&lt;/p>
&lt;p>在 Scheme 中，所有的过程都通过 &lt;code>(procedure param)&lt;/code> 的形式调用。下面是一些例子：&lt;/p>
&lt;ul>
&lt;li>&lt;code>(eq? 3 (+ 1 2))&lt;/code>：计算 3 是否等于 1 + 2&lt;/li>
&lt;li>&lt;code>(define x (* 3 4))&lt;/code>：将变量 &lt;code>x&lt;/code> 绑定至 3 * 4 的结果&lt;/li>
&lt;li>&lt;code>(define (abs x) (if (&amp;gt; x 0) x (- x)))&lt;/code>：定义过程 &lt;code>abs&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>可见，Scheme 使用波兰表示法而非我们惯用的中缀表示法。这对于初用者来说可能很麻烦，但也方便了我们实现其解释器。我们不用考虑种种运算符的运算顺序，然后在此基础上复杂地将中缀表达式转换为波兰表达式处理。&lt;/p>
&lt;p>需要注意的是，在 Scheme 中括号不用于表示运算顺序，而是表示过程调用。例如 &lt;code>+&lt;/code> 和 &lt;code>(+)&lt;/code> 是不同的，前者表示加法函数，后者表示无参数地调用加法函数。&lt;/p>
&lt;h2 id="read-eval-print-循环">Read-Eval-Print 循环&lt;/h2>
&lt;p>类似 Python，Scheme 解释器在交互模式下也按照“读入-求值-输出”的模式循环。&lt;/p>
&lt;h3 id="读入">读入&lt;/h3>
&lt;p>首先以空格、括号为界，将输入 tokenize。例如 &lt;code>(+ 1 (* 2 3))&lt;/code> 在被 tokenized 后会成为 &lt;code>['(', '+', '1', '(', '*', '2', '3' ')', ')']&lt;/code>。&lt;/p>
&lt;p>之后，再将 token 转化为可供求值的对象。在我们的设计中，任何可供求值的对象，要么是个字符串，要么是个本质为链表的 &lt;code>Pair&lt;/code>。任何被括号包围的 token 将被转化为 &lt;code>Pair&lt;/code>，而独立的 token 将被转化为字符串。例如，&lt;code>'1'&lt;/code> 会被转化为 &lt;code>'1'&lt;/code>（技术上，它其实没发生任何改变），而 &lt;code>('1')&lt;/code> 却会被转化为 &lt;code>Pair('1', nil)&lt;/code>（nil 代表尾节点）。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Pair&lt;/span>(object):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">def&lt;/span> __init__(self, first, rest):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self&lt;span style="color:#f92672">.&lt;/span>first &lt;span style="color:#f92672">=&lt;/span> first
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self&lt;span style="color:#f92672">.&lt;/span>rest &lt;span style="color:#f92672">=&lt;/span> rest
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>对于字符串，我们在当前环境下查找其值，例如 &lt;code>'+'&lt;/code> 对应了一个代表加法的过程，&lt;code>'#t'&lt;/code> 对应了为真的布尔值，&lt;code>'a'&lt;/code> 对应了变量 &lt;code>a&lt;/code> 的值。对于 &lt;code>Pair&lt;/code>，在求值时我们认为其是个过程调用，当前数据为所调用的过程，下一个链表节点为过程的参数，例如 &lt;code>Pair('+', Pair('1', Pair('2', 'nil')))&lt;/code> 将被认为是一个以 &lt;code>Pair('1', Pair('2', 'nil'))&lt;/code> 为参数对过程 &lt;code>'+'&lt;/code> 的调用。&lt;code>Pair&lt;/code> 除了代表过程调用，还代表普通的链表，例如在刚才的例子中，&lt;code>Pair('1', Pair('2', 'nil'))&lt;/code> 代表一个普通的链表 &lt;code>['1', '2']&lt;/code> 而非对过程 &lt;code>'1'&lt;/code> 的调用。&lt;/p>
&lt;p>那么，一个 &lt;code>Pair&lt;/code> 何时被视作过程调用，何时被视作链表呢？&lt;code>Pair&lt;/code> 在被求值时被视作过程调用，而存储时被视作链表。这种说法有些抽象，将在接下来的对求值的介绍中予以澄清。&lt;/p>
&lt;h3 id="求值">求值&lt;/h3>
&lt;p>之前我们提到过，可供求值的对象要么是字符串，要么是 &lt;code>Pair&lt;/code>；独立的字符串以及包含在 &lt;code>Pair&lt;/code> 中的字符串可以被轻松的实现求值，于是我们要实现求值的只剩 &lt;code>Pair&lt;/code> 了。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">scheme_eval&lt;/span>(expr):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> isinstance(expr, str):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># if it is a string&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># we provoke some procedure to evaluate it&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> expr &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#e6db74">&amp;#39;#t&amp;#39;&lt;/span>: &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">True&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">elif&lt;/span> expr &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#e6db74">&amp;#39;#f&amp;#39;&lt;/span>: &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">False&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">elif&lt;/span> expr &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#e6db74">&amp;#39;1&amp;#39;&lt;/span>: &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">elif&lt;/span> expr &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#e6db74">&amp;#39;2&amp;#39;&lt;/span>: &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">elif&lt;/span> expr &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#e6db74">&amp;#39;+&amp;#39;&lt;/span>: &lt;span style="color:#66d9ef">return&lt;/span> plus_function
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># blah blah blah...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># of course the real implementation won&amp;#39;t be this stupid; this is just a demo&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> isinstance(expr, Pair):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># otherwise it is a pair&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># expr.first is the procedure while expr.rest being the argument&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> scheme_apply(scheme_eval(expr&lt;span style="color:#f92672">.&lt;/span>first, env), expr&lt;span style="color:#f92672">.&lt;/span>rest)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>我们通过函数 &lt;code>scheme_apply(procedure, args)&lt;/code> 实现 &lt;code>Pair&lt;/code> 的求值。将 &lt;code>args&lt;/code> 视作一个链表而非过程调用，逐个地对其中元素调用 &lt;code>scheme_eval&lt;/code>：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">scheme_apply&lt;/span>(procedure, args):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> lst &lt;span style="color:#f92672">=&lt;/span> list()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> args &lt;span style="color:#f92672">!=&lt;/span> nil:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> lst&lt;span style="color:#f92672">.&lt;/span>append(scheme_eval(args&lt;span style="color:#f92672">.&lt;/span>first))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> args &lt;span style="color:#f92672">=&lt;/span> args&lt;span style="color:#f92672">.&lt;/span>rest
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> procedure(&lt;span style="color:#960050;background-color:#1e0010">＊&lt;/span>lst)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="输出">输出&lt;/h3>
&lt;p>简单地输出调用 &lt;code>scheme_eval&lt;/code> 的返回值即可。&lt;/p>
&lt;h2 id="框架和环境">框架和环境&lt;/h2>
&lt;p>框架（Frame）和环境（Environment）都是关于变量和实例绑定的概念，都是从变量到实例的单射。但它们并非完全一样的概念。请参考下面的介绍：&lt;/p>
&lt;blockquote>
&lt;p>An frame is a box that contains bindings from variables to values. An frame can “extend” another frame; that is, this frame can see all bindings of the frame it extends. We represent this by drawing an arrow from an environment frame to the frame it is extending. The global environment is the only environment that extends nothing.&lt;/p>
&lt;p>An environment is a series of frames, which we get from extending the current frame. To determine which frames are in an environment, follow the arrows until reaching the global environment. Every frame you passed through is part of that environment. The global environment is only made up of the global frame, because its frame extends nothing.&lt;/p>
&lt;/blockquote>
&lt;p>之前的 &lt;code>scheme_eval&lt;/code> 中，对于字符串，我们采用了类似 &lt;code>if expr == '1': return 1&lt;/code> 这样的愚蠢实现，并表示其只是个 demo。那么对于字符串我们究竟要怎么处理呢？&lt;/p>
&lt;p>字符串分为两类：字面量和变量。对于字面量，我们免不了要使用一些烦人的分类讨论。对于变量，我们要在环境内寻找其值。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Frame&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">def&lt;/span> __init__(self, parent):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self&lt;span style="color:#f92672">.&lt;/span>bindings &lt;span style="color:#f92672">=&lt;/span> dict()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self&lt;span style="color:#f92672">.&lt;/span>parent &lt;span style="color:#f92672">=&lt;/span> parent
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">lookup&lt;/span>(self, name):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> name &lt;span style="color:#f92672">in&lt;/span> self&lt;span style="color:#f92672">.&lt;/span>bindings:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> self&lt;span style="color:#f92672">.&lt;/span>bindings[name]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> self&lt;span style="color:#f92672">.&lt;/span>parent &lt;span style="color:#f92672">is&lt;/span> &lt;span style="color:#66d9ef">None&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">raise&lt;/span> SomeError
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> self&lt;span style="color:#f92672">.&lt;/span>parent&lt;span style="color:#f92672">.&lt;/span>lookup(name)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">define&lt;/span>(self, name, value):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self&lt;span style="color:#f92672">.&lt;/span>bindings[name] &lt;span style="color:#f92672">=&lt;/span> value
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>为了确定当前的环境，&lt;code>scheme_eval&lt;/code> 和 &lt;code>scheme_apply&lt;/code> 要加上一个新的参数 &lt;code>env&lt;/code> 表示当前环境：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">scheme_eval&lt;/span>(expr, env):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> isinstance(expr, str):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> is_literal(expr):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> literal(expr)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> env&lt;span style="color:#f92672">.&lt;/span>lookup(expr)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> scheme_apply(scheme_eval(expr&lt;span style="color:#f92672">.&lt;/span>first, env), expr&lt;span style="color:#f92672">.&lt;/span>rest, env)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">scheme_apply&lt;/span>(procedure, args, env):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> lst &lt;span style="color:#f92672">=&lt;/span> list()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> args &lt;span style="color:#f92672">!=&lt;/span> nil:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> lst&lt;span style="color:#f92672">.&lt;/span>append(scheme_eval(args&lt;span style="color:#f92672">.&lt;/span>first, env))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> args &lt;span style="color:#f92672">=&lt;/span> args&lt;span style="color:#f92672">.&lt;/span>rest
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> procedure(&lt;span style="color:#f92672">*&lt;/span>lst)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>我们要预先创建一个 global 框架，并向其中加入一些预设的变量。&lt;/p>
&lt;h3 id="if">if&lt;/h3>
&lt;p>在 C/C++ 和 Java 中，if/while/for 等语句会以当前环境为父环境创建新的环境，但在 Scheme 中 if 并不会。&lt;/p>
&lt;h3 id="函数">函数&lt;/h3>
&lt;p>和其他大多数语言一样，Scheme 的函数调用会创建新环境，父环境为声明函数的环境。&lt;/p>
&lt;h2 id="特殊形式">特殊形式&lt;/h2>
&lt;p>上面的设计只考虑了函数，而未考虑其他的特殊形式。函数和特殊形式的不同之处在于，函数总是会先对所有参数进行求值，而特殊形式却并不会。&lt;/p>
&lt;ul>
&lt;li>&lt;code>(define a (+ 1 2))&lt;/code> 的参数有 &lt;code>a&lt;/code> 和 &lt;code>(+ 1 2)&lt;/code>，但 &lt;code>a&lt;/code> 不会被求值，只有 &lt;code>(+ 1 2)&lt;/code> 会被求值&lt;/li>
&lt;li>&lt;code>(and #f (+ 1 2))&lt;/code> 的参数有 &lt;code>#f&lt;/code> 和 &lt;code>(+ 1 2)&lt;/code>，但由于逻辑与的短路规则，&lt;code>(+ 1 2)&lt;/code> 并不会被求值&lt;/li>
&lt;li>&lt;code>(define (plus x y) (+ x y))&lt;/code> 的参数有 &lt;code>(plus x y)&lt;/code> 和 &lt;code>(+ x y)&lt;/code>，但它们都不会被求值&lt;/li>
&lt;/ul>
&lt;p>因此，我们需要改变 &lt;code>scheme_apply&lt;/code> 的实现。具体地，若 &lt;code>procedure&lt;/code> 是特殊形式，我们将不对 &lt;code>args&lt;/code> 中的元素求值，而是将其直接传给 &lt;code>procedure&lt;/code>。&lt;/p>
&lt;p>Scheme 中的特殊形式有很多，这里只介绍其中关键的特殊形式的实现。&lt;/p>
&lt;h3 id="逻辑运算">逻辑运算&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">scheme_and&lt;/span>(args, env):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> args &lt;span style="color:#f92672">!=&lt;/span> nil:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">not&lt;/span> scheme_eval(args&lt;span style="color:#f92672">.&lt;/span>first, env):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">False&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> args &lt;span style="color:#f92672">=&lt;/span> args&lt;span style="color:#f92672">.&lt;/span>rest
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">True&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">scheme_if&lt;/span>(args, env):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> len(args) &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#ae81ff">3&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">raise&lt;/span> SomeError
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> scheme_eval(args&lt;span style="color:#f92672">.&lt;/span>first):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> scheme_eval(args&lt;span style="color:#f92672">.&lt;/span>rest&lt;span style="color:#f92672">.&lt;/span>first)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">else&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> scheme_eval(args&lt;span style="color:#f92672">.&lt;/span>rest&lt;span style="color:#f92672">.&lt;/span>rest&lt;span style="color:#f92672">.&lt;/span>first)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="变量定义">变量定义&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">scheme_define&lt;/span>(args, env):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> name, value &lt;span style="color:#f92672">=&lt;/span> args&lt;span style="color:#f92672">.&lt;/span>first, scheme_eval(args&lt;span style="color:#f92672">.&lt;/span>rest)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> env&lt;span style="color:#f92672">.&lt;/span>define(name, value)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="函数定义和-lambda-表达式">函数定义和 Lambda 表达式&lt;/h3>
&lt;p>在我们的 Scheme 解释器中，用户定义函数就是用 Lambda 表达式实现的。我们只需实现 Lambda 表达式即可。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Lambda&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">def&lt;/span> __init__(self, formals, body, env):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self&lt;span style="color:#f92672">.&lt;/span>formals &lt;span style="color:#f92672">=&lt;/span> formals
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self&lt;span style="color:#f92672">.&lt;/span>body &lt;span style="color:#f92672">=&lt;/span> body
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self&lt;span style="color:#f92672">.&lt;/span>env &lt;span style="color:#f92672">=&lt;/span> env
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">apply&lt;/span>(self, args):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> len(formals) &lt;span style="color:#f92672">!=&lt;/span> len(args):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">raise&lt;/span> SomeError
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> env &lt;span style="color:#f92672">=&lt;/span> Frame(self&lt;span style="color:#f92672">.&lt;/span>env)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> args &lt;span style="color:#f92672">!=&lt;/span> nil:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> env&lt;span style="color:#f92672">.&lt;/span>define(formals&lt;span style="color:#f92672">.&lt;/span>first, args&lt;span style="color:#f92672">.&lt;/span>first)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> scheme_eval(self&lt;span style="color:#f92672">.&lt;/span>body, env)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>可见，在 Lambda 表达式的实现中，我们存储三个变量：参数列表，函数体，定义函数的 Environment。调用函数时，我们直接创建一个定义函数的 Environment 的拷贝，在该拷贝中绑定参数和参数的值，并调用 &lt;code>scheme_eval&lt;/code> 计算返回值。&lt;/p>
&lt;h3 id="quote-和-quasiquote">Quote 和 Quasiquote&lt;/h3>
&lt;p>在 Scheme 中，quote 是一个返回参数的过程。例如 &lt;code>(square 4)&lt;/code> 作为一个包含两个元素的 Pair，在被求值后得到 &lt;code>16&lt;/code>；但 &lt;code>'(square 4)&lt;/code> 中却会直接返回这个包含两个元素的 Pair，而非其被求值后的结果 &lt;code>16&lt;/code>。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">scheme_quote&lt;/span>(args, env):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> len(args) &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">raise&lt;/span> SomeError
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> args&lt;span style="color:#f92672">.&lt;/span>first &lt;span style="color:#75715e"># rather than scheme_eval(args.first, env)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Quasiquote 的功能与 quote 类似，但其允许参数中存在 unquote 的调用。Unquote 则是一个必须位于 quasiquote 的参数中调用的过程。它能够避免其参数被 quote 直接返回，而是使其在求值后再被返回。例如，``((+ 1 2) (* 2 ,(+ 5 6)))&lt;code>求值后将得到&lt;/code>((+ 1 2) (* 2 11))`。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">scheme_quasiquote&lt;/span>(args, env):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> len(args) &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">raise&lt;/span> SomeError
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> arg &lt;span style="color:#f92672">=&lt;/span> args&lt;span style="color:#f92672">.&lt;/span>first
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> isinstance(arg, Pair):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> arg&lt;span style="color:#f92672">.&lt;/span>first &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#e6db74">&amp;#39;quote&amp;#39;&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> scheme_eval(arg&lt;span style="color:#f92672">.&lt;/span>rest, env)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">else&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> arg&lt;span style="color:#f92672">.&lt;/span>map(&lt;span style="color:#66d9ef">lambda&lt;/span> x:scheme_eval(x, env))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">else&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> arg
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="尾递归">尾递归&lt;/h2>
&lt;p>Scheme 没有设计循环语句，因此其任何的批量操作都要通过递归实现。因此在 Scheme 中递归的发生十分频繁，实现尾递归十分重要。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-text" data-lang="text">&lt;span style="display:flex;">&lt;span>(define (fact n)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (if (eq? n 0)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (* (fact (- n 1)) n)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>以上函数不符合尾递归的形式，因为递归调用成为了另一个函数的参数。&lt;/p>
&lt;p>那么，什么才是尾递归调用呢？若递归调用是某个函数的参数，则其一定不是尾递归，因为函数要在递归返回后才能返回；若递归是某个可以和参数同时返回的过程的参数，则其可以为尾递归，例如&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-text" data-lang="text">&lt;span style="display:flex;">&lt;span>(define (output n)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (if (&amp;gt;= n 1)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (begin (print n) (output (- n 1)))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (print n)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>尽管 &lt;code>(output (- n 1))&lt;/code> 作了 &lt;code>begin&lt;/code> 的参数，但 &lt;code>output&lt;/code> 仍是尾递归的。因为 &lt;code>begin&lt;/code> 无需等待 &lt;code>(output (- n 1))&lt;/code> 返回再返回，而是可以直接退出，再让 &lt;code>(output (- n 1))&lt;/code> 作为自己的返回值。&lt;/p>
&lt;p>我们可以为 &lt;code>scheme_apply&lt;/code> 设计一个接口，允许其处理的过程调用提前退出并通过该接口告知 &lt;code>scheme_apply&lt;/code> 最后调用的过程。同时，我们也要重新设计我们的过程，使之能够分离不涉及返回值的调用和作为返回值的调用；不涉及返回值的调用直接执行，作为返回值的调用则不执行，而是告知 &lt;code>scheme_apply&lt;/code> 后退出，由 &lt;code>scheme_apply&lt;/code> 执行。&lt;/p>
&lt;h2 id="credits">Credits&lt;/h2>
&lt;p>本文参考 &lt;a href="https://inst.eecs.berkeley.edu/~cs61a/su20/proj/scheme_stubbed/">UC Berkeley CS61A Project 4&lt;/a> 写成。实现代码存储于 &lt;a href="https://github.com/fei0319/CS61A/tree/main/scheme_stubbed">fei0319/CS61A/scheme_stubbed&lt;/a>。&lt;/p></description></item><item><title>ICPC2022 EC-Final 爆零记</title><link>https://blog.fei.ac/zh/posts/icpc-regional-2022-ec-final/</link><pubDate>Sun, 02 Apr 2023 23:05:00 +0800</pubDate><guid>https://blog.fei.ac/zh/posts/icpc-regional-2022-ec-final/</guid><description>&lt;p>因为之前南京区域赛发挥不错，我们队得到了参加 EC-Final 的名额。&lt;/p>
&lt;p>比赛前两天的下午，和两个队友还有 Owen_codeisking 坐地铁到汉口火车站，前往上海。高铁上 Owen 分给我们白象当晚餐，虽然我是白嫖，但还是要吐槽一下白象=面饼+汤，没有任何干货&lt;del>不是白象的我不吃&lt;/del>。晚上九点多到上海大学对面麦当劳吃了顿晚餐，然后入住汉庭。房间设计极不合理，卧室有二三十平米却只放了一张床和一个桌子，空空荡荡；洗手间则是另一个极端，狭窄逼仄，马桶和洗手台之间只留了十厘米宽的通道。&lt;/p>
&lt;p>第二天上午在酒店睡了个懒觉，去上大报道，拿了腾讯的宣传册、拍了照，然后去食堂吃午饭。食堂水平很低，发给我们中学食堂的那种铁盘子装的青豆炒肉、黄豆炒肉和蔬菜，青豆炒肉的那一格同时还放了一个装有肉丸汤的碗。下午去打热身赛。别的队都半小时 AK，我们队却卡 B。我认为是精度问题。不过反正只是热身赛。&lt;/p>
&lt;p>第三天参加比赛。开幕式精准地在 9:45 结束了。随后就是正赛。我们打得十分折磨。&lt;/p>
&lt;p>我先是过掉了最水的 M 题。然后 Destiny 和张神分别开始攻坚 C 和 L。他们 wa 了几发，随后张神转攻 J 题并于 72min 时通过。期间我在看以为可做的 D 题（事实上这是一道全场仅一队通过的神仙题）。然后我就发现 I 题很水并过掉，并得到了 C 题的 DP 做法。Destiny 认为 DP 应该比他的双向搜索更接近正解，并把他发现的两个 corner cases 告诉了我，于是我通过了 C。在之后，张神在 $n$ 次 wa 后也通过了 L 这道极其恶心的构造题。F 题我们大家都陷入到了归并排序中，只得到了 $4n\log n$ 的做法。我们孤注一掷试图以其通过，未果。最终大罚时通过五题，不出意外应该 cu 了。&lt;/p>
&lt;p>赛中发了鸡块、鸡柳和汉堡，所以虽然没吃午饭但赛后也不饿。赛后参加了华为座谈会，名为付求爱的华为员工向我们大谈华为的 CodeArts Snap（在此之前我甚至都不知道华为也涉足 AI 领域）并向在场学生许诺实习机会。晚上华为的武汉地区 hr 请我们还有华科的选手吃饭。我蹲在酒店睡大觉，没去。&lt;/p>
&lt;p>周天我鸽掉了上午的华为挑战赛，只参加了下午的闭幕式。闭幕式上整了一堆上大音乐学院的表演，我欣赏不来。滚榜时，我们心中毫无波澜地确认了我们 cu 的成绩。&lt;/p></description></item><item><title>强连通分量和点双连通分量</title><link>https://blog.fei.ac/zh/posts/connected-component/</link><pubDate>Wed, 18 Jan 2023 15:24:00 +0800</pubDate><guid>https://blog.fei.ac/zh/posts/connected-component/</guid><description>&lt;p>强连通分量和点双连通分量是图论中常见的两个概念。算法竞赛中，我们处理它们时都要使用 Tarjan 算法，因而这二者常常被混淆。强连通分量常常被缩点代称，而点双连通分量则常被割点代称。事实上，缩点和割点并不是一组对应的概念；缩点在点双连通分量中对应的概念是圆方树，割点在强连通分量中对应的概念是割边（桥）。因此，我们要么说“强连通分量和点双连通分量”，要么说“缩点和圆方树”，要么说“割边和割点”，但是不要说“缩点和割点”。人们常将缩点和割点并称的原因可能是洛谷，其关于构造强连通分量和点双连通分量的模板题的名称分别为“缩点”和“割点”，具有很强的误导性。尤其是“缩点”和“割点”都含有“点”字，容易让初学者以为它们是对应的概念，看不透二者的真正关系。&lt;/p>
&lt;p>那么，强连通分量和点双连通分量的真正关系是什么呢？或者说，怎样才能最好地理解它们的相似性和差异性呢？&lt;/p>
&lt;p>割边和割点的关系。强连通分量是割边分隔出的点集，点双连通分量是割点分割出的点集（特别地，割点本身同时属于它四周的点双连通分量）。因此它们都可以使用 Tarjan 算法处理。在 DFS 树上，一条边 $E$ 是割边当且仅当其儿子的子树中没有指向 $E$ 的祖先（注意这里不是子树外而是祖先，因为有向图的 DFS 树形态特别）的返祖边，一个结点 $V$ 是割点当且仅当其&lt;strong>某个&lt;/strong>儿子的子树中没有指向 $V$ 的祖先的返祖边。删去强连通分量中的任何边得到的生成子图仍然连通（弱连通），删去点双连通分量中的任何结点得到的导出子图仍然连通。&lt;/p>
&lt;p>有向图和无向图的关系。强连通分量在有向图中定义，点双连通分量在无向图中定义。“任意两个结点都能够互相到达的极大子图”这一定义不能够在无向图中定义强连通分量，因为这实际上指的是连通块；但我们可以用强连通分量的另一个定义“割边分割出的点集”在无向图中定义一个与强连通分量相似的概念，即边双连通分量。因此，“割边分割出的点集”是最适合强连通分量和边双连通分量的定义，它同时适用于有向图和无向图，而强连通分量“任意两个结点都能够互相到达的极大子图”和边双连通分量“删去任意边后任意两个结点仍然连通的极大子图”这两个常见定义则只适用于有向图或无向图。&lt;/p>
&lt;p>对于有向图，我们发现，一个节点 $v$ 的父边是割边，当且仅当从 $v$ 出发无法离开 $v$ 的子树；一个节点 $v$ 是割点，当且仅当从 $v$ 出发，且不经过从 $v$ 出发的返祖边，无法离开 $v$ 的子树。&lt;/p>
&lt;p>关于为什么求强连通分量可以写 &lt;code>low[node]=min(low[node],low[to])&lt;/code> 而求点双连通分量却只能写 &lt;code>low[node]=min(low[node],dfn[node]&lt;/code> 的原因，想必读者也已经懂了。当然 &lt;code>low[node]=min(low[node],low[to])&lt;/code> 也不是一定就不能用于求割点，比如下面的代码就是可行的。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">dfs&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> node) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dfn[node] &lt;span style="color:#f92672">=&lt;/span> low[node] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">++&lt;/span>ind;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> head[node]; i; i &lt;span style="color:#f92672">=&lt;/span> edge[i].next) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>dfn[edge[i].to]) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dfs(edge[i].to);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (low[edge[i].to] &lt;span style="color:#f92672">==&lt;/span> dfn[node]) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> is_cut[node] &lt;span style="color:#f92672">=&lt;/span> true;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> head[node]; i; i &lt;span style="color:#f92672">=&lt;/span> edge[i].next) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> low[node] &lt;span style="color:#f92672">=&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>min(low[node], low[edge[i].to]);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>ICPC2022 南京躺金记</title><link>https://blog.fei.ac/zh/posts/icpc-regional-2022-nanjing/</link><pubDate>Sun, 18 Dec 2022 19:26:18 +0800</pubDate><guid>https://blog.fei.ac/zh/posts/icpc-regional-2022-nanjing/</guid><description>&lt;p>开学的几周因为沉迷摆烂没找组织约人组队。新生赛打完后才发现榜前大佬很多都组好了，只有黄巨愿意跟我预约组明年的队。已经放弃了这个赛季的 ICPC 了。南京赛前几周，黄巨打女生赛用光了参赛次数，于是她的队友 Destiny 和张神找了我，我终于能够参加今年的 ICPC 了。&lt;/p>
&lt;p>Destiny 为在合肥站拿了银首心有不甘，卧薪尝胆南京拿金势在必得。赛前三天 Destiny 把我拉到计院打练习赛（张神怕阳没来），在爆切三题后又再随手切掉一道我调了两个小时的题，带领全队三小时夺金。他欣慰地看着榜单，雄心勃勃地给我画大饼。赛前一天我们三人又聚了一下，两人给我这个一次 XCPC 都没打过的萌新科普知识，展示监考系统使用方法。&lt;/p>
&lt;p>12 月 18 日上午 11 时，比赛开始。我上来就看最后一题 M，一眼丁真 “\/” 形结点就是要挖洞的地方，但是张神指出了水平边的 hack，我只能继续冥思苦想。然后 Destiny 和张神就切掉了 I 和 G。之后我就占用电脑，尝试用叉积判凸+左右找第一个非水平边，写了一个丑陋的 $O(n^2)$ 过掉了 M（尽管实现的精细点也可以达到线性复杂度，但这题没卡 $O(n^2)$ 我就懒得写了）。此时才开赛一小时，Destiny 表示我们已达金牌线。&lt;/p>
&lt;p>在我写 M 的时候 Destiny 和张神想出了 A，M 题一过张神就立刻写起了 A。于是 Destiny 找了目前通过数较多的两题 B 和 D。这两题比较简单，B 题我想了十分钟得到了一个单调队列 $O(n+kq)$ 做法，D 我也一眼丁真搞了一个 $O(n\log^2 n)$ 的二分+平衡树做法。然后张神 A 就 wa 了，Destiny 立刻过去打 D 的平衡树，张神和我静态调试 A。我们瞪了半小时没结果，然后 Destiny 也 wa 了。于是我就去写 B。这段时间，我们从金牌线掉到了银牌线。&lt;/p>
&lt;p>一直到开赛三个小时后，我终于写完了 B 并过掉，张神也找出了 A 代码的错误，Destiny 也发现 $n=2\times 10^5$ 时二分+平衡树的 $O(n\log^2 n)$ 没法三秒内过并想出了 $O(n\log n)$ 的单二分做法（我口糊的双 log 做法害他调了两个小时）。十几分钟后张神过掉了 A，Destiny 开始码 $O(n \log n)$ 的 D 题。&lt;/p>
&lt;p>张神和我开始看 J。我提出了题目的一种抽象，将原题转换为求图的边匹配；张神猜想边匹配存在的充要条件是每个连通块的边数为偶数。我们两个确信这个猜想是对的，在十几分钟的思考后张神提出了 dfs 树构造。这时 Destiny 过掉了 D。他看了看排行榜，告诉我：如果能把 J 过掉我们金牌就有了。我赶紧上机码 J，却在比赛还剩 40 分钟的时候 wa 掉。&lt;/p>
&lt;p>两人赶紧过来帮我查错，几分钟后无果，只能让张神赶紧码一份，Destiny 和我到队员机上查错。结束前 15 分钟，张神也 wa 了，Destiny 和我也未查出任何错误。我们都觉得这道题很可能做不出来了。&lt;/p>
&lt;p>突然，张神指出我们建图的方式会导致本该不同的点重合为同一个点。张神起初表示这个错误没法改，但仅仅一分钟后他突然又喊道“好像可以改”，冲向电脑改代码，我也随即意识到了修改方法，而且对于我的代码来讲，只需要改一行。张神 wa 了，我赶紧切到我的代码改完，提交，通过了这题。吐槽一下这个系统，评测未通过是绿色，通过反而是红色。&lt;/p>
&lt;p>接下来，大家都不再看题，而是对着排行榜分析起来。Destiny 经验丰富，指出某些封榜后交题的队纯属虚张声势；最后他认为我们金牌很有机会，张神却认为不只是很有机会，而是稳了。最后也确实是金。&lt;/p></description></item><item><title>凸包的闵可夫斯基和</title><link>https://blog.fei.ac/zh/posts/sum-of-convex/</link><pubDate>Thu, 25 Aug 2022 09:57:07 +0800</pubDate><guid>https://blog.fei.ac/zh/posts/sum-of-convex/</guid><description>&lt;p>对于两个点集 $A$ 与 $B$，它们的闵可夫斯基和就是 $A + B = {\mathbf a + \mathbf b \rvert \mathbf a \in A, \mathbf b \in B}$。本文只讨论 $A$ 和 $B$ 都是凸包的情况。&lt;/p>
&lt;h2 id="符号和约定">符号和约定&lt;/h2>
&lt;p>$|A|$ 表示凸包 $A$ 的顶点个数，$A_i$ 表示凸包的第 $i$ 个顶点，并且下标是循环的（即 $A_i$ 与 $A_{i+|A|}$ 指同一顶点）。&lt;/p>
&lt;h2 id="结论和实现">结论和实现&lt;/h2>
&lt;p>将 $\vec{A_iA_{i+1}}(i \in [1, |A|])$ 和 $\vec{B_iB_{i+1}}(i \in [1, |B|])$ 这 $|A| + |B|$ 条向量极角排序，并合并其中的同向边，顺次连接，即可得到 $A+B$ 的轮廓。&lt;/p>
&lt;p>实现上，我们不会采用比较斜率的方式来极角排序，因为那样涉及浮点运算；我们可以用向量的叉积作为排序的比较器，实现 $O(n\log n)$ 的算法。进一步地，由于 $\vec{A_iA_{i+1}}(i \in [1, |A|])$ 和 $\vec{B_iB_{i+1}}(i \in [1, |B|])$ 各自原本就是按极角有序的，我们还可以使用类似归并排序的方式 $O(n)$ 地合并它们。&lt;/p>
&lt;h2 id="凸包的闵可夫斯基和在算法竞赛中的应用">凸包的闵可夫斯基和在算法竞赛中的应用&lt;/h2>
&lt;p>利用凸包求和，我们可以快速地进行最值卷积，即以 $O(|F|+|G|)$ 的时间复杂度求出 $\forall k, P_k = \max\limits_{i+j=k} F_i + G_j$ 和 $\forall k, Q_k = \min\limits_{i+j=k} F_i + G_j$；配合分治式合并可以在 $O(n\log n)$ 的时间内完成一系列大小总和不超过 $n$ 的数列的合并。Splay 启发式合并也可以做到 $O(n\log n)$ 的复杂度，并且相比分治式合并维护树上 DP $O(n^2)$ 的复杂度（这和暴力复杂度相同），它却可以 $O(n\log n)$ 维护树上 DP（因为 Splay 启发式合并的复杂度事实上是 $O((n-a)\log n)$，其中 $a$ 为最大数组的大小）。方便起见，我们一般只维护凸包的上轮廓或是下轮廓。&lt;/p>
&lt;p>最值卷积听起来很让人激动。类似“给定若干个特定重量和价值的物品，求总重量为特定值时物品的最大总价值”一类的背包问题难道就这样轻松解决了吗？我们把每单个物品都视作一条线段（在我们的理论中，线段也属于凸包），对这些凸包进行合并，不就得到最终答案对应的凸包了吗？事实并非如此美好。因为最终求到的结果中，某些答案对应的点不在凸包的顶点上，而在凸包的边上；而由于单个物品只能取到线段的两个端点而不能取到线段上的非端点（即物品只可取 0 个或 1 个而不能取 0.5 个），最终我们得到的凸包上的非顶点也是不能取的。也就是说，这样求出的凸包，只有顶点对应了的重量求出的是正确答案，其余均求得偏大了。换句话讲，闵可夫斯基和本质上求的是所有可行解的凸包，这些可行解有的在凸包内部，有的在凸包顶点上；只有那些恰好在顶点上的最优解被得到了，而那些不在顶点上的最优解，我们只知道其在这个凸包的范围内，而不知其具体值。&lt;/p>
&lt;p>为了保证我们能得到所有最优解，必须确保最优解具有凸性，从而它们都在凸包顶点上。最优解是否具有凸性，是能否使用闵可夫斯基和的重要依据。&lt;/p></description></item><item><title>无偏博弈</title><link>https://blog.fei.ac/zh/posts/impartial-game/</link><pubDate>Fri, 05 Aug 2022 15:51:00 +0800</pubDate><guid>https://blog.fei.ac/zh/posts/impartial-game/</guid><description>&lt;p>无偏博弈 (Impartial Game) 是一类满足以下性质的回合制二人游戏：&lt;/p>
&lt;ul>
&lt;li>无偏性：玩家可用的决策仅受当前局势，而不受玩家身份限制&lt;/li>
&lt;li>有限性：在有限次行动后游戏必将以非平局终止&lt;/li>
&lt;li>非随机性：对于目前局势的任意行动，下一局势都唯一确定&lt;/li>
&lt;li>信息完全性：所有玩家都时刻知晓当前局势的所有信息&lt;/li>
&lt;/ul>
&lt;p>无偏博弈的无偏 (Impartial) 并不是指游戏机制的公平 (Fair)，而是指可用决策与玩家身份无关。例如，五子棋等机制公平的棋类游戏不是无偏博弈，因为落白子仅限白方，落黑子仅限黑方；Nim 游戏等机制不公平的游戏却是无偏博弈，因为双方取石子的规则完全相同。&lt;/p>
&lt;p>无偏博弈一定是机制不公平的，即在某一方按某种方式决策时，其一定可以获胜，另一方一定失败，游戏的结果在游戏开始前就已由孰先手孰后手决定了。策梅洛定理指出该性质不只适用于无偏博弈，而适用于所有具有有限性、非随机性、信息完全性的二人回合制游戏。对于无偏博弈，我们最常研究哪一方有必胜策略。&lt;/p>
&lt;h2 id="必胜和必败局势">必胜和必败局势&lt;/h2>
&lt;p>我们定义，在无偏博弈中，先手有必胜策略的局势为必胜局势；先手没有必胜策略的局势 (此时后手一定有必胜策略) 为必败局势；对于某个局势，其后继局势为当前局势下某个玩家单次行动后能得到的所有局势。&lt;/p>
&lt;p>显然，一个局势为必胜局势，当且仅当其后继局势中的某一个为必败局势，或其本身为游戏规定的必胜局势；一个局势为必败局势，当且仅当其后继局势均为必胜局势，或其本身为游戏规定的必败局势。这种递归的定义使得游戏中所有无后继局势的局势都必须被事先规定为必胜或必败局势。&lt;/p>
&lt;p>我们研究无偏博弈中先后手玩家谁有必胜策略，其实就是研究其初始时的局势是必胜局势还是必败局势。&lt;/p>
&lt;h2 id="最基本的无偏博弈">最基本的无偏博弈&lt;/h2>
&lt;p>尼姆游戏是最基本的无偏博弈。一个尼姆游戏包含 $n$ 个含有特定数量道具的堆，玩家轮流选取一个堆，从中取走至少一个道具；最终无道具可取的玩家负。尼姆游戏中含有特定数量道具的堆称作尼姆堆。&lt;/p>
&lt;p>结论指出，含有 $n$ 个尼姆堆 $\left\{a_1, a_2, \ldots, a_n\right\}$ 的尼姆游戏结果与单个含 $\bigoplus\limits_{1\le i \le n}a_i$ 个道具的尼姆堆组成的游戏相同。&lt;/p>
&lt;p>由于在单个含 $0$ 个道具的尼姆堆组成的游戏中后手有必胜策略，单个含非零个道具的尼姆堆组成的游戏中先手有必胜策略，结合上述结论，则某个尼姆游戏 $\left\{a_1, a_2, \ldots, a_n\right\}$ 为先手必胜，当且仅当 $\bigoplus\limits_{1\le i \le n}a_i \neq 0$。&lt;/p>
&lt;p>这个结论是易证的。我们只需用以下四点说明：&lt;/p>
&lt;ol>
&lt;li>必败局势 $\{0, 0, \ldots, 0\}$ 属于 $\bigoplus\limits_{1\le i \le n}a_i = 0$ 的形式。&lt;/li>
&lt;li>总是不存在将 $\bigoplus\limits_{1\le i \le n}a_i = 0$ 保持为 $\bigoplus\limits_{1\le i \le n}a_i = 0$ 的行动。&lt;/li>
&lt;li>总是存在一种将 $\bigoplus\limits_{1\le i \le n}a_i \neq 0$ 转为 $\bigoplus\limits_{1\le i \le n}a_i = 0$ 的行动。&lt;/li>
&lt;li>经过有限次行动，游戏将以非平局结束。&lt;/li>
&lt;/ol>
&lt;h2 id="spraguegrundy-定理">Sprague–Grundy 定理&lt;/h2>
&lt;p>Sprague–Grundy 定理又称斯普莱格–格隆第定理或 SG 定理，其指出任何无偏博弈都可以按如下规则等效为单个尼姆堆的尼姆游戏：&lt;/p>
&lt;p>定义关于游戏状态 $X$ 的函数 $\operatorname{SG}(X)$：&lt;/p>
&lt;ul>
&lt;li>若 $X$ 是终止局势，$\operatorname{SG}(X)=0$。要求此时 $X$ 总为必败状态。&lt;/li>
&lt;li>否则，设 $X$ 所有后继局势的集合为 $S$，$\operatorname{SG}(X)=\operatorname{mex}\{\mathrm{SG}(Y) | Y \in S\}$。&lt;/li>
&lt;/ul>
&lt;p>状态 $X$ 可以等效为单个大小为 $\operatorname{SG}(X)$ 的尼姆堆。特别地，若状态 $X$ 由若干个互相独立的子状态 $P_1, P_2, \ldots, P_n$ 组成，也有 $\operatorname{SG}(X) = \bigoplus\limits_{1\le i \le n}\operatorname{SG}(P_i)$。&lt;/p>
&lt;p>证明如下：由 $\operatorname{mex}$ 函数的性质可知，对于 $i = 0, 1, \ldots, \operatorname{SG}(X) - 1$，$X$ 均有一个满足 $\operatorname{SG}(Y) = i$ 的后继局势 $Y$。对于走向可能存在的 $\operatorname{SG}(Y) &amp;gt; \operatorname{SG}(X)$ 的后继局势 $Y$ 的行动，后手方也总可以在下一次行动中将局势的 $\operatorname{SG}$ 值变回 $\operatorname{SG}(X)$ 来抵消这种影响。&lt;/p>
&lt;p>对于必胜方来讲，只需要将各个子状态 $X$ 视作大小为 $\operatorname{SG}(X)$ 的尼姆堆即可。若必败方进行使某堆 $\operatorname{SG}$ 值减小的行动，则必胜方可按尼姆博弈策略应对；若必败方进行使某堆 $\operatorname{SG}$ 值增大的行动，则必胜方只需在下一次行动中恢复该堆的 $\operatorname{SG}$ 值。故原游戏与按 Sprague–Grundy 定理等效得出的尼姆游戏总有相同的必胜方，即为等效。&lt;/p></description></item><item><title>最小生成树上路径为最小瓶颈路的证明</title><link>https://blog.fei.ac/zh/posts/proof-mbp-mst/</link><pubDate>Mon, 01 Aug 2022 16:01:25 +0800</pubDate><guid>https://blog.fei.ac/zh/posts/proof-mbp-mst/</guid><description>&lt;p>对于无向图 $G$，$x$ 到 $y$ 的最小瓶颈路定义为它们间所有简单路径中最大边权最小的路径。显然，$x$ 到 $y$ 的最小瓶颈路不一定只有唯一一条。&lt;/p>
&lt;p>一个广为人知的结论是，$G$ 的一个最小生成树上 $x$ 到 $y$ 的路径是它们间的一个最小瓶颈路。下面给出两个证明。&lt;/p>
&lt;h2 id="从构造方法证明">从构造方法证明&lt;/h2>
&lt;p>假定我们的最小生成树由 Kruskal 算法构造。&lt;/p>
&lt;p>设 $x$ 到 $y$ 最小瓶颈路上的最大边权为 $m$。由于 $x$ 到 $y$ 最小瓶颈路上的最大边权为 $m$，一定可以仅通过边权小于等于 $m$ 的边使 $x$ 和 $y$ 联通，则在 Kruskal 算法仅处理完边权小于等于 $m$ 的边时，$x$ 和 $y$ 已在生成树中联通，即最小生成树中 $x$ 到 $y$ 的路径上的最大边权小于等于 $m$。&lt;/p>
&lt;p>类似地，也可以说明 Prim 算法构造的最小生成树具有该性质。这样不能证明其他最小生成树也具有性质。&lt;/p>
&lt;h2 id="反证法">反证法&lt;/h2>
&lt;p>设 $x$ 到 $y$ 最小瓶颈路上的最大边权为 $m$。假设最小生成树 $T = (V, E)$ 上 $x$ 到 $y$ 的路径上存在边权大于 $m$ 的边，则我们去除 $T$ 中所有边权大于 $m$ 的边 (记作 $V_m$)，$T$ 中剩余的边与顶点形成的图 $T_m = (\complement_VV_m, E)$ 中含超过一个连通块。&lt;/p>
&lt;p>由于 $x$ 到 $y$ 存在一条所有边的边权都不超过 $m$ 的路径，一定可以加入 $p$ 条边权不大于 $m$ 的边，使得包含 $x$ 所在连通块和 $y$ 所在连通块的一系列共 $p + 1$ 个连通块连通。之后再加入 $|V_m| - p$ 个 $V_m$ 中的边，即可形成一个新的生成树 $T^\prime$。&lt;/p>
&lt;p>比较 $T$ 和 $T^\prime$，发现 $T^\prime$ 以一些边权不大于 $m$ 的边替换了 $T$ 中边权大于 $m$ 的边，故 $T^\prime$ 的边权和比 $T$ 的更小，$T$ 不是最小生成树，与假设矛盾。&lt;/p></description></item><item><title>从概率生成函数出发研究离散概率</title><link>https://blog.fei.ac/zh/posts/pgf-discrete-possibility/</link><pubDate>Sun, 17 Jul 2022 20:16:44 +0800</pubDate><guid>https://blog.fei.ac/zh/posts/pgf-discrete-possibility/</guid><description>&lt;p>概率生成函数是一种特殊的生成函数，其导数和卷积在离散概率的研究中都有意义。&lt;/p>
&lt;h2 id="一些基础概念">一些基础概念&lt;/h2>
&lt;p>对于一个仅取非负实数值的随机变量 $X$，我们定义其概率生成函数为&lt;/p>
&lt;p>$$
G_X(z) = \sum_{k\ge 0} P(X=k)z^k
$$&lt;/p>
&lt;p>与一般的幂级数形式的生成函数不同，概率生成函数存在非整数次的项。&lt;/p>
&lt;h2 id="导数期望与方差">导数、期望与方差&lt;/h2>
&lt;p>我们很少研究生成函数的导数，但概率生成函数的导数却值得研究：它与随机变量的期望和方差关系匪浅。由于&lt;/p>
&lt;p>$$
G_X^\prime(z) = \sum_{k\ge 0} kP(X=k)z^{k-1}
$$&lt;/p>
&lt;p>我们可以得到&lt;/p>
&lt;p>$$
E(X) = \sum_{k\ge 0} kP(X=k) = G_X^\prime(1)
$$&lt;/p>
&lt;p>同理我们也可以用 $G_X(z)$ 表示 $X$ 的方差 $V(X)$：&lt;/p>
&lt;p>$$
\begin{aligned}
V(X) &amp;amp;= E(X^2) - E^2(X) \newline
&amp;amp;= E(X^2) - \left(G_X^\prime(1)\right)^2 \newline
&amp;amp;= G_X^{\prime\prime}(1) + G_X^\prime(1) - \left(G_X^\prime(1)\right)^2
\end{aligned}
$$&lt;/p>
&lt;p>其中&lt;/p>
&lt;p>$$
\begin{aligned}
E(X^2) &amp;amp;= \sum_{k\ge 0} k^2P(X=k) \newline
&amp;amp;= \sum_{k\ge 0}k(k-1)P(X=k) + \sum_{k\ge 0}kP(X=k) \newline
&amp;amp;= G_X^{\prime\prime}(1) + G_X^\prime(1)
\end{aligned}
$$&lt;/p>
&lt;p>总而言之，我们有&lt;/p>
&lt;p>$$
\begin{aligned}
E(X) &amp;amp;= G_X^\prime(1) \newline
V(X) &amp;amp;= G_X^{\prime\prime}(1) + G_X^\prime(1) - \left(G_X^\prime(1)\right)^2
\end{aligned}
$$&lt;/p>
&lt;p>利用这个关系，我们可以方便地求出一些随机变量的期望、方差。以 $n$ 阶均匀分布为例 (即 $X$ 以 $\frac 1 n$ 的概率取遍 $[0,n-1]$ 范围内的每一个整数)：&lt;/p>
&lt;p>$X$ 的概率生成函数为&lt;/p>
&lt;p>$$
G_n(z) = \frac{1}{n}\sum_{k=0}^{n-1}z^k = \frac{1-z^n}{n(1-z)}
$$&lt;/p>
&lt;p>研究一般的生成函数时，我们只关心各项系数而不关心生成函数在 $z$ 取特定值时的值，因而这种封闭形式的表达是没有问题的。但此时我们研究的是概率生成函数，我们需要知道 $z=1$ 时导数的值，而这种封闭形式的表达却要求 $z\neq 1$ 了。&lt;/p>
&lt;p>一种思路是运用洛必达法则求 $\lim\limits_{z\rightarrow 1}G_n^\prime(z)$ 和 $\lim\limits_{z\rightarrow 1}G_n^{\prime\prime}(z)$，进而求出 $X$ 的期望、方差。这种方法十分困难，在此不做展开。&lt;/p>
&lt;p>另一种思路是运用泰勒定理，得到&lt;/p>
&lt;p>$$
G_n(1+z) = \sum_{k\ge 0} \frac{G^{(k)}(1)}{k!}z^k
$$&lt;/p>
&lt;p>而由二项式定理&lt;/p>
&lt;p>$$
G_n(1+z) = \frac{(1+z)^n-1}{nz} = \sum_{k\ge 0} \frac{1}{n} \binom{n}{k} z^{k-1}
$$&lt;/p>
&lt;p>于是&lt;/p>
&lt;p>$$
\frac{G^{(k)}(1)}{k!} = \frac{1}{n} \binom{n}{k+1}
$$&lt;/p>
&lt;p>故&lt;/p>
&lt;p>$$
G_n^\prime(1)=\frac{n-1}{2}, G_n^{\prime\prime}(1)=\frac{(n-1)(n-2)}{3}
$$&lt;/p>
&lt;p>结合之前推导的关系，我们可以得出&lt;/p>
&lt;p>$$
E(X)=\frac{n-1}{2}, V(X)=\frac{n^2-1}{12}
$$&lt;/p>
&lt;p>类似地，我们也可以求泊松分布的期望、方差：&lt;/p>
&lt;p>$$
G_\lambda(z) = \sum_{k \ge 0}\frac{e^{-\lambda}\lambda^k}{k!}z^k = e^{\lambda(z-1)}
$$&lt;/p>
&lt;p>故&lt;/p>
&lt;p>$$
G_\lambda(1+z) = e^{\lambda z} = \sum \frac{\lambda^k}{k!}z^k
$$&lt;/p>
&lt;p>与泰勒展开式比较，可得 $G_\lambda^{(k)}=\lambda^k$，最终得到&lt;/p>
&lt;p>$$
E(X)=\lambda, V(X)=\lambda
$$&lt;/p>
&lt;p>然而，这种期望、方差的求法也不是万能的，将它用于二项分布就不是个好主意。&lt;/p>
&lt;h2 id="推导期望方差的可加性">推导期望、方差的可加性&lt;/h2>
&lt;p>设 $X$ 和 $Y$ 为两相互独立的随机变量，则&lt;/p>
&lt;p>$$
P(X = a \land Y = b) = P(X = a)P(Y = b)
$$&lt;/p>
&lt;p>那么&lt;/p>
&lt;p>$$
P(X + Y = n) = \sum_{a + b = n}P(X = a \land Y = b) = \sum_{a + b = n}P(X = a)P(Y = b)
$$&lt;/p>
&lt;p>这是一个卷积形式的式子，可以完美地用生成函数表示。即，若 $X$ 和 $Y$ 相互独立，我们就可以得到&lt;/p>
&lt;p>$$
G_{X+Y}(z) = G_X(z)G_Y(z)
$$&lt;/p>
&lt;p>这个式子是我们利用概率生成函数推导期望、方差可加性的基石。设随机变量 $X$、$Y$ 和 $X+Y$ 的概率生成函数分别为 $F(z)$、$G(z)$ 和 $H(z)$，根据我们推导出的关系 $H(z)=F(z)G(z)$，可以得到&lt;/p>
&lt;p>$$
\begin{aligned}
H^\prime(z) &amp;amp;= F^\prime(z)G(z) + F(z)G^\prime(z) \newline
H^{\prime\prime}(z) &amp;amp;= F^{\prime\prime}(z)G(z) + 2F^\prime(z)G^\prime(z) + F(z)G^{\prime\prime}(z)
\end{aligned}
$$&lt;/p>
&lt;p>由概率生成函数的定义可知 $F(1)=G(1)=H(1)=1$，那么&lt;/p>
&lt;p>$$
\begin{aligned}
H^\prime(1) &amp;amp;= F^\prime(1) + G^\prime(1) \newline
H^{\prime\prime}(1) &amp;amp;= F^{\prime\prime}(1) + 2F^\prime(1)G^\prime(1) + G^{\prime\prime}(1)
\end{aligned}
$$&lt;/p>
&lt;p>代入公式&lt;/p>
&lt;p>$$
\begin{aligned}
E(X) &amp;amp;= G_X^\prime(1) \newline
V(X) &amp;amp;= G_X^{\prime\prime}(1) + G_X^\prime(1) - \left(G_X^\prime(1)\right)^2
\end{aligned}
$$&lt;/p>
&lt;p>可得&lt;/p>
&lt;p>$$
\begin{aligned}
E(X+Y) &amp;amp;= E(X) + E(Y) \newline
V(X+Y) &amp;amp;= V(X) + V(Y)
\end{aligned}
$$&lt;/p>
&lt;p>即期望和方差都具有可加性。&lt;/p>
&lt;h2 id="二项分布和负二项分布">二项分布和负二项分布&lt;/h2>
&lt;p>二项分布我们都十分熟悉。由于它可以被看作 $n$ 个相互独立的伯努利试验的和，由可加性我们知它的期望和方差分别为 $np$ 和 $np(1-p)$。&lt;/p>
&lt;p>而负二项分布是指：进行若干次相互独立的伯努利试验，成功次数为 $n$ 次时失败次数的概率分布。假定单次伯努利试验的成功概率为 $p$，那么成功一次时失败次数 $X$ 的概率分布显然满足&lt;/p>
&lt;p>$$
P(X=k) = (1-p)^kp
$$&lt;/p>
&lt;p>那么我们可以写出 $X$ 的概率生成函数为&lt;/p>
&lt;p>$$
F(z) = \sum_{i \ge 0}(1-p)^ipz^i=\dfrac{p}{1-(1-p)z}
$$&lt;/p>
&lt;p>且其期望和方差分别为&lt;/p>
&lt;p>$$
E(X) = F^\prime(1) = \dfrac{(1-p)}{p}, V(X) = F^{\prime\prime}(1) + F^\prime(1) - \left(F^\prime(1)\right)^2 = \dfrac{(1-p)}{p^2}
$$&lt;/p>
&lt;p>负二项分布进行了重复了上述过程 $n$ 次，且每次相互独立，则我们也可知 $X \sim NB(n, p)$ 的概率分布函数就是 $F(z)$ 的 $n$ 次方，即：&lt;/p>
&lt;p>$$
G_n(z) = F^n(z) = \left(\dfrac{p}{1-(1-p)z}\right)^n=\sum\binom{n+i-1}{i}p^n(1-p)^iz^i
$$&lt;/p>
&lt;p>当然它的期望和方差也可得分别为 $\dfrac{n(1-p)}{p}$ 和 $\dfrac{n(1-p)}{p^2}$。&lt;/p>
&lt;p>负二项分布之名何来？我们发现，由于 $\dfrac{1}{F(1)} = 1$，$\dfrac{1}{F(z)}=\dfrac{1}{p}-\dfrac{1-p}{p}z$ 可被视做一次成功概率为 $-\dfrac{1-p}{p}$ （尽管它是个负数）的伯努利分布对应的概率分布函数，而 $G_n(z)=\left(\dfrac{1}{F(z)}\right)^{-n}$ 对应的就是 $-n$ （尽管这是个负数）次这样的伯努利试验的二项分布。&lt;/p>
&lt;p>未完待续&lt;/p></description></item><item><title>我的新博客</title><link>https://blog.fei.ac/zh/posts/hello-world/</link><pubDate>Sun, 03 Jul 2022 19:22:44 +0800</pubDate><guid>https://blog.fei.ac/zh/posts/hello-world/</guid><description>&lt;p>一年的紧张备考后，我又有空写博客啦！&lt;/p>
&lt;p>不过我曾经维护过的博客的相关配置早已丢失，仅其中博文的草稿仍有备份。与其费劲心思恢复旧博客，不如另起炉灶，于是我搭建了这一新博客，一方面保留了一部分过往博文，另一方面也添加了新的内容。&lt;/p></description></item><item><title>关于</title><link>https://blog.fei.ac/zh/about/</link><pubDate>Sat, 02 Apr 2022 23:03:23 +0800</pubDate><guid>https://blog.fei.ac/zh/about/</guid><description>&lt;h2 id="关于我">关于我&lt;/h2>
&lt;p>前 OIer，曾获 APIO2020 银牌，CSP2020 提高组一等奖，NOIP2020 一等奖，NOI2021 冬令营银牌，ICPC2022 南京金牌，ICPC2022 EC-Final 铜牌以及许多省赛金牌。现就读于武汉大学计算机学院。&lt;/p>
&lt;p>请根据页面左下角提供的信息联系我。推荐使用邮件或是本站评论系统。&lt;/p>
&lt;h2 id="关于本站">关于本站&lt;/h2>
&lt;p>因本人是东方厨，为本站取名“绯想天”。&lt;/p>
&lt;p>“绯想天”是我基于 &lt;a href="https://gohugo.io/">Hugo&lt;/a> 和 &lt;a href="https://github.com/heyeshuang/hugo-theme-tokiwa">tokiwa&lt;/a>（其按 &lt;a href="https://github.com/heyeshuang/hugo-theme-tokiwa/blob/master/LICENSE.md">MIT 协议&lt;/a>分发）搭建的静态博客，所有内容按 &lt;a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0&lt;/a> 协议分发。本站部署于 &lt;a href="https://pages.github.com/">Github Pages&lt;/a>，以 &lt;a href="https://utteranc.es/">utterances&lt;/a> 作为评论系统，您可以通过 Github 账号登录并评论。&lt;/p>
&lt;p>“绯想天”起初是我作为一个 OIer 的学习笔记，仅包含一些简单的算法知识或是题目解析，并以 feiko.me 作为域名。高考后，我注册了 flandre.love 域名，将 feiko.me 归档至 &lt;a href="https://old.flandre.love">old.flandre.love&lt;/a>，并整理其中部分文章，搭建了本站。我也开始将自己对一些现象的思考研究加入“绯想天”，使其不再仅仅是一个学习笔记归档，而是一个内容丰富多样的个人博客。&lt;/p></description></item><item><title>Boruvka 算法</title><link>https://blog.fei.ac/zh/posts/boruvka/</link><pubDate>Fri, 26 Mar 2021 11:38:23 +0800</pubDate><guid>https://blog.fei.ac/zh/posts/boruvka/</guid><description>&lt;p>Borůvka 算法是一种基于贪心的最小生成树算法，它比 Prim 算法和 Kruskal 算法更加古老。在 Borůvka 算法的基础上，已经发展出了&lt;a href="https://blog.fei.ac/files/a-randomized-linear-time-algorithm-to-find-mst.pdf">线性的最小生成树算法&lt;/a>。&lt;/p>
&lt;p>Borůvka 算法的思想是：每次迭代，选取每一个连通块中最小的连向另一个连通块的边，将其加入最小生成树。其过程如下伪代码所示：&lt;/p>
&lt;p>$$
\begin{array}{ll}
1 &amp;amp; \textbf{Input.}\text{ Edge set }E\text{ and vertex set }V\text{ of the graph}\newline
2 &amp;amp; \textbf{Output.}\text{ A minimum spanning tree of the graph}\newline
3 &amp;amp; \textbf{Method.}\newline
4 &amp;amp; \textbf{Function}\text{ Borůvka(void)}\newline
5 &amp;amp; \qquad S\text{ is a graph of vertex set }V\text{ and empty edge set}\newline
6 &amp;amp; \qquad\textbf{while}\text{ the count of connected components in }S&amp;gt;1\newline
7 &amp;amp; \qquad\qquad T\text{ is an empty set}\newline
8 &amp;amp; \qquad\qquad\textbf{for}\text{ each connected component }C\text{ in }S\newline
9 &amp;amp; \qquad\qquad\qquad\text{edge }(u,v)\text{ is the minimum edge that connects }C\text{ and another component}\newline
10 &amp;amp; \qquad\qquad\qquad\textbf{if }(u,v)\notin T\newline
11 &amp;amp; \qquad\qquad\qquad\qquad T\gets T+(u,v)\newline
12 &amp;amp; \qquad\qquad\textbf{for}\text{ each edge }(u,v)\in T\newline
13 &amp;amp; \qquad\qquad\qquad S\gets S+(u,v)\newline
14 &amp;amp; \qquad\textbf{return }S\newline
15 &amp;amp; \textbf{End}\newline
16 &amp;amp; \textbf{return }\text{Borůvka()}
\end{array}
$$&lt;/p>
&lt;p>对于每次迭代，迭代后的每个连通块至少包含两个迭代前的连通块，故连通块总数至少减少一半，迭代次数为对数级别。&lt;/p>
&lt;p>可以发现，对于每次迭代，若 $T$ 中的某些边可以连接若干个连通块形成环，则该环上属于 $T$ 的所有边的边权一定相等。因此只要确保所有边权互不相等我们就可断定 Borůvka 算法必然不会成环。&lt;/p>
&lt;p>实际情况中可能会出现一些边边权相等的情况，但我们可以给边随意分配一个第二关键字，或是用并查集排除形成环的边。因此，Borůvka 算法可以用于存在边权相同的图。&lt;/p></description></item><item><title>扩展欧几里得算法得出的解的绝对值上界</title><link>https://blog.fei.ac/zh/posts/exgcd/</link><pubDate>Fri, 19 Mar 2021 14:57:56 +0800</pubDate><guid>https://blog.fei.ac/zh/posts/exgcd/</guid><description>&lt;p>众所周知，扩展欧几里得算法是用于求解线性不定方程 $ax+by=(a,b)$ 的一组可行解的，其时间复杂度为对数级。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">exgcd&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> a, &lt;span style="color:#66d9ef">int&lt;/span> b, &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>x, &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>y){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span>(&lt;span style="color:#f92672">!&lt;/span>b) &lt;span style="color:#66d9ef">return&lt;/span> (&lt;span style="color:#66d9ef">void&lt;/span>)(x &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>, y &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> exgcd(b, a &lt;span style="color:#f92672">%&lt;/span> b, y, x), y &lt;span style="color:#f92672">-=&lt;/span> a &lt;span style="color:#f92672">/&lt;/span> b &lt;span style="color:#f92672">*&lt;/span> x;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在计算过程中出现了乘法。$x$ 和 $y$ 是否有可能发生整型溢出呢？&lt;/p>
&lt;p>事实上，除了 $b=0$ 的情况，在扩展欧几里得的过程中总是有 $|x|\le b,|y|\le a$，不可能发生溢出。这里给出简要证明：&lt;/p>
&lt;p>记 $S=(a,b,x,y)$ 为一个同余方程 $ax+by=(a,b)$。中止状态解的同余方程为 $S_1=(\gcd(a,b),0,1,0)$。&lt;/p>
&lt;p>考虑终止状态的前一个状态 $S_2=(a_2,b_2,x_2,y_2)$。此时一定有 $b_2\mid a_2$。根据公式&lt;/p>
&lt;p>$$
\begin{cases}x_2=y_1\newline
y_2=x_1-\left\lfloor\dfrac{a}{b}\right\rfloor y_1\end{cases}
$$&lt;/p>
&lt;p>解得 $x_2=0,y_2=1$。由于 $b_2\neq 0$ 且 $b_2\mid a_2$，则该状态满足 $|x_2|\le b_2,|y_2|\le a_2$。&lt;/p>
&lt;p>归纳证明后面的情况。对于后面的任何一个状态 $S_i$ ($i&amp;gt;2$)，我们有 $x_i=y_{i-1},y_i=x_{i-1}-\left\lfloor\dfrac{a}{b}\right\rfloor y_{i-1}$。将 $|x_{i-1}|\le b_{i-1}=a_i\bmod b_i,|y_{i-1}|\le a_{i-1}=b_i$ 代入得到 $|x_i|\le b_i,|y_i|\le a_i$。&lt;/p></description></item><item><title>静态链分治和树上启发式合并</title><link>https://blog.fei.ac/zh/posts/dsu-on-tree/</link><pubDate>Thu, 18 Mar 2021 10:22:29 +0800</pubDate><guid>https://blog.fei.ac/zh/posts/dsu-on-tree/</guid><description>&lt;p>静态链分治 (DSU on Tree) 和树上启发式合并 (Heuristic Merge on Tree) 是简洁有力的处理树上问题的工具，而代价仅为将复杂度乘上 $O(\log n)$。在处理询问时，要求询问离线。&lt;/p>
&lt;p>很多人把静态链分治和树上启发式合并混为一谈，但它们其实是截然不同的算法。大家常见并称之为“树上启发式合并”的算法其实是静态链分治。&lt;/p>
&lt;h2 id="静态链分治">静态链分治&lt;/h2>
&lt;blockquote>
&lt;p>给定一棵有根树，每个节点上都有一种颜色。回答所有子树中不同颜色的个数。&lt;/p>
&lt;/blockquote>
&lt;p>这是一道老生常谈的经典题，可以用线段树合并 (复杂度 $O(n\log n)$) 和树分块 (复杂度 $O(n\sqrt n)$，又称树上莫队) 等方法解决。但静态链分治也可以解决此题，而且常数较小 (不过我自己写的静态链分治比线段树合并慢)。&lt;/p>
&lt;p>利用一个数组 $\text{cnt}$ 来记录每种颜色的出现次数。对树进行重链剖分，处理节点 $i$ 时：&lt;/p>
&lt;ul>
&lt;li>先处理所有轻儿子，得到轻儿子子树中所有节点的答案，并在处理完每个轻儿子后清空 $\text{cnt}$。&lt;/li>
&lt;li>然后处理重儿子，得到重儿子子树中所有节点的答案。处理完后不清空 $\text{cnt}$。&lt;/li>
&lt;li>最后再遍历轻儿子。至此 $i$ 子树中的所有节点都计入了 $\text{cnt}$，我们得到了 $i$ 的答案。&lt;/li>
&lt;/ul>
&lt;h2 id="复杂度证明">复杂度证明&lt;/h2>
&lt;p>静态链分治中有四个产生复杂度的过程：处理轻儿子、清空轻儿子、处理重儿子、遍历轻儿子 (和本身)。&lt;/p>
&lt;p>其中，清空轻儿子和遍历轻儿子的复杂度显然都是 $O(n\log n)$，因为每个点到根经过的轻边数都是 $O(\log n)$ 级的。&lt;/p>
&lt;p>剩下的过程的复杂度为 $O(n)$。因此总复杂度为 $O(n\log n)$。&lt;/p>
&lt;h2 id="例题">例题&lt;/h2>
&lt;p>&lt;a href="https://codeforces.com/problemset/problem/600/E">Lomsat gelral&lt;/a>&lt;br>
&lt;a href="https://uoj.ac/problem/284">快乐游戏鸡&lt;/a>&lt;/p>
&lt;h2 id="树上启发式合并">树上启发式合并&lt;/h2>
&lt;blockquote>
&lt;p>给定一棵有根树，定义 $d(u,v)$ 为从 $u$ 到 $v$ 的简单路径包含的边数。令 $a=\operatorname{LCA}(u,v),f(u,v)=\gcd(d(u, a), d(a, v))$，求满足 $f(u,v)=i$ 的数对 $(u,v)$ 个数。&lt;/p>
&lt;/blockquote>
&lt;p>这是一道 UOJ 上的题 &lt;a href="https://uoj.ac/problem/33">树上 GCD&lt;/a> ，标算为 $O(n\sqrt n)$ 的点分治。但此题也可以用树上启发式合并做到几乎同样的复杂度，并且常数奇小，代码健康。&lt;/p>
&lt;p>我们只要求出满足 $d\mid f(u,v)$ 的 $(u,v)$ 个数，就可以通过容斥或者莫比乌斯反演得到答案。我们设定一个分治界限 $B$，对于 $d\in[1,B]$，用动态规划求出满足 $i\mid f(u,v)$ 的点对数，复杂度为 $O(nB)$。&lt;/p>
&lt;p>对于 $d\in [B+1,n]$，使用树上启发式合并。设 $dp_{i,j}$ 表示以 $i$ 节点为链顶，且长度为 $j$ 的链的个数。每次将 $i$ 的一个儿子的答案与 $i$ 的答案合并时，我们正常地启发式合并即可。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>dp[i].push_back(&lt;span style="color:#ae81ff">1&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">/* (i,fa[i]) 也是一个长度为 1 的链。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * 这里 dp 数组是倒着的，dp[i][dp.size()-j] 表示长度为 j 的链的个数
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">if&lt;/span>(dp[fa[i]].size() &lt;span style="color:#f92672">&amp;lt;&lt;/span> dp[i].size())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>swap(dp[fa[i]], dp[i]);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">/* 在 C++11 以下的标准中，
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * std::swap 不是 O(1) 的，必须使用 dp[fa[i]].swap(dp[i]) 来保证复杂度
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> j &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; j &lt;span style="color:#f92672">&amp;lt;&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span>)dp[i].size(); &lt;span style="color:#f92672">++&lt;/span>j)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dp[fa[i]][dp[fa[i]].size() &lt;span style="color:#f92672">-&lt;/span> j] &lt;span style="color:#f92672">+=&lt;/span> dp[i][dp[i].size() &lt;span style="color:#f92672">-&lt;/span> j];
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这一部分的复杂度为 $O(n\log n)$。&lt;/p>
&lt;p>除了合并儿子与父亲的 $dp$ 数组，我们还要统计对答案的贡献：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>dp[i].push_back(&lt;span style="color:#ae81ff">1&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">if&lt;/span>(dp[fa[i]].size() &lt;span style="color:#f92672">&amp;lt;&lt;/span> dp[i].size())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>swap(dp[fa[i]], dp[i]);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> sz1 &lt;span style="color:#f92672">=&lt;/span> dp[i].size(), sz2 &lt;span style="color:#f92672">=&lt;/span> dp[fa[i]].size();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> d &lt;span style="color:#f92672">=&lt;/span> B &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; d &lt;span style="color:#f92672">&amp;lt;=&lt;/span> sz1; &lt;span style="color:#f92672">++&lt;/span>d){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">long&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> cnt1 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0ll&lt;/span>, cnt2 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0ll&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> j &lt;span style="color:#f92672">=&lt;/span> d; j &lt;span style="color:#f92672">&amp;lt;=&lt;/span> sz1; j &lt;span style="color:#f92672">+=&lt;/span> d)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cnt1 &lt;span style="color:#f92672">+=&lt;/span> dp[i][sz1 &lt;span style="color:#f92672">-&lt;/span> j];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> j &lt;span style="color:#f92672">=&lt;/span> d; j &lt;span style="color:#f92672">&amp;lt;=&lt;/span> sz2; j &lt;span style="color:#f92672">+=&lt;/span> d)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cnt2 &lt;span style="color:#f92672">+=&lt;/span> dp[fa[i]][sz2 &lt;span style="color:#f92672">-&lt;/span> j];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ans[d] &lt;span style="color:#f92672">+=&lt;/span> cnt1 &lt;span style="color:#f92672">*&lt;/span> cnt2;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// ans[d] 表示满足 d | f(u,v) 的 (u,v) 的个数
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> j &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; j &lt;span style="color:#f92672">&amp;lt;&lt;/span> sz1; &lt;span style="color:#f92672">++&lt;/span>j)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dp[fa[i]][sz2 &lt;span style="color:#f92672">-&lt;/span> j] &lt;span style="color:#f92672">+=&lt;/span> dp[i][sz1 &lt;span style="color:#f92672">-&lt;/span> j];
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这一部分的复杂度较难分析。只有大于 $B$ 的 $\text{sz1}$ 才会对时间产生 $O(\text{sz2}\log\text{sz1})=O(n\log\text{sz1})$ 的贡献，而这种两个 $\text{dp}$ 数组的大小都大于 $B$ 的合并至多出现 $\dfrac{n}{B}$ 次，故复杂度为 $O\left(\dfrac{n^2\log n}{B}\right)$。&lt;/p>
&lt;p>取一个 $\sqrt{n\log n}$ 量级的 $B$ 即可得到理论最优复杂度 $O(n\sqrt{n\log n})$。实际上取 $B=10$ 最快。我怀疑这个取值是假的，但构造了许多组数据也没能卡掉。&lt;/p>
&lt;p>从这道题我们可以看出来，树上启发式合并本质上就是用启发式合并来优化树形 DP，是一种常数非常小的优秀算法，非常适合代替有根树上的点分治。它的缺陷就是启发式合并只能优化转移方程很简单的树形 DP，不如线段树合并用处广泛。&lt;/p>
&lt;blockquote>
&lt;p>说到有根树点分治，不能不让人想起&lt;a href="https://uoj.ac/problem/7">购票&lt;/a>。不过购票的所谓“分治”其实是 CDQ 分治，要求计算的并非树上路径，因而没法用树上启发式合并了。&lt;/p>
&lt;/blockquote></description></item><item><title>多项式对数函数、指数函数和欧拉变换</title><link>https://blog.fei.ac/zh/posts/polylog/</link><pubDate>Sat, 27 Feb 2021 10:46:08 +0800</pubDate><guid>https://blog.fei.ac/zh/posts/polylog/</guid><description>&lt;p>与一般想法不同，多项式也有自己的对数函数和指数函数。它们也可以在 $O(n\log n)$ 的优秀时间内求解。&lt;/p>
&lt;p>有这么一个式子广为人知&lt;/p>
&lt;p>$$
e^x=\sum\limits_{i=0}^{+\infty}\dfrac{x^i}{i!}
$$&lt;/p>
&lt;p>事实上对数函数也可以像这样用无限幂级数定义：&lt;/p>
&lt;p>$$
\ln(1-x)=-\sum\limits_{i=1}^{+\infty}\dfrac{x^i}{i}
$$&lt;/p>
&lt;p>$$
\ln(1+x)=-\sum\limits_{i=1}^{+\infty}\dfrac{(-1)^i\cdot x^i}{i}
$$&lt;/p>
&lt;p>指数函数的泰勒展开式对于任意实数 $x$ 都成立，对数函数的泰勒展开式只对定义域内的一些 $x$ 成立；不过我们并不关心 $x$，只关心其系数。多项式的指数函数和对数函数就是用这些级数定义的。因为这些级数都是无限级数，多项式只在模意义下存在指数函数和对数函数。&lt;/p>
&lt;h2 id="多项式对数函数">多项式对数函数&lt;/h2>
&lt;p>多项式 $g(x)$ 在模 $x^n$ 意义下的对数函数存在，当且仅当其常数项为 $1$，否则它对应的泰勒级数不收敛。把 $\ln g(x)$ 视作一个关于 $x$ 的函数，我们有&lt;/p>
&lt;p>$$
\begin{aligned}\left[\ln g(x)\right]^\prime&amp;amp;=\dfrac{g(x)^\prime}{g(x)}\newline
\ln g(x)&amp;amp;=\int\mathrm{d}\ln g(x)=\int\dfrac{g(x)^\prime}{g(x)}\mathrm{d}x\end{aligned}
$$&lt;/p>
&lt;p>只要对 $g(x)$ 求导，再乘上 $\dfrac{1}{g(x)}$ 就能够得到 $\ln g(x)$ 的导数，这个导数的积分就是 $\ln(g(x))$。多项式求导、积分都是非常容易的事情，但是，$\dfrac{g(x)^\prime}{g(x)}$ 的不定积分随常数项的不同有无穷多个，我们应该取哪一个呢？我们取常数项为 $0$ 的那个作为答案，因为只有常数项为 $0$ 的多项式在模意义下存在指数函数。&lt;/p>
&lt;h2 id="多项式指数函数">多项式指数函数&lt;/h2>
&lt;p>上面我们提到，多项式 $g(x)$ 在模 $x^n$ 意义下的指数函数存在，当且仅当其常数项为 $0$，否则它对应的泰勒级数也一样不收敛。由于 $\exp f(x)$ 的导数里还是存在 $\exp f(x)$，我们只能用分治 FFT 的方法 $O\left(n\log^2n\right)$ 求出。这种方法由于比较缓慢而不常使用，通常我们使用 &lt;a href="https://blog.fei.ac/zh/posts/newtons-method/">Newton&amp;rsquo;s Method&lt;/a> $O(n\log n)$ 求。&lt;/p>
&lt;p>分治法并非一无是处。这个方法不需要写多项式求逆和多项式对数函数，写起来要快很多；虽然复杂度多一个对数，但常数较小，也不会慢特别多。&lt;/p>
&lt;p>多项式的指数函数是有实际的组合意义的。设 $f(x)$ 是一个大小为 $i$ 的盒子内部分配方案数的指数型生成函数（即，$\left[\dfrac{x^i}{i!}\right] f(x)$ 表示一个盒子装 $i$ 个小球的方案数），则 $\exp f(x)$ 表示 $i$ 个有标号小球分配到任意多个无标号盒子的方案数的指数型生成函数（即，$\left[\dfrac{x^i}{i!}\right] (\exp f(x))$ 表示 $i$ 个相互区分的小球放到若干个完全一样的盒子的方案数）。这个组合意义与指数函数的幂级数有关系。&lt;/p>
&lt;p>这一点的证明只需用下式说明&lt;/p>
&lt;p>$$
\exp f(x)=\sum\dfrac{f^i(x)}{i!}=\prod \exp f_ix^i
$$&lt;/p>
&lt;p>其中的含义是：&lt;/p>
&lt;p>$f^i(x)$ 是将有标号小球分配到 $i$ 个有标号盒子的方案数的指数型生成函数；&lt;/p>
&lt;p>$\dfrac{f^i(x)}{i!}$ 是将有标号小球分配到 $i$ 个无标号盒子的方案数的指数型生成函数；&lt;/p>
&lt;p>$\sum\dfrac{f^i(x)}{i!}$ 是将有标号小球分配到任意多个无标号盒子的方案数的指数型生成函数；&lt;/p>
&lt;p>$\prod \exp f_ix^i$ 也有含义。&lt;/p>
&lt;h2 id="欧拉变换">欧拉变换&lt;/h2>
&lt;p>在多项式指数函数中，我们提到了多项式指数函数的组合含义。如果要求无标号小球放到无标号盒子的方案数，我们应该怎么做呢？&lt;/p>
&lt;p>令 $f(x)=\sum\limits_{i=1}^nf_ix^i$，则我们可以写出所求的普通型生成函数 $g(f(x))$&lt;/p>
&lt;p>$$
g(f(x))=\prod\limits_{i=1}^n\dfrac{1}{(1-x^i)^{f_i}}
$$&lt;/p>
&lt;blockquote>
&lt;p>在指数函数的组合意义中，我们使用了指数型生成函数（EGF），而在欧拉变换中，我们使用的却是普通型生成函数（OGF）。&lt;/p>
&lt;/blockquote>
&lt;p>出现了 $1-x^k$，对此敏感的我们考虑求出它的对数函数&lt;/p>
&lt;p>$$
\ln g(f(x))=\sum\limits_{i=1}^nf_i\sum\limits_{j=1}^{+\infty}\dfrac{x^{ij}}{j}
$$&lt;/p>
&lt;p>交换求和顺序&lt;/p>
&lt;p>$$
\begin{aligned}\ln g(f(x))&amp;amp;=\sum\limits_{i=1}^{+\infty}\dfrac{1}{i}\sum\limits_{j=1}^{n}f_jx^{ij}\&amp;amp;=\sum\limits_{i=1}^{+\infty}\dfrac{f(x^i)}{i}\end{aligned}
$$&lt;/p>
&lt;p>于是&lt;/p>
&lt;p>$$
g(f(x))=\exp \sum\limits_{i=1}^{+\infty}\dfrac{f(x^i)}{i}
$$&lt;/p>
&lt;p>我们把 $g(f(x))$ 称作 $f(x)$ 的欧拉变换，它的组合含义是无标号小球放到无标号盒子的方案数。我们可以用 $O(n\log n)$ 的复杂度求一个多项式 $f(x)$ 的欧拉变换。&lt;/p>
&lt;p>&lt;a href="https://www.luogu.com.cn/problem/P4389">付公主的背包&lt;/a>可以用欧拉变换解释。完全背包的本质就是把 $s$ 个无标号体积放到 $n$ 种有标号商品中。&lt;/p></description></item><item><title>WC2021 爆零记</title><link>https://blog.fei.ac/zh/posts/wc2021/</link><pubDate>Wed, 10 Feb 2021 10:56:38 +0800</pubDate><guid>https://blog.fei.ac/zh/posts/wc2021/</guid><description>&lt;p>先花 $20 \text{min}$ 把所有题看了一遍，但是什么想法都没有。&lt;/p>
&lt;p>$30 \text{min}$ 时开始硬刚 T1，想到 $1\text{h}$ 时想出了一个结论，然后打了一个假做法。稍微改进了一下，得到了一个（应该）没什么问题的 $O(n^2\log n)$ 假做法，过掉 $n=3000$ 的样例。&lt;/p>
&lt;p>此时已是 $10:30$ 左右。由于不确定 T1 的做法是否是对的，反复校验了一会才开始做 T2。&lt;/p>
&lt;p>发现 T2 $O(nm|E|)$ 做法很显然，由于头晕脑胀，花了一个半小时左右打了出来。发现 $n=5000$ 的样例要跑接近 $3s$，由于头晕脑胀没有发现 $n=5000$ 的部分分没有问号可以直接 $O(nm)$，于是花了一会卡常，发现卡不进 $2.5s$，作罢。只能选择相信 8700k 比 $2.2\text{Ghz}$ 的老爷机的三倍还快。&lt;/p>
&lt;p>此时只剩 $1\text{h}$ 了。猜斐波那契模 $m$ 有循环节，为了保险计算 $10m$ 项。&lt;/p>
&lt;p>预计 $(0\sim 64)+(55\sim 70)+20=75\sim 154$。这个危险的分数可能会直接把我送退役。&lt;/p>
&lt;p>出成绩后发现 T1 有 $80$ 分，很不错。T2 只有 $55$，本来认为这是很合理的事，但在 LOJ，洛谷和本地都可以卡进 $70$ 分，于是申诉。T3 如预期，$20$ 分。&lt;/p>
&lt;p>分没要到。最终还是离金牌差 $3$ 分，痛苦地拿了银牌。&lt;/p></description></item><item><title>斯特林数与上升幂、下降幂</title><link>https://blog.fei.ac/zh/posts/stirling/</link><pubDate>Thu, 28 Jan 2021 14:29:04 +0800</pubDate><guid>https://blog.fei.ac/zh/posts/stirling/</guid><description>&lt;blockquote>
&lt;p>&lt;strong>本文内容已被整合至 OI Wiki，请至 &lt;a href="https://oi-wiki.org/math/combinatorics/stirling/">OI Wiki&lt;/a> 查看最新内容。&lt;/strong>&lt;/p>
&lt;/blockquote>
&lt;p>斯特林数与二项式系数密切相关，是离散数学的重要内容。&lt;/p>
&lt;p>斯特林数分为两类，分别是“第二类斯特林数”和“第一类斯特林数”。虽然被称作“第二类”，第二类斯特林数却比第一类的更常用，也在斯特林的相关著作和具体数学中被首先描述；因此，在这篇文章中我们也先介绍第二类斯特林数。&lt;/p>
&lt;h2 id="第二类斯特林数">第二类斯特林数&lt;/h2>
&lt;p>第二类斯特林数又称作斯特林子集数，用 $\begin{Bmatrix}n\m\end{Bmatrix}$ 表示，读作“$n$ 子集 $m$”。它的组合含义是，将 $n$ 个有标号物品划分为 $m$ 个无标号集合的方案数。学习&lt;a href="https://blog.fei.ac/2021/polylog">多项式对数函数、指数函数和欧拉变换&lt;/a>应该有助于能找到第二类斯特林数和指数函数的相关性（斯特林数限定了划分子集的个数而指数函数没有）。&lt;/p>
&lt;p>可以认为，对于 $n \less m$，有 $\begin{Bmatrix}n\m\end{Bmatrix}=0$。$m=0$ 的情况比较特殊。一般认为，将空集划分为 $0$ 个非空集合是可行的，因此我们定义 $\begin{Bmatrix}0\0\end{Bmatrix}=1$；而对于任意 $n \greater 0$，都有 $\begin{Bmatrix}n\0\end{Bmatrix}=0$。&lt;/p>
&lt;p>和二项式系数类似，第二类斯特林数也有递推公式&lt;/p>
&lt;p>$$
\begin{Bmatrix}n\m\end{Bmatrix}=m\begin{Bmatrix}n-1\m\end{Bmatrix}+\begin{Bmatrix}n-1\m-1\end{Bmatrix},n&amp;gt;0
$$&lt;/p>
&lt;p>同时，第二类斯特林数也有简洁的通项公式，即&lt;/p>
&lt;p>$$
\begin{Bmatrix}n\m\end{Bmatrix}=\sum\limits_{i=0}^m\dfrac{(-1)^{m-i}i^n}{i!(m-i)!}
$$&lt;/p>
&lt;p>考虑使用容斥原理证明。设 $G_i$ 表示 $n$ 个有标号元素，放置到 $i$ 个有标号集合的方案数；$F_i$ 表示 $n$ 个有标号元素，放置到 $i$ 个有标号非空集合的方案数。不难得到&lt;/p>
&lt;p>$$
G_i=i^n=\sum\limits_{j=0}^i\binom{i}{j}F_j
$$&lt;/p>
&lt;p>根据二项式反演&lt;/p>
&lt;p>$$
F_i=\sum\limits_{j=0}^{i}(-1)^{i-j}\binom{i}{j}j^n
$$&lt;/p>
&lt;p>考虑第二类斯特林数与 $F_i$ 的关系&lt;/p>
&lt;p>$$
\begin{Bmatrix}n\i\end{Bmatrix}=\dfrac{F_i}{i!}
$$&lt;/p>
&lt;p>联立得证。&lt;/p>
&lt;h2 id="同一行第二类斯特林数的计算">同一行第二类斯特林数的计算&lt;/h2>
&lt;p>“同一行”的第二类斯特林数指的是，有着不同的 $i$，相同的 $n$ 的一系列 $\begin{Bmatrix}n\i\end{Bmatrix}$。求出同一行的所有第二类斯特林数，就是对 $i=0..n$ 求出了将 $n$ 个不同元素划分为 $i$ 个非空集的方案数。&lt;/p>
&lt;p>根据上面给出的通项公式，卷积计算即可。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>(){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> scanf(&lt;span style="color:#e6db74">&amp;#34;%d&amp;#34;&lt;/span>, &lt;span style="color:#f92672">&amp;amp;&lt;/span>n);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fact[&lt;span style="color:#ae81ff">0&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;=&lt;/span> n; &lt;span style="color:#f92672">++&lt;/span>i) fact[i] &lt;span style="color:#f92672">=&lt;/span> (ll)fact[i &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>] &lt;span style="color:#f92672">*&lt;/span> i &lt;span style="color:#f92672">%&lt;/span> mod;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> exgcd(fact[n], mod, ifact[n], ifact[&lt;span style="color:#ae81ff">0&lt;/span>]), ifact[n] &lt;span style="color:#f92672">=&lt;/span> (ifact[n] &lt;span style="color:#f92672">%&lt;/span> mod &lt;span style="color:#f92672">+&lt;/span> mod) &lt;span style="color:#f92672">%&lt;/span> mod;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> n &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; i &lt;span style="color:#f92672">&amp;gt;=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; &lt;span style="color:#f92672">--&lt;/span>i) ifact[i] &lt;span style="color:#f92672">=&lt;/span> (ll)ifact[i &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>] &lt;span style="color:#f92672">*&lt;/span> (i &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>) &lt;span style="color:#f92672">%&lt;/span> mod;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fstdlib&lt;span style="color:#f92672">::&lt;/span>poly f(n &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>), g(n &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;=&lt;/span> n; &lt;span style="color:#f92672">++&lt;/span>i) g[i] &lt;span style="color:#f92672">=&lt;/span> (i &lt;span style="color:#f92672">&amp;amp;&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#f92672">?&lt;/span> mod &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">1ll&lt;/span> &lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#ae81ff">1ll&lt;/span>) &lt;span style="color:#f92672">*&lt;/span> ifact[i] &lt;span style="color:#f92672">%&lt;/span> mod, f[i] &lt;span style="color:#f92672">=&lt;/span> (ll)qpow(i, n) &lt;span style="color:#f92672">*&lt;/span> ifact[i] &lt;span style="color:#f92672">%&lt;/span> mod;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> f &lt;span style="color:#f92672">*=&lt;/span> g, f.resize(n &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;=&lt;/span> n; &lt;span style="color:#f92672">++&lt;/span>i) printf(&lt;span style="color:#e6db74">&amp;#34;%d &amp;#34;&lt;/span>, f[i]);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="同一列第二类斯特林数的计算">同一列第二类斯特林数的计算&lt;/h2>
&lt;p>即对 $i=0..n$，求出 $\begin{Bmatrix}i\k\end{Bmatrix}$。有两种常用的快速计算方法。&lt;/p>
&lt;h3 id="方法-1-利用递推公式">方法 1. 利用递推公式&lt;/h3>
&lt;p>第二类斯特林数的通项公式不适合计算列，我们考虑利用递推公式写出它的生成函数。设 $F_k(x)=\sum\limits_{i=0}^n\begin{Bmatrix}i\k\end{Bmatrix}x^i$，则&lt;/p>
&lt;p>$$
F_k(x)=kxF_k(x)+xF_{k-1}(x)
$$&lt;/p>
&lt;p>综合第二类斯特林数的定义解得&lt;/p>
&lt;p>$$
F_k(x)=\begin{cases}\dfrac{x}{1-kx}F_{k-1}(x)&amp;amp;\text{if }k&amp;gt;0\1&amp;amp;\text{else}\end{cases}
$$&lt;/p>
&lt;p>即 $F_k(x)=\prod\limits_{i=1}^k\dfrac{x}{1-ix}$&lt;/p>
&lt;p>利用多项式分治乘和多项式乘法逆即可在 $O(k\log k\log n)$ 的时间内解出 $F_k(x)$。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>(){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> scanf(&lt;span style="color:#e6db74">&amp;#34;%d%d&amp;#34;&lt;/span>, &lt;span style="color:#f92672">&amp;amp;&lt;/span>n, &lt;span style="color:#f92672">&amp;amp;&lt;/span>k);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;=&lt;/span> k; &lt;span style="color:#f92672">++&lt;/span>i) mask.emplace_back(std&lt;span style="color:#f92672">::&lt;/span>vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>{&lt;span style="color:#ae81ff">1&lt;/span>, mod &lt;span style="color:#f92672">-&lt;/span> i});
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span>((&lt;span style="color:#66d9ef">int&lt;/span>)mask.size() &lt;span style="color:#f92672">&amp;gt;=&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span>((&lt;span style="color:#66d9ef">int&lt;/span>)mask.size() &lt;span style="color:#f92672">&amp;gt;=&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> tmp.push_back(mask[mask.size() &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>] &lt;span style="color:#f92672">*&lt;/span> mask[mask.size() &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>]);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> mask.pop_back(), mask.pop_back();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span>(&lt;span style="color:#f92672">!&lt;/span>mask.empty()) tmp.push_back(mask[&lt;span style="color:#ae81ff">0&lt;/span>]), mask.pop_back();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>swap(mask, tmp);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fstdlib&lt;span style="color:#f92672">::&lt;/span>poly f(mask[&lt;span style="color:#ae81ff">0&lt;/span>].inv(n &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> f.size() &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; i &lt;span style="color:#f92672">&amp;gt;=&lt;/span> k; &lt;span style="color:#f92672">--&lt;/span>i) f[i] &lt;span style="color:#f92672">=&lt;/span> f[i &lt;span style="color:#f92672">-&lt;/span> k];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>min(k, (&lt;span style="color:#66d9ef">int&lt;/span>)f.size()) &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; i &lt;span style="color:#f92672">&amp;gt;=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; &lt;span style="color:#f92672">--&lt;/span>i) f[i] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span>)f.size(); &lt;span style="color:#f92672">++&lt;/span>i) printf(&lt;span style="color:#e6db74">&amp;#34;%d &amp;#34;&lt;/span>, f[i]);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="方法-2-利用指数型生成函数">方法 2. 利用指数型生成函数&lt;/h3>
&lt;p>一个盒子装 $i$ 个物品的方案是 $\begin{cases}1&amp;amp;\text{if }i&amp;gt;0\0&amp;amp;\text{else}\end{cases}$。我们可以写出它的指数型生成函数为 $F(x)=\sum\limits_{i=1}^{+\infty}\dfrac{x^i}{i!}$。经过之前的学习，我们明白 $F^k(x)$ 就是 $i$ 个有标号物品放到 $k$ 个有标号盒子里的指数型生成函数，$\exp F(x)=\sum\limits_{i=0}^{+\infty}\dfrac{F^i(x)}{i!}$ 就是 $i$ 个有标号物品放到任意多个无标号盒子里的指数型生成函数（指数函数通过每项除以一个 $i!$ 去掉了盒子的标号）。这里涉及到很多“有标号”“无标号”的内容，注意辨析。&lt;/p>
&lt;p>那么 $\begin{Bmatrix}i\k\end{Bmatrix}=\dfrac{\left[\dfrac{x^i}{i!}\right]F^k(x)}{k!}$，$O(n\log n)$ 计算多项式幂即可。实际使用时比 $O(n\log^2n)$ 的方法 1 要慢。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>(){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> scanf(&lt;span style="color:#e6db74">&amp;#34;%d%d&amp;#34;&lt;/span>, &lt;span style="color:#f92672">&amp;amp;&lt;/span>n, &lt;span style="color:#f92672">&amp;amp;&lt;/span>k);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fstdlib&lt;span style="color:#f92672">::&lt;/span>poly f(n &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fact[&lt;span style="color:#ae81ff">0&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;=&lt;/span> n; &lt;span style="color:#f92672">++&lt;/span>i) fact[i] &lt;span style="color:#f92672">=&lt;/span> (ll)fact[i &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>] &lt;span style="color:#f92672">*&lt;/span> i &lt;span style="color:#f92672">%&lt;/span> mod;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;=&lt;/span> n; &lt;span style="color:#f92672">++&lt;/span>i) f[i] &lt;span style="color:#f92672">=&lt;/span> qpow(fact[i], mod &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> f &lt;span style="color:#f92672">=&lt;/span> fstdlib&lt;span style="color:#f92672">::&lt;/span>exp(fstdlib&lt;span style="color:#f92672">::&lt;/span>log(f &lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>) &lt;span style="color:#f92672">*&lt;/span> k) &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> k, f.resize(n &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> inv &lt;span style="color:#f92672">=&lt;/span> qpow(fact[k], mod &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;=&lt;/span> n; &lt;span style="color:#f92672">++&lt;/span>i) printf(&lt;span style="color:#e6db74">&amp;#34;%lld &amp;#34;&lt;/span>, (ll)f[i] &lt;span style="color:#f92672">*&lt;/span> fact[i] &lt;span style="color:#f92672">%&lt;/span> mod &lt;span style="color:#f92672">*&lt;/span> inv &lt;span style="color:#f92672">%&lt;/span> mod);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="第一类斯特林数">第一类斯特林数&lt;/h2>
&lt;p>第一类斯特林数又称作斯特林轮换数，用 $\begin{bmatrix}n\m\end{bmatrix}$ 表示，读作“$n$ 轮换 $m$”。它的组合含义是，将 $n$ 个有标号物品分为 $m$ 个无标号轮换的方案数。&lt;/p>
&lt;p>一个轮换就是一个首尾相接的环形排列。我们可以写出一个轮换$[A,B,C,D]$，并且我们认为 $[A,B,C,D]=[B,C,D,A]=[C,D,A,B]=[D,A,B,C]$，即，两个可以通过旋转而互相得到的轮换是等价的。注意，我们不认为两个可以通过翻转而相互得到的轮换等价，即 $[A,B,C,D]\neq[D,C,B,A]$。&lt;/p>
&lt;p>不难发现，对于 $n&amp;gt;0$ 有 $\begin{bmatrix}n\1\end{bmatrix}=(n-1)!$；进一步，也有 $\begin{bmatrix}n\m\end{bmatrix}\geq \begin{Bmatrix}n\m\end{Bmatrix}$。&lt;/p>
&lt;p>轮换和排列一一对应，如果对同一行的所有第二类斯特林数求和，我们也能得到排列的总数 $\sum\limits_{i=0}^k\begin{bmatrix}n\i\end{bmatrix}=n!$。这一点可以参考 &lt;em>具体数学&lt;/em>。&lt;/p>
&lt;p>类似第二类斯特林数，我们也可以写出第一类斯特林数的递推公式&lt;/p>
&lt;p>$$
\begin{bmatrix}n\m\end{bmatrix}=(n-1)\begin{bmatrix}n-1\m\end{bmatrix}+\begin{bmatrix}n-1\m-1\end{bmatrix},n&amp;gt;0
$$&lt;/p>
&lt;h2 id="同一行第一类斯特林数的计算">同一行第一类斯特林数的计算&lt;/h2>
&lt;p>类似第二类斯特林数，我们构造同行第一类斯特林数的生成函数，即&lt;/p>
&lt;p>$$
F_n(x)=\sum\limits_{i=0}^n\begin{bmatrix}n\i\end{bmatrix}x^i
$$&lt;/p>
&lt;p>根据递推公式，不难写出&lt;/p>
&lt;p>$$
F_n(x)=(n-1)F_{n-1}(x)+xF_{n-1}(x)
$$&lt;/p>
&lt;p>于是&lt;/p>
&lt;p>$$
F_n(x)=\prod\limits_{i=0}^{n-1}(x+i)=\dfrac{(x+n-1)!}{(x-1)!}
$$&lt;/p>
&lt;p>这其实是 $x$ 的 $n$ 次上升阶乘幂，记做 $x^{\overline n}$。这个东西自然是可以暴力分治乘 $O(n\log^2n)$ 求出的，但用上升幂相关做法可以 $O(n\log n)$ 求出。具体见下面有关阶乘幂的部分。&lt;/p>
&lt;h2 id="同一列第一类斯特林数的计算">同一列第一类斯特林数的计算&lt;/h2>
&lt;p>仿照第二类斯特林数的计算，我们可以用指数型生成函数解决该问题。注意，由于递推公式和行有关，我们不能利用递推公式计算同列的第一类斯特林数。&lt;/p>
&lt;p>显然，单个轮换的指数型生成函数为&lt;/p>
&lt;p>$$
F(x)=\sum\limits_{i=1}^n\dfrac{(i-1)!x^i}{i!}=\sum\limits_{i=1}^n\dfrac{x^i}{i}
$$&lt;/p>
&lt;p>它的 $k$ 次幂就是 $\begin{bmatrix}i\k\end{bmatrix}$ 的指数型生成函数，$O(n\log n)$ 计算即可。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>(){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> scanf(&lt;span style="color:#e6db74">&amp;#34;%d%d&amp;#34;&lt;/span>, &lt;span style="color:#f92672">&amp;amp;&lt;/span>n, &lt;span style="color:#f92672">&amp;amp;&lt;/span>k);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fact[&lt;span style="color:#ae81ff">0&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;=&lt;/span> n; &lt;span style="color:#f92672">++&lt;/span>i) fact[i] &lt;span style="color:#f92672">=&lt;/span> (ll)fact[i &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>] &lt;span style="color:#f92672">*&lt;/span> i &lt;span style="color:#f92672">%&lt;/span> mod;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ifact[n] &lt;span style="color:#f92672">=&lt;/span> qpow(fact[n], mod &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> n &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; i &lt;span style="color:#f92672">&amp;gt;=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; &lt;span style="color:#f92672">--&lt;/span>i) ifact[i] &lt;span style="color:#f92672">=&lt;/span> (ll)ifact[i &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>] &lt;span style="color:#f92672">*&lt;/span> (i &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>) &lt;span style="color:#f92672">%&lt;/span> mod;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fstdlib&lt;span style="color:#f92672">::&lt;/span>poly f(n &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;=&lt;/span> n; &lt;span style="color:#f92672">++&lt;/span>i) f[i] &lt;span style="color:#f92672">=&lt;/span> (ll)fact[i &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>] &lt;span style="color:#f92672">*&lt;/span> ifact[i] &lt;span style="color:#f92672">%&lt;/span> mod;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> f &lt;span style="color:#f92672">=&lt;/span> fstdlib&lt;span style="color:#f92672">::&lt;/span>exp(fstdlib&lt;span style="color:#f92672">::&lt;/span>log(f &lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>) &lt;span style="color:#f92672">*&lt;/span> k) &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> k, f.resize(n &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;=&lt;/span> n; &lt;span style="color:#f92672">++&lt;/span>i) printf(&lt;span style="color:#e6db74">&amp;#34;%lld &amp;#34;&lt;/span>, (ll)f[i] &lt;span style="color:#f92672">*&lt;/span> fact[i] &lt;span style="color:#f92672">%&lt;/span> mod &lt;span style="color:#f92672">*&lt;/span> ifact[k] &lt;span style="color:#f92672">%&lt;/span> mod);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="上升阶乘幂和下降阶乘幂">上升阶乘幂和下降阶乘幂&lt;/h2>
&lt;p>之前我们提出了第一类斯特林数和上升阶乘幂的关系，即 $x$ 的 $n$ 次上升阶乘幂正是第 $n$ 行的第一类斯特林数的普通型生成函数。&lt;/p>
&lt;p>$$
F_n(x)=x^{\overline n}
$$&lt;/p>
&lt;p>接下来我们就介绍上升阶乘幂和与之类似的下降阶乘幂。&lt;/p>
&lt;p>一般的，我们分别用 $x^{\overline n}$ 和 $x^{\underline n}$ 来表示 $x$ 的 $n$ 次上升阶乘幂和下降阶乘幂。它们可以被这样描述&lt;/p>
&lt;p>$$
x^{\overline n}=\prod\limits_{i=0}^{n-1}(x+i)=\dfrac{(x+n-1)!}{(x-1)!},x^{\underline n}=\prod\limits_{i=0}^{n-1}(x-i)=\dfrac{x!}{(x-n)!}
$$&lt;/p>
&lt;p>直观上看，上升幂和下降幂是对称的。我们可以写出&lt;/p>
&lt;p>$$
\begin{aligned}(-x)^{\overline n}&amp;amp;=\prod\limits_{i=0}^{n-1}(-x+i)\&amp;amp;=(-1)^n\prod_{i=0}^{n-1}(x-i)\&amp;amp;=(-1)^nx^{\underline n}\end{aligned}
$$&lt;/p>
&lt;p>同理，$(-x)^{\underline n}=(-1)^nx^{\overline n}$ 也是成立的。&lt;/p>
&lt;p>我们还可以用下降阶乘幂表示二项式系数，这使得下降阶乘幂成为解决带组合数多项式的重要方法。&lt;/p>
&lt;p>$$
\binom{n}{m}=\dfrac{n!}{(n-m)!m!}=\dfrac{n^{\underline m}}{m!}
$$&lt;/p>
&lt;h2 id="阶乘幂和两类斯特林数的关系">阶乘幂和两类斯特林数的关系&lt;/h2>
&lt;h3 id="阶乘幂和第二类斯特林数的关系">阶乘幂和第二类斯特林数的关系&lt;/h3>
&lt;p>我们先研究阶乘幂与第二类斯特林数的关系。事实上它们之间有这样的关系&lt;/p>
&lt;p>$$
x^n=\sum\limits_{i=0}^n\begin{Bmatrix}n\i\end{Bmatrix}x^{\underline{i}},n\geq 0
$$&lt;/p>
&lt;p>我们用“生成函数”证明这一点。令&lt;/p>
&lt;p>$$
F_n(x)=\sum\limits_{i=0}^n\begin{Bmatrix}n\i\end{Bmatrix}x^{\underline i}
$$&lt;/p>
&lt;p>根据第二类斯特林数的递推公式 $\begin{Bmatrix}n\m\end{Bmatrix}=m\begin{Bmatrix}n-1\m\end{Bmatrix}+\begin{Bmatrix}n-1\m-1\end{Bmatrix}$ 可以写出&lt;/p>
&lt;p>$$
\begin{aligned}F_n(x)&amp;amp;=\sum\limits_{i=0}^{n-1}i\begin{Bmatrix}n-1\i\end{Bmatrix}x^{\underline i}+\sum\limits_{i=1}^{n}\begin{Bmatrix}n-1\i-1\end{Bmatrix}x^{\underline {i}}\&amp;amp;=\sum\limits_{i=0}^{n-1}i\begin{Bmatrix}n-1\i\end{Bmatrix}x^{\underline i}+\sum\limits_{i=0}^{n-1}\begin{Bmatrix}n-1\i\end{Bmatrix}x^{\underline {i+1}}\&amp;amp;=\sum\limits_{i=0}^{n-1}\begin{Bmatrix}n-1\i\end{Bmatrix}(i\cdot x^{\underline i}+x^{\underline {i+1}})\end{aligned}
$$&lt;/p>
&lt;p>由 $x^{\underline {i+1}}=(x-i)\cdot x^{\underline{i}}$ 知&lt;/p>
&lt;p>$$
\begin{aligned}i\cdot x^{\underline i}+x^{\underline {i+1}}&amp;amp;=i\cdot x^{\underline{i}}+(x-i)x^{\underline{i}}\&amp;amp;=x \cdot x^{\underline i}\end{aligned}
$$&lt;/p>
&lt;p>代入原式得&lt;/p>
&lt;p>$$
\begin{aligned}F_n(x)&amp;amp;=\sum\limits_{i=0}^{n-1}\begin{Bmatrix}n-1\i\end{Bmatrix}x\cdot x^{\underline i}\&amp;amp;=x\cdot\sum\limits_{i=0}^{n-1}\begin{Bmatrix}n-1\i\end{Bmatrix}x^{\underline i}\&amp;amp;=x\cdot F_{n-1}(x)\end{aligned}
$$&lt;/p>
&lt;p>由于 $F_0(x)=1$，因此 $F_n(x)=x^n$，得证。&lt;/p>
&lt;p>当然，也可以根据上升、下降阶乘幂的关系，将其中的下降阶乘幂替换为上升阶乘幂&lt;/p>
&lt;p>$$
(-x)^n=\sum\limits_{i=0}^n\begin{Bmatrix}n\i\end{Bmatrix}(-1)^{i}x^{\overline i}
$$&lt;/p>
&lt;p>也就是&lt;/p>
&lt;p>$$
x^n=\sum\limits_{i=0}^n\begin{Bmatrix}n\i\end{Bmatrix}(-1)^{n-i}x^{\overline i}
$$&lt;/p>
&lt;p>第二类斯特林数建立了一般多项式向阶乘幂多项式转化的通道。它是一般多项式转上升、下降阶乘幂多项式的有力工具。&lt;/p>
&lt;h3 id="阶乘幂和第一类斯特林数的关系">阶乘幂和第一类斯特林数的关系&lt;/h3>
&lt;p>通过之前构造的生成函数，我们已经知道&lt;/p>
&lt;p>$$
x^{\overline n}=\sum\limits_{i=0}^n\begin{bmatrix}n\i\end{bmatrix}x^i,n\ge 0
$$&lt;/p>
&lt;p>同样，也可以写成下降幂的形式&lt;/p>
&lt;p>$$
x^{\underline n}=\sum\limits_{i=0}^n\begin{bmatrix}n\i\end{bmatrix}(-1)^{n-i}x^i
$$&lt;/p>
&lt;p>第一类斯特林数和第二类斯特林数的作用正好相反，用于将上升、下降幂多项式转化为一般多项式。&lt;/p>
&lt;h2 id="下降阶乘幂在-oi-中的应用">下降阶乘幂在 OI 中的应用&lt;/h2>
&lt;p>上升阶乘幂在 OI 中的应用较少，在此不做介绍；我们只研究下降阶乘幂。&lt;/p>
&lt;h3 id="多项式下降阶乘幂表示与多项式点值表示的关系">多项式下降阶乘幂表示与多项式点值表示的关系&lt;/h3>
&lt;p>在这里，多项式的下降阶乘幂表示就是用&lt;/p>
&lt;p>$$
f(x)=\sum\limits_{i=0}^nb_i{x^\underline i}
$$&lt;/p>
&lt;p>的形式表示一个多项式，而点值表示就是用 $n+1$ 个点&lt;/p>
&lt;p>$$
(i,a_i),i=0..n
$$&lt;/p>
&lt;p>来表示一个多项式。&lt;/p>
&lt;p>显然，下降阶乘幂 $b$ 和点值 $a$ 间满足这样的关系：&lt;/p>
&lt;p>$$
a_k=\sum\limits_{i=0}^{n}b_ik^{\underline i}
$$&lt;/p>
&lt;p>即&lt;/p>
&lt;p>$$
\begin{aligned}a_k&amp;amp;=\sum\limits_{i=0}^{n}\dfrac{b_ik!}{(k-i)!}\\dfrac{a_k}{k!}&amp;amp;=\sum\limits_{i=0}^kb_i\dfrac{1}{(k-i)!}\end{aligned}
$$&lt;/p>
&lt;p>这显然是个卷积形式，我们可以在 $O(n\log n)$ 的时间复杂度内完成点值和下降阶乘幂的互相转化。&lt;/p></description></item><item><title>多项式中的 Newton's Method</title><link>https://blog.fei.ac/zh/posts/newtons-method/</link><pubDate>Thu, 14 Jan 2021 21:00:43 +0800</pubDate><guid>https://blog.fei.ac/zh/posts/newtons-method/</guid><description>&lt;p>Newton&amp;rsquo;s Method 是牛顿提出的一种将非线性方程线性化的近似方法。它也可以运用在多项式中，求关于多项式的非线性方程在模意义下的解。&lt;/p>
&lt;p>要学习 Newton&amp;rsquo;s Method，得先了解泰勒级数。&lt;/p>
&lt;h2 id="泰勒级数和麦克劳林级数">泰勒级数和麦克劳林级数&lt;/h2>
&lt;p>泰勒级数用无限项连加式来表示函数。一般地，对于一个光滑函数 $f(x)$，有&lt;/p>
&lt;p>$$
f(x)=\sum\limits_{n=0}^{+\infty}\dfrac{f ^ {(n)}(a)} {i!}(x-a)^n
$$&lt;/p>
&lt;p>这个等式被称为 $f(x)$ 在 $a$ 处的泰勒展开式；等号右边的式子被称为 $f(x)$ 在 $a$ 处的泰勒级数。在 $0$ 处的泰勒展开式和泰勒级数也被称为麦克劳林展开式和麦克劳林级数。下面给出了一些常用的麦克劳林级数，有的在生成函数中常用：&lt;/p>
&lt;p>$$
\begin{aligned}
(1-x)^{-1}&amp;amp;=\sum\limits_{n=0}^{+\infty}x^n\newline
(1-x)^{-m}&amp;amp;=\sum\limits_{n=0}^{+\infty}\binom{n+m-1}{n}x^n\newline
(1+x)^{m}&amp;amp;=\sum\limits_{n=0}^{+\infty}\binom{m}{n}x^n\newline
\ln(1-x)&amp;amp;=-\sum\limits_{n=1}^{+\infty}\dfrac{x^n}{n}\newline
\ln(1+x)&amp;amp;=-\sum\limits_{n=1}^{+\infty}\dfrac{(-1)^{n}x^n}{n}\newline
\exp x&amp;amp;=-\sum\limits_{n=0}^{+\infty}\dfrac{x^n}{n!}
\end{aligned}
$$&lt;/p>
&lt;blockquote>
&lt;p>泰勒展开式并非对于 $f(x)$ 定义域内所有 $x$ 都成立。比如，将 $x=10$ 代入 $(1-x)^{-1}=\sum\limits_{n=0}^{+\infty}x^n$，很容易发现这个式子根本不成立。事实上，$(1-x)^{-1}=\sum\limits_{n=0}^{+\infty}x^n$ 这个式子只对 $|x|&amp;lt;1$ 成立。&lt;/p>
&lt;p>其他函数的泰勒展开式有的也有类似的限制。但在 OI 中我们只关心展开式的系数，不关心 $x$ 的值，可以认为这些泰勒展开式在我们研究的范围内总是成立的。&lt;/p>
&lt;/blockquote>
&lt;p>了解了泰勒级数，我们可以开始学习 Newton&amp;rsquo;s Method 了：&lt;/p>
&lt;h2 id="一般的-newtons-method">一般的 Newton&amp;rsquo;s Method&lt;/h2>
&lt;p>Newton&amp;rsquo;s Method 一般被用于求解非线性方程。它是这样求 $f(x)=0$ 的根的：&lt;/p>
&lt;ul>
&lt;li>选取合适一个数作为 $x_0$&lt;/li>
&lt;li>将 $f(x)$ 在 $x_0$ 处展开，即 $f(x)=\sum\limits_{n=0}^{+\infty}\dfrac{f ^ {(n)}(x_0)} {n!}(x-x_0)^n$&lt;/li>
&lt;li>取其常数项和线性项，令其值为 $0$，即 $f(x_0)+f^\prime(x_0)\cdot(x-x_0)=0$&lt;/li>
&lt;li>解得这个近似方程的根 $x_1$，并在 $x_1$ 处将 $f(x)$ 泰勒展开，重复上述过程得到 $x_2,x_3,x_4,&amp;hellip;$ 可以证明，每一个新解都更加接近 $f(x)=0$ 的根&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">double&lt;/span> &lt;span style="color:#a6e22e">f&lt;/span>(&lt;span style="color:#66d9ef">double&lt;/span> x);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">double&lt;/span> &lt;span style="color:#a6e22e">fd&lt;/span>(&lt;span style="color:#66d9ef">double&lt;/span> x);&lt;span style="color:#75715e">//fd 是 f 的导数，即 f&amp;#39;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">double&lt;/span> &lt;span style="color:#a6e22e">newtonsMethod&lt;/span>(&lt;span style="color:#66d9ef">double&lt;/span> x0, &lt;span style="color:#66d9ef">int&lt;/span> d){ &lt;span style="color:#75715e">//d 代表迭代次数
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">//f(x_0)+fd(x0)*(x-x0)=0 -&amp;gt; x=-f(x0)/fd(x0)+x0
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">while&lt;/span>(d&lt;span style="color:#f92672">--&lt;/span>) x0 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">-&lt;/span>f(x0) &lt;span style="color:#f92672">/&lt;/span> fd(x0) &lt;span style="color:#f92672">+&lt;/span> x0;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> x0;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这样看来，我们只能无限逼近 $f(x)=0$ 的根，而无法绝对准确地取到根。我们求多项式，是否也无法得到精确的解呢？担心是多余的，我们本来就不需要求“绝对精确”的解，只需要求模意义下的“精确”的解。&lt;/p>
&lt;h2 id="newtons-method-在多项式中的-methodology">Newton&amp;rsquo;s Method 在多项式中的 Methodology&lt;/h2>
&lt;blockquote>
&lt;p>求一个关于 $x$ 的多项式 $f(x)$，使得对于一给定的关于 $f(x)$ 的函数 $g(f(x))$，$g(f(x))\equiv 0\pmod {x^n}$ 成立。&lt;/p>
&lt;/blockquote>
&lt;p>这是 Newton&amp;rsquo;s Method 求解的问题的通式。对于多项式 $h(x)$，求逆时 $g(f(x))=h(x)-f^{-1}(x)$，开根时 $g(f(x))=h(x)-f^{2}(x)$，求指数时 $g(f(x))=h(x)-\ln f(x)$。下面就讲述 Newton&amp;rsquo;s Method 是如何逼近根的：&lt;/p>
&lt;p>选择一个满足 $g(f(x))\equiv0\pmod{x^1}$ 的多项式作为初始根。&lt;/p>
&lt;p>设我们已经求出了模 $x^{\lceil\frac{n}{2}\rceil}$ 下的根 $f_0(x)$，将 $g(f(x))$ 在 $f_0(x)$ 处泰勒展开：&lt;/p>
&lt;p>$$
g(f(x))\equiv\sum\limits_{i=0}^{+\infty}\dfrac{g ^ {(i)}(f_0(x))} {i!}(f(x)-f_0(x))^i\equiv 0\pmod{x^n}
$$&lt;/p>
&lt;p>将 $f(x)=f_0(x)+x^{\lceil\frac{n}{2}\rceil}\cdot h(x)$ 代入&lt;/p>
&lt;p>$$
\sum\limits_{i=0}^{+\infty}\dfrac{g ^ {(i)}(f_0(x))} {i!}(f_0(x)+x^{\lceil\frac{n}{2}\rceil}\cdot h(x)-f_0(x))^i\equiv 0\pmod{x^{n}}
$$&lt;/p>
&lt;p>即&lt;/p>
&lt;p>$$
\sum\limits_{i=0}^{+\infty}\dfrac{g ^ {(i)}(f_0(x))} {i!}\cdot x^{i\cdot\lceil\frac{n}{2}\rceil}\cdot h^i(x)\equiv 0\pmod{x^{n}}
$$&lt;/p>
&lt;p>其中，对于 $x^{i\cdot\lceil\frac{n}{2}\rceil}\cdot h^i(x)$ 这一部分，显然当 $i\ge 2$ 时有 $x^{i\cdot\lceil\frac{n}{2}\rceil}\cdot h^i(x)\equiv 0\pmod{x^n}$。则在此处模 $x^n$ 意义下的泰勒级数，从第三项开始全部为 $0$，于是只需保留前两项：&lt;/p>
&lt;p>$$
g(f_0(x))+g^\prime(f_0(x))\cdot (x^{\lceil\frac{n}{2}\rceil}\cdot h(x))\equiv 0\pmod{x^n}
$$&lt;/p>
&lt;p>解得&lt;/p>
&lt;p>$$
h(x)\equiv -x^{-\lceil\frac{n}{2}\rceil}\dfrac{g(f_0(x))}{g^\prime(f_0(x))}\pmod{x^n}
$$&lt;/p>
&lt;p>在 $h(x)$ 存在的情况下回代得 $f(x)\equiv f_0(x)-\dfrac{g(f_0(x))}{g^\prime(f_0(x))}\pmod{x^n}$，完成了一次迭代。如果迭代 $a$ 次，我们就可以得到在模 $x^{2^a}$ 意义下的解了。&lt;/p>
&lt;p>有一个问题尚未解决：$h(x)$ 是否总是存在？我们发现，$-x^{-\lceil\frac{n}{2}\rceil}\dfrac{g(f_0(x))}{g^\prime(f_0(x))}$ 在模 $x^n$ 意义下存在，当且仅当它只包含 $x$ 的自然数幂次项，而 $g(f_0(x))\equiv 0\pmod{x^{\lceil\frac{n}{2}\rceil}}$，于是在模 $x^n$ 意义下的 $\dfrac{g(f_0(x))}{g^\prime(f_0(x))}$ 总是存在，且其前 $\lceil\frac{n}{2}\rceil$ 总是为零。于是 $-x^{-\lceil\frac{n}{2}\rceil}\dfrac{g(f_0(x))}{g^\prime(f_0(x))}$ 总是一个只包含 $x$ 的自然数幂的式子，$h(x)$ 总是存在。&lt;/p>
&lt;p>由上述过程可知，Newton&amp;rsquo;s Method 可应用于解 $g(f(x))=0$ 模 $x^n$ 意义下的根，当且仅当 $g(f(x))$ 无限可微。$g(f(x))\equiv0\pmod{x^n}$ 的根存在，当且仅当这个同余方程在模 $x^1$ 意义下的根 $f_0$ 存在，并且每个 $f_0$ 都对应着唯一的一个模 $x^n$ 的根。除此之外，对于第 $a$ 次和第 $a+1$ 次迭代的根 $f_{a}(x),f_{a+1}(x)$，有 $f_a(x)\equiv f_{a+1}(x)\pmod{x^{2^a}}$。&lt;/p>
&lt;p>下面将就几个具体的 $g(f(x))$ 讲解 Newton&amp;rsquo;s Method 的应用。&lt;/p>
&lt;h2 id="newtons-method-求多项式的逆">Newton&amp;rsquo;s Method 求多项式的逆&lt;/h2>
&lt;p>对于原多项式 $h(x)$，它在模 $x^n$ 意义下的逆 $f(x)$ 满足 $h(x)\cdot g(x)\equiv0\pmod{x^n}$。则 $g(f(x))$ 可以写作 $g(f(x))=h(x)-\dfrac{1}{f(x)}$。代入 Newton&amp;rsquo;s Method 得&lt;/p>
&lt;p>$$
f(x)\equiv f_0(x)-\dfrac{h(x)-\dfrac{1}{f_0(x)}}{f_0^{-2}(x)}\pmod{x^n}
$$&lt;/p>
&lt;p>注意这里 $g(f(x))$ 不是关于 $x$ 的复合函数，而是一个关于 $f(x)$ 的函数。它的导数要视作 $\dfrac{\mathrm{d}g(f(x))}{\mathrm{d}f(x)}$。&lt;/p>
&lt;p>即&lt;/p>
&lt;p>$$
f(x)\equiv f_0(x)\cdot\left(2-f_0(x)\cdot h(x)\right)\pmod{x^n}
$$&lt;/p>
&lt;p>运用 FNTT，单次迭代复杂度为 $O(n\log n)$。运用主定理可得总时间复杂度为 $T(n)=T\left(\dfrac{n}{2}\right)+O(n\log n)=O(n\log n)$。我们一般用倍增法实现代码。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">polyinv&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#f92672">*&lt;/span>f, &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#f92672">*&lt;/span>h, &lt;span style="color:#66d9ef">int&lt;/span> n){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> N &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; &lt;span style="color:#66d9ef">while&lt;/span>(N &lt;span style="color:#f92672">&amp;lt;&lt;/span> n &lt;span style="color:#f92672">+&lt;/span> n &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>) N &lt;span style="color:#f92672">&amp;lt;&amp;lt;=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> d[maxn], g[maxn];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> memcpy(d, h, n &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#66d9ef">sizeof&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span>)), memset(d &lt;span style="color:#f92672">+&lt;/span> n, &lt;span style="color:#ae81ff">0&lt;/span>, (N &lt;span style="color:#f92672">-&lt;/span> n) &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#66d9ef">sizeof&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span>));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> memset(f, &lt;span style="color:#ae81ff">0&lt;/span>, N &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#66d9ef">sizeof&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span>)), memset(g, &lt;span style="color:#ae81ff">0&lt;/span>, N &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#66d9ef">sizeof&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span>)), f[&lt;span style="color:#ae81ff">0&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> qpow(h[&lt;span style="color:#ae81ff">0&lt;/span>], mod &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> w &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>; w &lt;span style="color:#f92672">/&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span> n; w &lt;span style="color:#f92672">&amp;lt;&amp;lt;=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> memcpy(g, d, w &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#66d9ef">sizeof&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span>));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> w &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>; &lt;span style="color:#f92672">++&lt;/span>i) rev[i] &lt;span style="color:#f92672">=&lt;/span> (rev[i &lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>] &lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>) &lt;span style="color:#f92672">|&lt;/span> (i &lt;span style="color:#f92672">&amp;amp;&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#f92672">?&lt;/span> w : &lt;span style="color:#ae81ff">0&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dft(f, w &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">1&lt;/span>), dft(g, w &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">1&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> w &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>; &lt;span style="color:#f92672">++&lt;/span>i) f[i] &lt;span style="color:#f92672">=&lt;/span> (ll)f[i] &lt;span style="color:#f92672">*&lt;/span> (&lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#f92672">-&lt;/span> (ll)f[i] &lt;span style="color:#f92672">*&lt;/span> g[i] &lt;span style="color:#f92672">%&lt;/span> mod) &lt;span style="color:#f92672">%&lt;/span> mod;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dft(f, w &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>, inv &lt;span style="color:#f92672">=&lt;/span> qpow(w &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>, mod &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>); i &lt;span style="color:#f92672">&amp;lt;&lt;/span> w; &lt;span style="color:#f92672">++&lt;/span>i) f[i] &lt;span style="color:#f92672">=&lt;/span> (ll)f[i] &lt;span style="color:#f92672">*&lt;/span> inv &lt;span style="color:#f92672">%&lt;/span> mod;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> memset(f &lt;span style="color:#f92672">+&lt;/span> w, &lt;span style="color:#ae81ff">0&lt;/span>, w &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#66d9ef">sizeof&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span>));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> memset(f &lt;span style="color:#f92672">+&lt;/span> n, &lt;span style="color:#ae81ff">0&lt;/span>, (N &lt;span style="color:#f92672">-&lt;/span> n) &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#66d9ef">sizeof&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span>));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="newtons-method-求多项式平方根">Newton&amp;rsquo;s Method 求多项式平方根&lt;/h2>
&lt;p>对于多项式 $h(x)$，它的平方根 $f(x)$ 满足 $f^2(x)\equiv h(x)\pmod{x^n}$，我们可以写出 $g(f(x))\equiv h(x)-f^2(x)\pmod{x^n}$。代入 Newton&amp;rsquo;s Method 得&lt;/p>
&lt;p>$$
\begin{aligned}
f(x)&amp;amp;\equiv f_0(x)-\dfrac{h(x)-f_0^2(x)}{-2f_0(x)}\newline
&amp;amp;\equiv f_0(x)+\dfrac{1}{2}\left(h(x)\cdot f_0^{-1}(x)-f_0(x)\right)\newline
&amp;amp;\equiv \dfrac{1}{2}\left(f_0(x)+f_0^{-1}(x)\cdot h(x)\right)
\end{aligned}\pmod{x^n}
$$&lt;/p>
&lt;p>单次迭代仍为 $O(n\log n)$，故总复杂度也为 $O(n\log n)$。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">polysqrt&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#f92672">*&lt;/span>f, &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#f92672">*&lt;/span>h, &lt;span style="color:#66d9ef">int&lt;/span> n){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> N &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; &lt;span style="color:#66d9ef">while&lt;/span>(N &lt;span style="color:#f92672">&amp;lt;&lt;/span> n &lt;span style="color:#f92672">+&lt;/span> n &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>) N &lt;span style="color:#f92672">&amp;lt;&amp;lt;=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> d[maxn], g[maxn], f_inv[maxn];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> memcpy(d, h, n &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#66d9ef">sizeof&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span>)), memset(d &lt;span style="color:#f92672">+&lt;/span> n, &lt;span style="color:#ae81ff">0&lt;/span>, (N &lt;span style="color:#f92672">-&lt;/span> n) &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#66d9ef">sizeof&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span>));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> memset(f, &lt;span style="color:#ae81ff">0&lt;/span>, N &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#66d9ef">sizeof&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span>)), memset(g, &lt;span style="color:#ae81ff">0&lt;/span>, N &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#66d9ef">sizeof&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span>)), f[&lt;span style="color:#ae81ff">0&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> w &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>; w &lt;span style="color:#f92672">/&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span> n; w &lt;span style="color:#f92672">&amp;lt;&amp;lt;=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> memcpy(g, d, w &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#66d9ef">sizeof&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span>)), polyinv(f_inv, f, w);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> w &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>; &lt;span style="color:#f92672">++&lt;/span>i) rev[i] &lt;span style="color:#f92672">=&lt;/span> (rev[i &lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>] &lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>) &lt;span style="color:#f92672">|&lt;/span> (i &lt;span style="color:#f92672">&amp;amp;&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#f92672">?&lt;/span> w : &lt;span style="color:#ae81ff">0&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dft(g, w &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">1&lt;/span>), dft(f, w &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">1&lt;/span>), dft(f_inv, w &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">1&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> w &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>; &lt;span style="color:#f92672">++&lt;/span>i) f[i] &lt;span style="color:#f92672">=&lt;/span> (f[i] &lt;span style="color:#f92672">+&lt;/span> (ll)f_inv[i] &lt;span style="color:#f92672">*&lt;/span> g[i] &lt;span style="color:#f92672">%&lt;/span> mod) &lt;span style="color:#f92672">%&lt;/span> mod;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dft(f, w &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>, inv &lt;span style="color:#f92672">=&lt;/span> qpow(w &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>, mod &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>); i &lt;span style="color:#f92672">&amp;lt;&lt;/span> w; &lt;span style="color:#f92672">++&lt;/span>i) f[i] &lt;span style="color:#f92672">=&lt;/span> (ll)f[i] &lt;span style="color:#f92672">*&lt;/span> inv &lt;span style="color:#f92672">%&lt;/span> mod;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> memset(f &lt;span style="color:#f92672">+&lt;/span> w, &lt;span style="color:#ae81ff">0&lt;/span>, w &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#66d9ef">sizeof&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span>));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> memset(f &lt;span style="color:#f92672">+&lt;/span> n, &lt;span style="color:#ae81ff">0&lt;/span>, (N &lt;span style="color:#f92672">-&lt;/span> n) &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#66d9ef">sizeof&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span>));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="newtons-method-求多项式指数函数">Newton&amp;rsquo;s Method 求多项式指数函数&lt;/h2>
&lt;p>多项式的对数函数和指数函数都是用麦克劳林级数定义的。要用 Newton&amp;rsquo;s Method 求多项式指数函数，得先会求&lt;a href="https://blog.fei.ac/zh/posts/polylog">多项式对数函数&lt;/a>。&lt;/p>
&lt;p>对于多项式 $h(x)$，它的指数函数 $f(x)\equiv\exp h(x)\pmod{x^n}$ 满足 $h(x)\equiv\ln f(x)\pmod{x^n}$，我们可以写出 $g(f(x))=h(x)-\ln f(x)$。代入 Newton&amp;rsquo;s Method 得&lt;/p>
&lt;p>$$
\begin{aligned}
f(x)&amp;amp;\equiv f_0(x)-\dfrac{h(x)-\ln f_0(x)}{-\dfrac{1}{f_0(x)}}\newline
&amp;amp;\equiv f_0(x)+f_0(x)\cdot\left(h(x)-\ln f_0(x)\right)\newline
&amp;amp;\equiv f_0(x)\cdot(1+h(x)-\ln f_0(x))
\end{aligned}\pmod{x^n}
$$&lt;/p>
&lt;p>单次迭代仍为 $O(n\log n)$，故总复杂度也为 $O(n\log n)$。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">polyexp&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#f92672">*&lt;/span>f, &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#f92672">*&lt;/span>h, &lt;span style="color:#66d9ef">int&lt;/span> n){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> N &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; &lt;span style="color:#66d9ef">while&lt;/span>(N &lt;span style="color:#f92672">&amp;lt;&lt;/span> n &lt;span style="color:#f92672">+&lt;/span> n &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>) N &lt;span style="color:#f92672">&amp;lt;&amp;lt;=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> d[maxn], g[maxn], lg[maxn]; memset(lg, &lt;span style="color:#ae81ff">0&lt;/span>, N &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#66d9ef">sizeof&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span>));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> memcpy(d, h, n &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#66d9ef">sizeof&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span>)), memset(d &lt;span style="color:#f92672">+&lt;/span> n, &lt;span style="color:#ae81ff">0&lt;/span>, (N &lt;span style="color:#f92672">-&lt;/span> n) &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#66d9ef">sizeof&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span>));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> memset(g, &lt;span style="color:#ae81ff">0&lt;/span>, N &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#66d9ef">sizeof&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span>)), memset(f, &lt;span style="color:#ae81ff">0&lt;/span>, N &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#66d9ef">sizeof&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span>)), f[&lt;span style="color:#ae81ff">0&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> w &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>; w &lt;span style="color:#f92672">/&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span> n; w &lt;span style="color:#f92672">&amp;lt;&amp;lt;=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> memcpy(g, d, w &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#66d9ef">sizeof&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span>)), polylog(lg, f, w);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> w &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>; &lt;span style="color:#f92672">++&lt;/span>i) rev[i] &lt;span style="color:#f92672">=&lt;/span> (rev[i &lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>] &lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>) &lt;span style="color:#f92672">|&lt;/span> (i &lt;span style="color:#f92672">&amp;amp;&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#f92672">?&lt;/span> w : &lt;span style="color:#ae81ff">0&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dft(g, w &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">1&lt;/span>), dft(f, w &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">1&lt;/span>), dft(lg, w &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">1&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> w &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>; &lt;span style="color:#f92672">++&lt;/span>i) f[i] &lt;span style="color:#f92672">=&lt;/span> (ll)f[i] &lt;span style="color:#f92672">*&lt;/span> (&lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#f92672">+&lt;/span> g[i] &lt;span style="color:#f92672">-&lt;/span> lg[i]) &lt;span style="color:#f92672">%&lt;/span> mod;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dft(f, w &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>, inv &lt;span style="color:#f92672">=&lt;/span> qpow(w &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>, mod &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>); i &lt;span style="color:#f92672">&amp;lt;&lt;/span> w; &lt;span style="color:#f92672">++&lt;/span>i) f[i] &lt;span style="color:#f92672">=&lt;/span> (ll)f[i] &lt;span style="color:#f92672">*&lt;/span> inv &lt;span style="color:#f92672">%&lt;/span> mod;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> memset(f &lt;span style="color:#f92672">+&lt;/span> w, &lt;span style="color:#ae81ff">0&lt;/span>, w &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#66d9ef">sizeof&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span>));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> memset(f &lt;span style="color:#f92672">+&lt;/span> n, &lt;span style="color:#ae81ff">0&lt;/span>, (N &lt;span style="color:#f92672">-&lt;/span> n) &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#66d9ef">sizeof&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span>));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>一个有趣的事实是，要写多项式指数函数就必须先写一个多项式对数函数；要写多项式对数函数就必须先写一个多项式求逆&amp;hellip;&amp;hellip;这些东西加起来有七八十行，还是不太好写的。&lt;/p></description></item><item><title>多项式的逆</title><link>https://blog.fei.ac/zh/posts/polyinv/</link><pubDate>Wed, 13 Jan 2021 22:13:23 +0800</pubDate><guid>https://blog.fei.ac/zh/posts/polyinv/</guid><description>&lt;p>数学中很多元素在一定条件下都存在逆元。多项式的逆元是什么呢？&lt;/p>
&lt;p>从乘法逆元出发，一个简单的想法是，多项式 $g(x)$ 是 $f(x)$ 的逆元当且仅当 $f(x)\cdot g(x)=1$。遗憾的是，当且仅当 $f(x)$ 只含常数项时才存在满足条件的多项式 $g(x)$，否则 $g(x)$ 必须为无穷的幂级数。因此，我们在模的意义下考虑多项式的逆，得到多项式逆元的定义：&lt;/p>
&lt;blockquote>
&lt;p>$f(x)$ 的逆元 $g(x)$ 是一个满足 $f(x)\cdot g(x)\equiv 1\pmod{x^n}$ 的多项式。&lt;/p>
&lt;/blockquote>
&lt;p>分别用 $f_{0..n-1}$ 和 $g_{0..n-1}$ 来表示 $f(x)$ 和 $g(x)$ 的系数，把 $f(x)\cdot g(x)$ 写下来：&lt;/p>
&lt;p>$$
f(x)\cdot g(x)\equiv \sum\limits_{i=0}^{n-1}\sum\limits_{j=0}^{i}f_{j}g_{i-j}\cdot x^{i}
$$&lt;/p>
&lt;p>要满足上面的定义，$f(x)\cdot g(x)$ 就是 $x^0$ 项为 $1$，其余项为 $0$ 的多项式，即&lt;/p>
&lt;p>$$
f_0g_0=1
$$&lt;/p>
&lt;p>和&lt;/p>
&lt;p>$$
\forall i\ge 1: \sum\limits_{j=0}^{i}f_{j}g_{i-j}=0
$$&lt;/p>
&lt;p>这两个条件都成立，$g(x)$ 才是 $f(x)$ 的逆元。由第一个条件可知，若 $f(x)$ 的常数项为 $0$，则 $g(x)$ 一定不存在（$0$ 不存在逆元）。若 $f(x)$ 的常数项不为零，是否就一定存在满足第二个条件的 $g(x)$ 呢？&lt;/p>
&lt;p>考虑把上面的式子视作一个 $n$ 元一次方程组，$f_{0..n-1}$ 是已知系数，$g_{0..n-1}$ 是未知数。由于我们有 $n$ 个关于 $n$ 个未知数的次数上升的方程，$g_{0..n-1}$ 一定有唯一解。&lt;/p>
&lt;p>$$
\begin{cases}f_0g_0&amp;amp;=1\newline f_0g_1+f_1g_0&amp;amp;=0\newline f_0g_2+f_1g_1+f_2g_0&amp;amp;=0\newline f_0g_3+f_1g_2+f_2g_1+f_3g_0&amp;amp;=0\newline \ldots\newline f_0g_{n-1}+f_1g_{n-2}+f_2g_{n-3}+\ldots+f_{n-1}g_0&amp;amp;=0\end{cases}
$$&lt;/p>
&lt;p>也就是说， &lt;strong>$f(x)$ 在模 $x^n$ 意义下存在逆元，当且仅当 $f(x)$ 的常数项非零；在 $f(x)$ 逆元存在的情况下，$f(x)$ 的逆元唯一&lt;/strong>。&lt;/p>
&lt;p>根据上述方程组求逆的时间复杂度是 $O(n^2)$，更快的 $O(n\log n)$ 算法请参考 &lt;a href="https://blog.fei.ac/zh/posts/newtons-method">Newton&amp;rsquo;s Method&lt;/a>。&lt;/p></description></item><item><title>NOIP2020 爆炸记</title><link>https://blog.fei.ac/zh/posts/noip2020/</link><pubDate>Sat, 05 Dec 2020 22:39:17 +0800</pubDate><guid>https://blog.fei.ac/zh/posts/noip2020/</guid><description>&lt;p>开考看 T1，发现是一道水题，半小时左右切掉。&lt;/p>
&lt;p>再看 T2，稍加思考，写了哈希+调和级数。然而用了神奇的树状数组，复杂度炸成 $O(n\log n\log 26)$，大概只有 $80$ 分。此时才 $9:36$。&lt;/p>
&lt;p>开 T3。花 $1$ h 打了一个假做法，又花不到 1h 打了一个 $O(nm^2)$ 算法，又花不到 $30$ min 稍稍优化。期望 $40$ 分。&lt;/p>
&lt;p>T4 感觉正解不太难，但是想不出具体怎么做。于是用剩下不到 1h 的时间打了 $40$ 分暴力。&lt;/p>
&lt;p>最后得分 $60+84+40+35=219$，勉强混了个省一。&lt;/p></description></item><item><title>CSP2020 爆零记</title><link>https://blog.fei.ac/zh/posts/csp2020/</link><pubDate>Sun, 08 Nov 2020 10:56:26 +0800</pubDate><guid>https://blog.fei.ac/zh/posts/csp2020/</guid><description>&lt;p>进了考场，考前 $3$ min 才让动键盘，结果发现自己的键盘的空格键有些问题，要用特别大的力按到正中央才能按动。&lt;/p>
&lt;p>先遍历一下所有题。T1 是一道无脑模拟，但感觉处理起来比较麻烦，可能要花半小时以上；T2 一眼没看出做法，但好像不太难；T3 不会；T4 不会。&lt;/p>
&lt;p>于是硬刚 T1。直到我开写才发现这题是多么恶心，于是大约 $17:30$ 左右才过掉大样例。&lt;/p>
&lt;p>然后开 T2，发现就是道水题，$10$ min 切掉。&lt;/p>
&lt;p>去写 T3，想了 $30$ min 想出了 $O(n^2)$ 后缀积，又码了 $30$ min，一次过掉所有样例（大样例太水）。几乎在码完的一刻，又想出了优化做法 $O(n)$ 正解，于是我试图在当前代码的基础上改出正解。由于头脑混乱（T1 = $120$ min, T2 = $10$ min)，写了 $50$ min 都没调过，只能作罢。&lt;/p>
&lt;p>T4 没动。&lt;/p>
&lt;p>跟同学讨论，才发现 T2 保证 $q$ 互不相同，完全没必要开 &lt;code>std::map&lt;/code>，可以 $O(n)$ 过，不过相信就算是 map 也能在 8700k 上过 $10^6$。回来测才发现 map 的 log 是过不了 $10^6$ 的，T2 可能只有 $60$ 分；T1 挂成 $40$ 分，T3 在不同平台分别水到 $60 \sim 80$ 不等的成绩。Clouder 表示 T4 是水题，我却碰都没碰。&lt;/p>
&lt;p>人已经没了，希望 CSP 和 NOIP 无关。&lt;/p>
&lt;p>最终因为 CCF 数据水，拿了 $220$。而强大的 &lt;a href="https://www.codein.icu">Clouder&lt;/a> 暴砍 $325$ 分 orz&lt;/p></description></item><item><title>任意模数多项式乘法</title><link>https://blog.fei.ac/zh/posts/arbitrary-modulo/</link><pubDate>Thu, 24 Sep 2020 11:19:29 +0800</pubDate><guid>https://blog.fei.ac/zh/posts/arbitrary-modulo/</guid><description>&lt;p>由于 NTT 的数学原理，它只能用于计算模特定模数意义下的多项式乘法。如何计算任意模数的多项式乘法呢？&lt;/p>
&lt;p>一种简单的想法是利用中国剩余定理。一般我们计算两个长度在 $10^5$ 级别、系数在 $10^9$ 级别的多项式的卷积，其结果的系数不会超过 $10^{23}$ 级别。只要选取三个乘积超过 $10^{23}$ 的 NTT 模数，分别乘一次，再用中国剩余定理合并答案即可。这种方法常数极大。&lt;/p>
&lt;p>而我们要介绍的做法是拆系数 FFT。合理的拆系数 FFT 实现消耗的时间仅仅是普通多项式乘法的四倍左右，是一种很优秀的任意模数多项式乘法计算方法。&lt;/p>
&lt;h2 id="拆系数-fft">拆系数 FFT&lt;/h2>
&lt;p>假定我们卷积的模数为 $p$，选取一个 $\sqrt{p}$ 级别的数 $d$。在 OI 中，$p$ 一般至多为 $2^{30}$ 级别的数。&lt;/p>
&lt;p>把多项式 $F$ 每一项的系数 $F_i$ 分解为 $F_i=d\cdot G_i+H_i$，得到 $F=d\cdot G+H$。由于 $d$ 是 $\sqrt{p}$ 级别的，我们可以保证 $G$ 和 $H$ 的系数也是 $\sqrt{p}$ 级别的，相乘不会超过 &lt;code>double&lt;/code> 的精度。&lt;/p>
&lt;p>于是&lt;/p>
&lt;p>$$
\begin{aligned}F\cdot G&amp;amp;=\left(d\cdot A+B\right)\cdot\left(d\cdot C+D\right)\newline &amp;amp;=d^2\cdot AC+d\cdot(AD+BC)+BD\end{aligned}
$$&lt;/p>
&lt;p>使用“三次变两次”的思想优化，可以在七次 DFT 变换内得到结果 $F\cdot G$。这就是拆系数 FFT 了。&lt;/p>
&lt;h2 id="优化">优化&lt;/h2>
&lt;p>根据国家集训队论文《再谈快速傅里叶变换》，存在一种四次 DFT 计算任意模数卷积的算法。&lt;/p>
&lt;p>设 $F=G+i\cdot H$，对于 FFT 选取的每一个点 $\left(\omega_n^k,F\left(\omega_n^k\right)\right)$，都有&lt;/p>
&lt;p>$$
\begin{aligned}F\left(\omega_n^k\right)&amp;amp;= G\left(\omega_n^k\right)+i\cdot H\left(\omega_n^k\right)\newline
&amp;amp;=\sum\limits_{j=0}^{n-1}\left(G_j\cdot\omega_n^{jk}+i\cdot H_j\cdot\omega_n^{jk}\right)\newline
&amp;amp;=\sum\limits_{j=0}^{n-1}\omega_{n}^{jk}\cdot\left(G_j+i\cdot H_j\right)\newline
&amp;amp;=\sum\limits_{j=0}^{n-1}\left(\cos\dfrac{kj\cdot 2\pi}{n}+i\cdot\sin\dfrac{kj\cdot 2\pi}{n}\right)\cdot\left(G_j+i\cdot H_j\right)\end{aligned}
$$&lt;/p>
&lt;p>再设 $\overline{F}=G-i\cdot H$，我们有&lt;/p>
&lt;p>$$
\begin{aligned}\overline{F}\left(\omega_n^k\right)&amp;amp;=\sum\limits_{j=0}^{n-1}\left(\cos\dfrac{kj\cdot 2\pi}{n}+i\cdot\sin\dfrac{kj\cdot 2\pi}{n}\right)\cdot\left(G_j-i\cdot H_j\right)\newline
&amp;amp;=\sum\limits_{j=0}^{n-1}\left(\left(G_j\cdot\cos\dfrac{kj\cdot 2\pi}{n}+H_j\cdot\sin\dfrac{kj\cdot 2\pi}{n}\right)+i\cdot\left(G_j\cdot\sin\dfrac{kj\cdot 2\pi}{n}-H_j\cdot\cos\dfrac{kj\cdot 2\pi}{n}\right)\right)\newline
&amp;amp;=\sum\limits_{j=0}^{n-1}\left(\left(G_j\cdot\cos\left(-\dfrac{kj\cdot 2\pi}{n}\right)-H_j\cdot\sin\left(-\dfrac{kj\cdot 2\pi}{n}\right)\right)-i\cdot\left(G_j\cdot\sin\left(-\dfrac{kj\cdot 2\pi}{n}\right)+H_j\cdot\cos\left(-\dfrac{kj\cdot 2\pi}{n}\right)\right)\right)\newline
&amp;amp;=\sum\limits_{j=0}^{n-1}\left(\left(G_j\cdot\cos\dfrac{(nj-kj)\cdot 2\pi}{n}-H_j\cdot\sin\dfrac{(nj-kj)\cdot 2\pi}{n}\right)-i\cdot\left(G_j\cdot\sin\dfrac{(nj-kj)\cdot 2\pi}{n}+H_j\cdot\cos\dfrac{(nj-kj)\cdot 2\pi}{n}\right)\right)\newline
&amp;amp;=\overline{\sum\limits_{j=0}^{n-1}\left(\left(G_j\cdot\cos\dfrac{(nj-kj)\cdot 2\pi}{n}-H_j\cdot\sin\dfrac{(nj-kj)\cdot 2\pi}{n}\right)+i\cdot\left(G_j\cdot\sin\dfrac{(nj-kj)\cdot 2\pi}{n}+H_j\cdot\cos\dfrac{(nj-kj)\cdot 2\pi}{n}\right)\right)}\newline
&amp;amp;=\overline{\sum\limits_{j=0}^{n-1}\left(\cos\dfrac{(nj-kj)\cdot 2\pi}{n}+i\cdot\sin\dfrac{(nj-kj)\cdot 2\pi}{n}\right)\cdot\left(G_j+i\cdot H_j\right)}\&amp;amp;=\overline{G\left(\omega_n^{n-k}\right)+i\cdot H\left(\omega_n^{n-k}\right)}\newline
&amp;amp;=\overline{F\left(\omega_n^{n-k}\right)}\end{aligned}
$$&lt;/p>
&lt;p>因此，只要求出 $F$ 的点值，就可 $O(n)$ 地推出 $\overline{F}$ 的点值，解出 $G,H$ 的点值。即&lt;/p>
&lt;p>$$
\begin{aligned}
\text{DFT}(G)&amp;amp;=\dfrac{\text{DFT}(F)+\text{DFT}(\overline{F})}{2}\newline
\text{DFT}(H)&amp;amp;=\dfrac{\text{DFT}(F)-\text{DFT}(\overline{F})}{2i}
\end{aligned}
$$&lt;/p>
&lt;p>这样，一共只需要两次 DFT 就可以得到四个多项式的点值。&lt;/p>
&lt;p>还原系数表达（IDFT）时，也可以用“三次变两次”的思想，将两个多项式分虚实放在一起 IDFT，做到两次 IDFT 还原。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;cstdio&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;cmath&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;vector&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;complex&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#define double long double
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">double&lt;/span> PI &lt;span style="color:#f92672">=&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>acos(&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">namespace&lt;/span> __fft{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">typedef&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>complex&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">double&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> comp;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>comp&lt;span style="color:#f92672">&amp;gt;&lt;/span> tmp;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> rev;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">init&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> n){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> tmp.resize(n), rev.resize(n);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> n; &lt;span style="color:#f92672">++&lt;/span>i){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> rev[i] &lt;span style="color:#f92672">=&lt;/span> rev[i &lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>] &lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span>(i &lt;span style="color:#f92672">&amp;amp;&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>) rev[i] &lt;span style="color:#f92672">|=&lt;/span> n &lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">fft&lt;/span>(std&lt;span style="color:#f92672">::&lt;/span>vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>comp&lt;span style="color:#f92672">&amp;gt;::&lt;/span>iterator f, &lt;span style="color:#66d9ef">int&lt;/span> n, &lt;span style="color:#66d9ef">int&lt;/span> b){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> n; &lt;span style="color:#f92672">++&lt;/span>i)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span>(i &lt;span style="color:#f92672">&amp;lt;&lt;/span> rev[i]) std&lt;span style="color:#f92672">::&lt;/span>swap(f[i], f[rev[i]]);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;=&lt;/span> n; i &lt;span style="color:#f92672">&amp;lt;&amp;lt;=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> comp w(std&lt;span style="color:#f92672">::&lt;/span>cos(&lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#f92672">*&lt;/span> PI &lt;span style="color:#f92672">/&lt;/span> i), b &lt;span style="color:#f92672">*&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>sin(&lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#f92672">*&lt;/span> PI &lt;span style="color:#f92672">/&lt;/span> i));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> j &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; j &lt;span style="color:#f92672">&amp;lt;&lt;/span> n; j &lt;span style="color:#f92672">+=&lt;/span> i){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> comp wn(&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>comp&lt;span style="color:#f92672">&amp;gt;::&lt;/span>iterator g &lt;span style="color:#f92672">=&lt;/span> f &lt;span style="color:#f92672">+&lt;/span> j, h &lt;span style="color:#f92672">=&lt;/span> f &lt;span style="color:#f92672">+&lt;/span> j &lt;span style="color:#f92672">+&lt;/span> i &lt;span style="color:#f92672">/&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> k &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; k &lt;span style="color:#f92672">&amp;lt;&lt;/span> i &lt;span style="color:#f92672">/&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>; &lt;span style="color:#f92672">++&lt;/span>k){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> tmp[k] &lt;span style="color:#f92672">=&lt;/span> g[k] &lt;span style="color:#f92672">+&lt;/span> h[k] &lt;span style="color:#f92672">*&lt;/span> wn;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> tmp[k &lt;span style="color:#f92672">+&lt;/span> i &lt;span style="color:#f92672">/&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> g[k] &lt;span style="color:#f92672">-&lt;/span> h[k] &lt;span style="color:#f92672">*&lt;/span> wn;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> wn &lt;span style="color:#f92672">=&lt;/span> wn &lt;span style="color:#f92672">*&lt;/span> w;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> k &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; k &lt;span style="color:#f92672">&amp;lt;&lt;/span> i; &lt;span style="color:#f92672">++&lt;/span>k) f[j &lt;span style="color:#f92672">+&lt;/span> k] &lt;span style="color:#f92672">=&lt;/span> tmp[k];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> n, m, p;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>std&lt;span style="color:#f92672">::&lt;/span>vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> F, G;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>std&lt;span style="color:#f92672">::&lt;/span>vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> mtt(std&lt;span style="color:#f92672">::&lt;/span>vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> F, std&lt;span style="color:#f92672">::&lt;/span>vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> G, &lt;span style="color:#66d9ef">int&lt;/span> len){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">typedef&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> ll;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">using&lt;/span> __fft&lt;span style="color:#f92672">::&lt;/span>comp;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> __fft&lt;span style="color:#f92672">::&lt;/span>init(len);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> d &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">15&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>comp&lt;span style="color:#f92672">&amp;gt;&lt;/span> A(len), B(len);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>comp&lt;span style="color:#f92672">&amp;gt;&lt;/span> C(len), D(len);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> len; &lt;span style="color:#f92672">++&lt;/span>i)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> A[i] &lt;span style="color:#f92672">=&lt;/span> comp(F[i] &lt;span style="color:#f92672">/&lt;/span> d, &lt;span style="color:#ae81ff">0&lt;/span>), B[i] &lt;span style="color:#f92672">=&lt;/span> comp(F[i] &lt;span style="color:#f92672">%&lt;/span> d, &lt;span style="color:#ae81ff">0&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> len; &lt;span style="color:#f92672">++&lt;/span>i)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> C[i] &lt;span style="color:#f92672">=&lt;/span> comp(G[i] &lt;span style="color:#f92672">/&lt;/span> d, &lt;span style="color:#ae81ff">0&lt;/span>), D[i] &lt;span style="color:#f92672">=&lt;/span> comp(G[i] &lt;span style="color:#f92672">%&lt;/span> d, &lt;span style="color:#ae81ff">0&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>comp&lt;span style="color:#f92672">&amp;gt;&lt;/span> H(len), I(len);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> len; &lt;span style="color:#f92672">++&lt;/span>i)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> H[i] &lt;span style="color:#f92672">=&lt;/span> comp(A[i].real(), B[i].real());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> __fft&lt;span style="color:#f92672">::&lt;/span>fft(H.begin(), len, &lt;span style="color:#ae81ff">1&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> len; &lt;span style="color:#f92672">++&lt;/span>i)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> I[i] &lt;span style="color:#f92672">=&lt;/span> conj(H[(len &lt;span style="color:#f92672">-&lt;/span> i) &lt;span style="color:#f92672">%&lt;/span> len]);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> len; &lt;span style="color:#f92672">++&lt;/span>i){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> A[i] &lt;span style="color:#f92672">=&lt;/span> (H[i] &lt;span style="color:#f92672">+&lt;/span> I[i]) &lt;span style="color:#f92672">*&lt;/span> comp(&lt;span style="color:#ae81ff">0.5&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> B[i] &lt;span style="color:#f92672">=&lt;/span> (H[i] &lt;span style="color:#f92672">-&lt;/span> I[i]) &lt;span style="color:#f92672">*&lt;/span> comp(&lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">0.5&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> len; &lt;span style="color:#f92672">++&lt;/span>i)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> H[i] &lt;span style="color:#f92672">=&lt;/span> comp(C[i].real(), D[i].real());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> __fft&lt;span style="color:#f92672">::&lt;/span>fft(H.begin(), len, &lt;span style="color:#ae81ff">1&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> len; &lt;span style="color:#f92672">++&lt;/span>i)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> I[i] &lt;span style="color:#f92672">=&lt;/span> conj(H[(len &lt;span style="color:#f92672">-&lt;/span> i) &lt;span style="color:#f92672">%&lt;/span> len]);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> len; &lt;span style="color:#f92672">++&lt;/span>i){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> C[i] &lt;span style="color:#f92672">=&lt;/span> (H[i] &lt;span style="color:#f92672">+&lt;/span> I[i]) &lt;span style="color:#f92672">*&lt;/span> comp(&lt;span style="color:#ae81ff">0.5&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> D[i] &lt;span style="color:#f92672">=&lt;/span> (H[i] &lt;span style="color:#f92672">-&lt;/span> I[i]) &lt;span style="color:#f92672">*&lt;/span> comp(&lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">0.5&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>comp&lt;span style="color:#f92672">&amp;gt;&lt;/span> P(len), Q(len);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> len; &lt;span style="color:#f92672">++&lt;/span>i){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> P[i] &lt;span style="color:#f92672">=&lt;/span> A[i] &lt;span style="color:#f92672">*&lt;/span> C[i] &lt;span style="color:#f92672">+&lt;/span> comp(&lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#ae81ff">1&lt;/span>) &lt;span style="color:#f92672">*&lt;/span> (A[i] &lt;span style="color:#f92672">*&lt;/span> D[i] &lt;span style="color:#f92672">+&lt;/span> B[i] &lt;span style="color:#f92672">*&lt;/span> C[i]);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Q[i] &lt;span style="color:#f92672">=&lt;/span> B[i] &lt;span style="color:#f92672">*&lt;/span> D[i];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> __fft&lt;span style="color:#f92672">::&lt;/span>fft(P.begin(), len, &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>), __fft&lt;span style="color:#f92672">::&lt;/span>fft(Q.begin(), len, &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> len; &lt;span style="color:#f92672">++&lt;/span>i){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> F[i] &lt;span style="color:#f92672">=&lt;/span> (ll)(P[i].real() &lt;span style="color:#f92672">/&lt;/span> len &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">0.9&lt;/span>) &lt;span style="color:#f92672">*&lt;/span> d &lt;span style="color:#f92672">%&lt;/span> p &lt;span style="color:#f92672">*&lt;/span> d &lt;span style="color:#f92672">%&lt;/span> p;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> F[i] &lt;span style="color:#f92672">=&lt;/span> (F[i] &lt;span style="color:#f92672">+&lt;/span> (ll)(P[i].imag() &lt;span style="color:#f92672">/&lt;/span> len &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">0.9&lt;/span>) &lt;span style="color:#f92672">*&lt;/span> d) &lt;span style="color:#f92672">%&lt;/span> p;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> F[i] &lt;span style="color:#f92672">=&lt;/span> (F[i] &lt;span style="color:#f92672">+&lt;/span> (ll)(Q[i].real() &lt;span style="color:#f92672">/&lt;/span> len &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">0.9&lt;/span>)) &lt;span style="color:#f92672">%&lt;/span> p;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> F[i] &lt;span style="color:#f92672">=&lt;/span> (F[i] &lt;span style="color:#f92672">+&lt;/span> p) &lt;span style="color:#f92672">%&lt;/span> p;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> F;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>(){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>scanf(&lt;span style="color:#e6db74">&amp;#34;%d%d%d&amp;#34;&lt;/span>, &lt;span style="color:#f92672">&amp;amp;&lt;/span>n, &lt;span style="color:#f92672">&amp;amp;&lt;/span>m, &lt;span style="color:#f92672">&amp;amp;&lt;/span>p);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> F.resize(n &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>), G.resize(m &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;=&lt;/span> n; &lt;span style="color:#f92672">++&lt;/span>i) std&lt;span style="color:#f92672">::&lt;/span>scanf(&lt;span style="color:#e6db74">&amp;#34;%d&amp;#34;&lt;/span>, &lt;span style="color:#f92672">&amp;amp;&lt;/span>F[i]), F[i] &lt;span style="color:#f92672">%=&lt;/span> p;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;=&lt;/span> m; &lt;span style="color:#f92672">++&lt;/span>i) std&lt;span style="color:#f92672">::&lt;/span>scanf(&lt;span style="color:#e6db74">&amp;#34;%d&amp;#34;&lt;/span>, &lt;span style="color:#f92672">&amp;amp;&lt;/span>G[i]), G[i] &lt;span style="color:#f92672">%=&lt;/span> p;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> len &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;=&lt;/span> &lt;span style="color:#ae81ff">20&lt;/span>; &lt;span style="color:#f92672">++&lt;/span>i)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span>((&lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> i) &lt;span style="color:#f92672">&amp;gt;=&lt;/span> n &lt;span style="color:#f92672">+&lt;/span> m &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> len &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> i; &lt;span style="color:#66d9ef">break&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> F.resize(len), G.resize(len);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> ans(mtt(F, G, len));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;=&lt;/span> n &lt;span style="color:#f92672">+&lt;/span> m; &lt;span style="color:#f92672">++&lt;/span>i) std&lt;span style="color:#f92672">::&lt;/span>printf(&lt;span style="color:#e6db74">&amp;#34;%d &amp;#34;&lt;/span>, ans[i]);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>以上是我早年间的实现，效率极其低下（$10^5$ 卷积运算耗时 $1109$ ms）。更好的实现可以参考我的项目 &lt;a href="https://github.com/fei0319/poly.h">fstdlib&lt;/a>。&lt;/p>
&lt;p>拆系数 FFT 是无法通过 &lt;a href="https://judge.yosupo.jp/problem/convolution_mod_1000000007">Library Checker&lt;/a> 的，因为 Library Checker 的多项式长度达到了 $524288$，纵使是 &lt;code>long double&lt;/code> 也无法保证精度。正常情况下不会有题目考察规模如此之大的任意模数卷积。&lt;/p></description></item><item><title>多项式时间复杂度计算行列式</title><link>https://blog.fei.ac/zh/posts/det/</link><pubDate>Tue, 12 May 2020 16:18:59 +0800</pubDate><guid>https://blog.fei.ac/zh/posts/det/</guid><description>&lt;p>矩阵的行列式在诸多领域有着广泛的应用。其最广为人知的应用便是在 Matrix-Tree 定理中求基尔霍夫矩阵的代数余子式。&lt;/p>
&lt;p>根据行列式的定义，求其值的时间复杂度可达 $O(n\cdot n!)$。下面介绍一个能以多项式时间复杂度计算行列式的算法。&lt;/p>
&lt;h2 id="一些约定">一些约定&lt;/h2>
&lt;ul>
&lt;li>用 $A_{i, j}$ 表示一个矩阵 $A$ 第 $i$ 行第 $j$ 列的值；&lt;/li>
&lt;li>用 $|A|$ 表示关于 $n$ 阶方阵 $A$ 的行列式；&lt;/li>
&lt;/ul>
&lt;h2 id="行列式的一般定义">行列式的一般定义&lt;/h2>
&lt;p>$n$ 阶行列式是关于一个 $n$ 阶方阵的函数，写作 $|A|$ 或 $\text{det}(A)$。&lt;/p>
&lt;p>设 $P$ 为 $1$ ~ $n$ 的一个排列，$\alpha(P)$ 为排列 $P$ 中的逆序对个数，有&lt;/p>
&lt;p>$$
|A| = \sum\limits_{P \text{ 是 } 1 \text{ 至 } n \text{ 的一个排列 }}(-1)^{\alpha(P)}\cdot\prod_{i=1}^nA_{i, P_i}
$$&lt;/p>
&lt;h2 id="矩阵变换与行列式值的改变">矩阵变换与行列式值的改变&lt;/h2>
&lt;p>由行列式的相关知识，我们必须要枚举所有的 $n!$ 种排列才能够得到行列式的值。为了改变我们的计算方法，就必须对矩阵进行一定的变换。下面是一些简单的引理：&lt;/p>
&lt;blockquote>
&lt;p>引理 1. 交换矩阵的两行，行列式值变为原来的相反数&lt;/p>
&lt;/blockquote>
&lt;p>定义 $\omega(A, P) = (-1)^{\alpha(P)}\cdot\prod_{i=1}^nA_{i, P_i}$，那么 $|A| = \sum\limits_{P \text{ 是 } 1 \text{ 至 } n \text{ 的一个排列}}\omega(A, P)$。&lt;/p>
&lt;p>交换矩阵的两行 $i, j$ 得到矩阵 $A&amp;rsquo;$。设同样交换 $P$ 的两个元素 $i, j$ 得到 $P&amp;rsquo;$，显然有 $\alpha(P&amp;rsquo;) = \alpha(P) \pm 1$，即 $(-1) ^ {\alpha(P`)} = -(-1) ^ {\alpha(P)}$。&lt;/p>
&lt;p>根据我们对 $A&amp;rsquo;$ 和 $P&amp;rsquo;$ 的定义，显然有 $\omega(A, P) = \omega(A&amp;rsquo;, P&amp;rsquo;)$。&lt;/p>
&lt;p>那么&lt;/p>
&lt;p>$$
\begin{aligned}|A&amp;rsquo;| &amp;amp;= -\sum\limits_{P \text{ 是 } 1 \text{ 至 } n \text{ 的一个排列}}\omega(A&amp;rsquo;, P&amp;rsquo;)\ &amp;amp;= -\sum\limits_{P \text{ 是 } 1 \text{ 至 } n \text{ 的一个排列}}\omega(A, P)\ &amp;amp;= -|A|\end{aligned}
$$&lt;/p>
&lt;blockquote>
&lt;p>引理 2. 有两行完全相同的矩阵，其行列式为 $0$&amp;quot;&lt;/p>
&lt;/blockquote>
&lt;p>由&lt;strong>引理 1&lt;/strong>可知，交换该矩阵的任意两行，其行列式变为相反数。若交换该矩阵相同的那两行，其矩阵不变，行列式变为相反数，即 $|A| = -|A|$。故 $|A| = 0$。&lt;/p>
&lt;blockquote>
&lt;p>引理 3. 将矩阵的某一行乘以一个实数 $k$，其行列式变为原来的 $k$ 倍&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>引理 4. 若两矩阵除了一行之外完全相同，将两矩阵相加并减去相同部分得到矩阵的行列式为该两矩阵行列式之和&lt;/p>
&lt;/blockquote>
&lt;p>即&lt;/p>
&lt;p>$$
\left|\begin{array}{ccc} A_{1,1} &amp;amp; \dots &amp;amp; A_{1,n-1} &amp;amp; A_{1,n}\newline
\cdots &amp;amp; \cdots &amp;amp; \cdots &amp;amp; \cdots\newline
X_{1}+Y_{1} &amp;amp; \dots &amp;amp; X_{n-1}+Y_{n-1} &amp;amp; X_{n}+Y_{n}\newline
\cdots &amp;amp; \cdots &amp;amp; \cdots &amp;amp; \cdots\newline
A_{n,1} &amp;amp; \cdots &amp;amp; A_{n,n-1} &amp;amp; A_{n,n}\end{array}\right|=
\left|\begin{array}{ccc} A_{1,1} &amp;amp; \dots &amp;amp; A_{1,n-1} &amp;amp; A_{1,n}\newline
\cdots &amp;amp; \cdots &amp;amp; \cdots &amp;amp; \cdots\newline
X_{1} &amp;amp; \dots &amp;amp; X_{n-1} &amp;amp; X_{n}\newline
\cdots &amp;amp; \cdots &amp;amp; \cdots &amp;amp; \cdots\newline
A_{n,1} &amp;amp; \cdots &amp;amp; A_{n,n-1} &amp;amp; A_{n,n}\end{array}\right|+\left|\begin{array}{ccc} A_{1,1} &amp;amp; \dots &amp;amp; A_{1,n-1} &amp;amp; A_{1,n}\newline
\cdots &amp;amp; \cdots &amp;amp; \cdots &amp;amp; \cdots\newline
Y_{1} &amp;amp; \dots &amp;amp; Y_{n-1} &amp;amp; Y_{n}\newline
\cdots &amp;amp; \cdots &amp;amp; \cdots &amp;amp; \cdots\newline
A_{n,1} &amp;amp; \cdots &amp;amp; A_{n,n-1} &amp;amp; A_{n,n}\end{array}\right|
$$&lt;/p>
&lt;blockquote>
&lt;p>引理 5. 矩阵的某一行加上另一行的倍数，其行列式不变&lt;/p>
&lt;/blockquote>
&lt;p>即&lt;/p>
&lt;p>$$
\left|\begin{array}{ccc} A_{1,1} &amp;amp; \dots &amp;amp; A_{1,n-1} &amp;amp; A_{1,n}\newline
\cdots &amp;amp; \cdots &amp;amp; \cdots &amp;amp; \cdots\newline
X_{1} &amp;amp; \dots &amp;amp; X_{n-1} &amp;amp; X_{n}\newline
Y_{1} &amp;amp; \dots &amp;amp; Y_{n-1} &amp;amp; Y_{n}\newline
\cdots &amp;amp; \cdots &amp;amp; \cdots &amp;amp; \cdots\newline
A_{n,1} &amp;amp; \cdots &amp;amp; A_{n,n-1} &amp;amp; A_{n,n}\end{array}\right|=\left|\begin{array}{ccc} A_{1,1} &amp;amp; \dots &amp;amp; A_{1,n-1} &amp;amp; A_{1,n}\newline
\cdots &amp;amp; \cdots &amp;amp; \cdots &amp;amp; \cdots\newline
X_{1}+k\cdot Y_{1} &amp;amp; \dots &amp;amp; X_{n-1}+k\cdot Y_{n-1} &amp;amp; X_{n}+k\cdot Y_{n}\newline
Y_{1} &amp;amp; \dots &amp;amp; Y_{n-1} &amp;amp; Y_{n}\newline
\cdots &amp;amp; \cdots &amp;amp; \cdots &amp;amp; \cdots\newline
A_{n,1} &amp;amp; \cdots &amp;amp; A_{n,n-1} &amp;amp; A_{n,n}\end{array}\right|
$$&lt;/p>
&lt;p>这个结论可以引用&lt;strong>引理 2, 3, 4&lt;/strong>证明：&lt;/p>
&lt;p>$$
\begin{aligned}&amp;amp;\left|\begin{array}{ccc} A_{1,1} &amp;amp; \dots &amp;amp; A_{1,n-1} &amp;amp; A_{1,n}\newline
\cdots &amp;amp; \cdots &amp;amp; \cdots &amp;amp; \cdots\newline
X_{1}+k\cdot Y_{1} &amp;amp; \dots &amp;amp; X_{n-1}+k\cdot Y_{n-1} &amp;amp; X_{n}+k\cdot Y_{n}\newline
Y_{1} &amp;amp; \dots &amp;amp; Y_{n-1} &amp;amp; Y_{n}\newline
\cdots &amp;amp; \cdots &amp;amp; \cdots &amp;amp; \cdots\newline
A_{n,1} &amp;amp; \cdots &amp;amp; A_{n,n-1} &amp;amp; A_{n,n}\end{array}\right|\newline
&amp;amp;=\left|\begin{array}{ccc} A_{1,1} &amp;amp; \dots &amp;amp; A_{1,n-1} &amp;amp; A_{1,n}\newline
\cdots &amp;amp; \cdots &amp;amp; \cdots &amp;amp; \cdots\newline
X_{1} &amp;amp; \dots &amp;amp; X_{n-1} &amp;amp; X_{n}\newline
Y_{1} &amp;amp; \dots &amp;amp; Y_{n-1} &amp;amp; Y_{n}\newline
\cdots &amp;amp; \cdots &amp;amp; \cdots &amp;amp; \cdots\newline
A_{n,1} &amp;amp; \cdots &amp;amp; A_{n,n-1} &amp;amp; A_{n,n}\end{array}\right|+\left|\begin{array}{ccc} A_{1,1} &amp;amp; \dots &amp;amp; A_{1,n-1} &amp;amp; A_{1,n}\newline
\cdots &amp;amp; \cdots &amp;amp; \cdots &amp;amp; \cdots\newline
k\cdot Y_{1} &amp;amp; \dots &amp;amp; k\cdot Y_{n-1} &amp;amp; k\cdot Y_{n}\newline
Y_{1} &amp;amp; \dots &amp;amp; Y_{n-1} &amp;amp; Y_{n}\newline
\cdots &amp;amp; \cdots &amp;amp; \cdots &amp;amp; \cdots\newline
A_{n,1} &amp;amp; \cdots &amp;amp; A_{n,n-1} &amp;amp; A_{n,n}\end{array}\right|\newline
&amp;amp;=\left|\begin{array}{ccc} A_{1,1} &amp;amp; \dots &amp;amp; A_{1,n-1} &amp;amp; A_{1,n}\newline
\cdots &amp;amp; \cdots &amp;amp; \cdots &amp;amp; \cdots\newline
X_{1} &amp;amp; \dots &amp;amp; X_{n-1} &amp;amp; X_{n}\newline
Y_{1} &amp;amp; \dots &amp;amp; Y_{n-1} &amp;amp; Y_{n}\newline
\cdots &amp;amp; \cdots &amp;amp; \cdots &amp;amp; \cdots\newline
A_{n,1} &amp;amp; \cdots &amp;amp; A_{n,n-1} &amp;amp; A_{n,n}\end{array}\right|+k\cdot\left|\begin{array}{ccc} A_{1,1} &amp;amp; \dots &amp;amp; A_{1,n-1} &amp;amp; A_{1,n}\newline
\cdots &amp;amp; \cdots &amp;amp; \cdots &amp;amp; \cdots\newline
Y_{1} &amp;amp; \dots &amp;amp; Y_{n-1} &amp;amp; Y_{n}\newline
Y_{1} &amp;amp; \dots &amp;amp; Y_{n-1} &amp;amp; Y_{n}\newline
\cdots &amp;amp; \cdots &amp;amp; \cdots &amp;amp; \cdots\newline
A_{n,1} &amp;amp; \cdots &amp;amp; A_{n,n-1} &amp;amp; A_{n,n}\end{array}\right|\newline
&amp;amp;=\left|\begin{array}{ccc} A_{1,1} &amp;amp; \dots &amp;amp; A_{1,n-1} &amp;amp; A_{1,n}\newline
\cdots &amp;amp; \cdots &amp;amp; \cdots &amp;amp; \cdots\newline
X_{1} &amp;amp; \dots &amp;amp; X_{n-1} &amp;amp; X_{n}\newline
Y_{1} &amp;amp; \dots &amp;amp; Y_{n-1} &amp;amp; Y_{n}\newline
\cdots &amp;amp; \cdots &amp;amp; \cdots &amp;amp; \cdots\newline
A_{n,1} &amp;amp; \cdots &amp;amp; A_{n,n-1} &amp;amp; A_{n,n}\end{array}\right|\end{aligned}
$$&lt;/p>
&lt;p>对于任意矩阵，交换其任意两行，其行列式变为相反数；对于任意矩阵，其中任意一行加上任意另一行的倍数，其行列式不变。&lt;/p>
&lt;h2 id="特殊矩阵的行列式">特殊矩阵的行列式&lt;/h2>
&lt;p>对于一个 $n$ 阶方阵，或是 $n$ 阶行列式，其从左上角至右下角连续 $n$ 个位置上的元素，称为它的主对角线。&lt;/p>
&lt;p>对于一个方阵，若其主对角线以下的所有元素都为 $0$，则称之为上三角矩阵；若其主对角线以上的所有元素为 $0$，则称之为下三角矩阵。&lt;/p>
&lt;p>由行列式的定义可知，若 $A$ 是上三角矩阵或下三角矩阵，$|A| = \prod\limits_{i=1}^nA_{i,i}$。&lt;/p>
&lt;h2 id="求行列式">求行列式&lt;/h2>
&lt;p>只要运用&lt;strong>引理 1&lt;/strong>和&lt;strong>引理 5&lt;/strong>，用类似高斯消元的方法将矩阵转为上三角矩阵，我们就可以在 $O(n^3)$ 的时间内求出矩阵的行列式了。&lt;/p></description></item><item><title>生成函数入门</title><link>https://blog.fei.ac/zh/posts/generating-function/</link><pubDate>Fri, 28 Feb 2020 10:51:38 +0800</pubDate><guid>https://blog.fei.ac/zh/posts/generating-function/</guid><description>&lt;p>生成函数是一种用级数的系数来表达数列的方法，是处理数列的最强有力的方法之一。在 OI 中生成函数常常与多项式结合起来处理计数问题。&lt;/p>
&lt;h2 id="几种基本的生成函数">几种基本的生成函数&lt;/h2>
&lt;p>对于一个无限长度的数列 $a_0, a_1, a_2, \ldots$，它的普通型生成函数 (Ordinary Generating Function, OGF) 是&lt;/p>
&lt;p>$$
F(z)=a_0+a_1z+a_2z+\ldots+a_iz^i+\ldots
$$&lt;/p>
&lt;p>它的指数型生成函数 (Exponential Generating Function, EGF) 是&lt;/p>
&lt;p>$$
F(z)=\dfrac{a_0}{0!}+\dfrac{a_1z}{1!}+\dfrac{a_2z^2}{2!}+\ldots+\dfrac{a_iz^i}{i!}+\ldots
$$&lt;/p>
&lt;p>还有另一种较为特殊的狄利克雷型生成函数，暂时不提。&lt;/p>
&lt;h2 id="普通型生成函数">普通型生成函数&lt;/h2>
&lt;p>普通型生成函数是我们最常用的生成函数。在这之后，如果不说明是何种生成函数，默认是在指普通型生成函数。&lt;/p>
&lt;p>数列 $1,1,1,\ldots$ 的普通型生成函数是什么？&lt;/p>
&lt;p>这个问题似乎很无趣。让我们把它写下来&lt;/p>
&lt;p>$$
F(z)=1+z+z^2+\ldots\
zF(z)=z+z^2+z^3+\ldots
$$&lt;/p>
&lt;p>我们发现&lt;/p>
&lt;p>$$
F(z)-zF(z)=1\
F(z)=\dfrac{1}{1-z}
$$&lt;/p>
&lt;p>事实上，$1+z+z^2+\ldots$ 是 $F(z)$ 的开放形式，而 $\dfrac{1}{1-z}$ 是 $F(z)$ 的封闭形式。用相同的方法，我们能得到所有类似数列的普通型生成函数的封闭形式：&lt;/p>
&lt;p>$$
F(z)=1+az+a^2z^2+a^3z^3\ldots=\dfrac{1}{1-az}\
G(z)=1+z^{a}+z^{2a}+z^{3a}+\ldots=\dfrac{1}{1-z^a}
$$&lt;/p>
&lt;blockquote>
&lt;p>如果你把 $z=10$ 代入 $1+z+z^2+\ldots=\dfrac{1}{1-z}$，你会发现这个式子根本不成立。事实上，这个式子只有在 $|z|&amp;lt;1$，即 $z^{+\infty}=0$ 时才成立。&lt;/p>
&lt;p>幸运的是，在生成函数中我们只关心 $F(z)$ 的系数，不关心 $z$ 的值和 $F(z)$ 的值。可以认为这些封闭形式在我们研究的范围内总是成立的。&lt;/p>
&lt;/blockquote>
&lt;p>数列 $\binom{n}{0},\binom{n}{1},\binom{n}{2},\ldots,\binom{n}{i},\ldots$ 的普通型生成函数是什么？&lt;/p>
&lt;p>这个问题和上面那个大同小异。直接写出来&lt;/p>
&lt;p>$$
F(z)=\binom{n}{0}+\binom{n}{1}z+\binom{n}{2}z^2+\ldots
$$&lt;/p>
&lt;p>这符合二项式定理的形式。用二项式定理得到原式的封闭形式：&lt;/p>
&lt;p>$$
F(z)=(1+z)^n
$$&lt;/p>
&lt;p>看来很多数列都有封闭形式！斐波那契数列是否也有封闭形式？&lt;/p>
&lt;p>$$
F(z)=1+z+2z^2+3z^3+5z^4+8z^7+\ldots
$$&lt;/p>
&lt;p>因为 $f_n=f_{n-1}+f_{n-2}$，于是对于原函数的每一项 $f_iz^i$，我们都可以用 $f_iz^i=z\cdot f_{i-1}z^{i-1}+z^2\cdot f_{i-2}z^{i-2}$ 替换&lt;/p>
&lt;p>$$
F(z)=1+zF(z)+z^2F(z)
$$&lt;/p>
&lt;p>解得&lt;/p>
&lt;p>$$
F(z)=\dfrac{1}{1-z-z^2}
$$&lt;/p>
&lt;h2 id="普通型生成函数卷积">普通型生成函数卷积&lt;/h2>
&lt;p>生成函数如果不能进行运算，那它将是无用的。我们先介绍生成函数的卷积运算。你也可以认为卷积就是乘法。&lt;/p>
&lt;p>普通型生成函数的卷积与多项式类似。设普通型生成函数 $F(z)=\sum\limits_{i=0} f_iz^i$ 和 $G(z)=\sum\limits_{i=0} g_iz^i$，则有 $(F*G)(z)=\sum\limits_{i=0}\sum\limits_{j=0}^if_jg_{i-j}z^i$。这样定义是很自然的，因为乘法分配律。&lt;/p>
&lt;p>我们发现这像是一个动态规划的转移。如果把 $F$，$G$ 和 $F&lt;em>G$ 看做三个数组，则对于 $F&lt;/em>G$ 的每个元素，都有&lt;/p>
&lt;p>$$
(F*G)[i]=F[0]\times G[i]+F[1]\times G[i-1]+F[2]\times G[i-2]+F[3]\times G[i-3]+\ldots+F[i]\times G[0]
$$&lt;/p>
&lt;p>这个 DP 的转移原本是 $O(n^2)$ 的。但如果我们把它看成生成函数的卷积，就可以在 $O(n\log n)$ 的时间复杂度内计算。&lt;/p>
&lt;p>当然，生成函数不止能优化时间，它还是一种更简便的计算工具。参考下面的例题：&lt;/p>
&lt;blockquote>
&lt;p>你们家将要外出野餐，由你负责准备食物。你打算携带一些水、牛奶、饼干、三明治和火腿。考虑到食物搭配合理，你准备的食物要满足如下条件：&lt;/p>
&lt;ul>
&lt;li>水携带任意瓶&lt;/li>
&lt;li>牛奶携带 $0$ 瓶或 $2$ 瓶&lt;/li>
&lt;li>饼干携带 $3$ 盒或 $4$ 盒&lt;/li>
&lt;li>三明治携带偶数份&lt;/li>
&lt;li>火腿携带奇数份&lt;/li>
&lt;/ul>
&lt;p>若一共携带 $1000$ 件食物，有多少种携带方案？两个方案不同当且仅当在这两种方案中，某种食物的数量不同。&lt;/p>
&lt;/blockquote>
&lt;p>携带水的方案数形成的数列是 $1, 1, 1, \ldots$ (携带任意瓶水的方案数都是 $1$)。由前面介绍的知识可知携带水的方案数的生成函数是 $\dfrac{1}{1-x}$。&lt;/p>
&lt;p>携带牛奶的方案数形成的数列是 $1, 0, 1, 0, 0, 0 \ldots$ (只有携带 $0$ 瓶或 $2$ 瓶的方案数是 $1$)。它的生成函数是 $1+x^2$。&lt;/p>
&lt;p>携带饼干的方案数形成的数列是 $0, 0, 0, 1, 1, 0, 0, \ldots$。它的生成函数是 $x^3+x^4$。&lt;/p>
&lt;p>携带三明治的方案数形成的数列是 $1, 0, 1, 0, 1, 0, \ldots$。它的生成函数是 $1+x^2+x^4+x^6+\ldots=\dfrac{1}{1-x^2}$。&lt;/p>
&lt;p>携带火腿的方案数形成的数列是 $0, 1, 0, 1, 0, 1, \ldots$。它的生成函数是 $\dfrac{x}{1-x^2}$。&lt;/p>
&lt;p>由于转移的形式与生成函数的卷积的形式完全吻合，这些生成函数的卷积的 $x^{1000}$ 次项的系数就是答案。于是携带食物的方案数形成的数列的生成函数是&lt;/p>
&lt;p>$$
\dfrac{1}{1-x}(1+x^2)(x^3+x^4)\dfrac{1}{1-x^2}\dfrac{x}{1-x^2}=\dfrac{x^4+x^5+x^6+x^7}{(1-x)(1-x^2)^2}
$$&lt;/p>
&lt;p>由于包含除法，我们现在还不会求 $\dfrac{x^4+x^5+x^6+x^7}{(1-x)(1-x^2)^2}$ 的系数。但我们已经得到了复杂情况的简洁表达方式。&lt;/p>
&lt;h2 id="指数型生成函数">指数型生成函数&lt;/h2>
&lt;p>为什么指数型生成函数被称为指数型生成函数，而不是阶乘型生成函数？因为指数函数的麦克劳林级数是&lt;/p>
&lt;p>$$
e^x = \sum\limits_{i=0}^{+\infty}\dfrac{x^i}{i!}
$$&lt;/p>
&lt;p>我们也常把 $e^x$ 写作 $\exp x$。可以看出 $\exp x$ 正好与指数型生成函数的形式吻合。&lt;/p>
&lt;p>由于 $\binom{n}{m}=\dfrac{n!}{m!(n-m)!}$，指数型生成函数的卷积恰好满足 $(F*G)(z)=\sum\limits_{i=0}\sum\limits_{j=0}^i\binom{i}{j}f_jg_{i-j}z^i$，正好比 OGF 多了一个二项式系数。下面的例题可以帮助理解这里的二项式系数的作用。&lt;/p>
&lt;blockquote>
&lt;p>科学家最近在火星上发现了一种原始生物。这种原始生物也是以 DNA 作为遗传物质的。&lt;/p>
&lt;p>我们可以用一个仅含 $\texttt{A,T,G,C}$ 的字符串来描述这个生物的某个基因片段。经过研究，科学家发现这个字符串满足如下限制：&lt;/p>
&lt;ul>
&lt;li>$\texttt{A}$ 的出现次数为偶数&lt;/li>
&lt;li>$\texttt{T}$ 的出现次数为奇数&lt;/li>
&lt;/ul>
&lt;p>求有多少个满足如上限制且长度为 $n$ 的字符串。&lt;/p>
&lt;/blockquote>
&lt;p>由于字符间的不同顺序也要计入方案，在转移时我们要乘上对应的二项式系数。指数型生成函数正好可以担负这一任务。&lt;/p>
&lt;p>$\texttt{A}$ 的方案数的指数型生成函数是 $1+\dfrac{x^2}{2!}+\dfrac{x^2}{2!}+\dfrac{x^4}{4!}+\ldots=\dfrac{e^x + e^{-x}}{2}$。&lt;/p>
&lt;p>$\texttt{T}$ 的方案数的指数型生成函数是 $\dfrac{x}{1!}+\dfrac{x^3}{3!}+\dfrac{x^5}{5!}+\ldots=\dfrac{e^x-e^{-x}}{2}$。&lt;/p>
&lt;p>$\texttt{G}$ 和 $\texttt{C}$ 的方案数的指数型生成函数都是 $e^x$。&lt;/p>
&lt;p>于是字符串的方案数的指数型生成函数就是&lt;/p>
&lt;p>$$\dfrac{e^x + e^{-x}}{2}\dfrac{e^x - e^{-x}}{2}e^xe^x=\dfrac{e^{4x}-1}{4}$$&lt;/p>
&lt;p>用麦克劳林级数展开就可以得到各项系数了。这个生成函数的第 $n$ 项系数就是答案。&lt;/p>
&lt;h2 id="更高阶的生成函数运算">更高阶的生成函数运算&lt;/h2>
&lt;p>事实上这一类类多项式生成函数还可以求指数函数、对数函数、平方根甚至三角函数。其中，指数函数有组合意义，对数函数则是这一组合意义的反演。&lt;/p>
&lt;h2 id="例题">例题&lt;/h2>
&lt;p>&lt;a href="https://www.luogu.com.cn/problem/P4389">付公主的背包&lt;/a>&lt;br>
&lt;a href="https://codeforces.com/problemset/problem/438/E">The Child and Binary Tree&lt;/a>&lt;/p></description></item></channel></rss>