<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><title>绯想天 | 斯特林数与上升幂、下降幂</title><meta name=viewport content="width=device-width,minimum-scale=1"><meta name=generator content="Hugo 0.100.2"><meta name=ROBOTS content="INDEX, FOLLOW"><link href=/dist/app.css rel=stylesheet><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,o,i,a,t,n,s){e.GoogleAnalyticsObject=t,e[t]=e[t]||function(){(e[t].q=e[t].q||[]).push(arguments)},e[t].l=1*new Date,n=o.createElement(i),s=o.getElementsByTagName(i)[0],n.async=1,n.src=a,s.parentNode.insertBefore(n,s)}(window,document,'script','https://www.google-analytics.com/analytics.js','ga'),ga('create','UA-1234567890','auto'),ga('send','pageview'))</script><script>MathJax={tex:{inlineMath:[["$","$"]]},displayMath:[["$$","$$"],["[[","]]"]],svg:{fontCache:"global"}}</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script>
<script>(function(i,t){var n=document,s='script',e=n.createElement(s),o=n.getElementsByTagName(s)[0];e.src=i,t&&e.addEventListener('load',function(e){t(e)}),o.parentNode.insertBefore(e,o)})('https://blog.fei.ac/lib/pangu.min.js',function(){pangu.spacingPage()})</script><style type=text/css media="screen, print">@font-face{font-family:fancytitlefont;font-style:normal;font-display:swap;src:url(https://blog.fei.ac/fonts/exampleFont.woff2)format('woff2'),url(https://blog.fei.ac/fonts/exampleFont.woff)format('woff')}@font-face{font-family:noto serif cjk sc;font-style:normal;font-weight:300;font-display:swap;src:local('Noto Serif CJK SC Light'),local('NotoSerifCJK-Light'),url(https://blog.fei.ac/fonts/noto-serif-sc-v7-latin_chinese-simplified-300.woff2)format('woff2'),url(https://blog.fei.ac/fonts/noto-serif-sc-v7-latin_chinese-simplified-300.woff)format('woff')}@font-face{font-family:noto serif cjk sc;font-style:normal;font-weight:400;font-display:swap;src:local('Noto Serif CJK SC'),local('NotoSerifCJK-Regular'),url(https://blog.fei.ac/fonts/noto-serif-sc-v7-latin_chinese-simplified-regular.woff2)format('woff2'),url(https://blog.fei.ac/fonts/noto-serif-sc-v7-latin_chinese-simplified-regular.woff)format('woff')}@font-face{font-family:noto serif cjk sc;font-style:normal;font-weight:500;font-display:swap;src:local('Noto Serif CJK SC Medium'),local('NotoSerifCJK-Medium'),url(https://blog.fei.ac/fonts/noto-serif-sc-v7-latin_chinese-simplified-500.woff2)format('woff2'),url(https://blog.fei.ac/fonts/noto-serif-sc-v7-latin_chinese-simplified-500.woff)format('woff')}</style></head><body class="bg-gray-100 text-gray-700 font-sans"><div class="p-6 sm:p-10 md:p-16 flex flex-wrap"><header class="w-full md:w-2/5 xl:w-1/2 md:pr-12 lg:pr-20 xl:pr-24 order-1 md:order-1 max-w-2xl"><div class="z-50 bg-gray-100 bg-opacity-75 bg-opacity-custom lg:min-w-0.7 max-w-xl md:float-right md:text-right leading-loose tracking-tight md:sticky md:top-0 pt-2"><div><h2><a href=https://blog.fei.ac/zh/ title=绯想天 class="heading font-cursive icon">绯想天</a></h2></div><h1 class=pt-2>斯特林数与上升幂、下降幂</h1><div class="flex flex-wrap justify-end pt-2"><div class="md:flex-grow-0 font-light"><a class="post-taxonomy-category text-medium-red-violet-600 hover:text-medium-red-violet-400" href=/categories/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6>离散数学</a>
&nbsp;&nbsp;
<a class="post-taxonomy-tag text-eucalyptus-500" href=/tags/%E5%A4%9A%E9%A1%B9%E5%BC%8F>多项式</a>&nbsp;/
<a class="post-taxonomy-tag text-eucalyptus-500" href=/tags/%E6%96%AF%E7%89%B9%E6%9E%97%E6%95%B0>斯特林数</a></div><time class="text-eucalyptus-500 md:text-right md:flex-grow font-light pl-4" datetime=2021-01-28T14:29:04+08:00>2021-01-28</time></div><hr></div></header><main role=main class="w-full md:w-3/5 xl:w-1/2 max-w-3xl order-2 md:order-2 min-h-70vh pt-2 pb-4"><article><section class="mx-auto content"><div class=c-rich-text><blockquote><p><strong>本文内容已被整合至 OI Wiki，请至 <a href=https://oi-wiki.org/math/combinatorics/stirling/>OI Wiki</a> 查看最新内容。</strong></p></blockquote><p>斯特林数与二项式系数密切相关，是离散数学的重要内容。</p><p>斯特林数分为两类，分别是“第二类斯特林数”和“第一类斯特林数”。虽然被称作“第二类”，第二类斯特林数却比第一类的更常用，也在斯特林的相关著作和具体数学中被首先描述；因此，在这篇文章中我们也先介绍第二类斯特林数。</p><h2 id=第二类斯特林数>第二类斯特林数</h2><p>第二类斯特林数又称作斯特林子集数，用 $\begin{Bmatrix}n\m\end{Bmatrix}$ 表示，读作“$n$ 子集 $m$”。它的组合含义是，将 $n$ 个有标号物品划分为 $m$ 个无标号集合的方案数。学习<a href=/2021/polylog>多项式对数函数、指数函数和欧拉变换</a>应该有助于能找到第二类斯特林数和指数函数的相关性（斯特林数限定了划分子集的个数而指数函数没有）。</p><p>可以认为，对于 $n \less m$，有 $\begin{Bmatrix}n\m\end{Bmatrix}=0$。$m=0$ 的情况比较特殊。一般认为，将空集划分为 $0$ 个非空集合是可行的，因此我们定义 $\begin{Bmatrix}0\0\end{Bmatrix}=1$；而对于任意 $n \greater 0$，都有 $\begin{Bmatrix}n\0\end{Bmatrix}=0$。</p><p>和二项式系数类似，第二类斯特林数也有递推公式</p><p>$$
\begin{Bmatrix}n\m\end{Bmatrix}=m\begin{Bmatrix}n-1\m\end{Bmatrix}+\begin{Bmatrix}n-1\m-1\end{Bmatrix},n>0
$$</p><p>同时，第二类斯特林数也有简洁的通项公式，即</p><p>$$
\begin{Bmatrix}n\m\end{Bmatrix}=\sum\limits_{i=0}^m\dfrac{(-1)^{m-i}i^n}{i!(m-i)!}
$$</p><p>考虑使用容斥原理证明。设 $G_i$ 表示 $n$ 个有标号元素，放置到 $i$ 个有标号集合的方案数；$F_i$ 表示 $n$ 个有标号元素，放置到 $i$ 个有标号非空集合的方案数。不难得到</p><p>$$
G_i=i^n=\sum\limits_{j=0}^i\binom{i}{j}F_j
$$</p><p>根据二项式反演</p><p>$$
F_i=\sum\limits_{j=0}^{i}(-1)^{i-j}\binom{i}{j}j^n
$$</p><p>考虑第二类斯特林数与 $F_i$ 的关系</p><p>$$
\begin{Bmatrix}n\i\end{Bmatrix}=\dfrac{F_i}{i!}
$$</p><p>联立得证。</p><h2 id=同一行第二类斯特林数的计算>同一行第二类斯特林数的计算</h2><p>“同一行”的第二类斯特林数指的是，有着不同的 $i$，相同的 $n$ 的一系列 $\begin{Bmatrix}n\i\end{Bmatrix}$。求出同一行的所有第二类斯特林数，就是对 $i=0..n$ 求出了将 $n$ 个不同元素划分为 $i$ 个非空集的方案数。</p><p>根据上面给出的通项公式，卷积计算即可。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(){
</span></span><span style=display:flex><span>	scanf(<span style=color:#e6db74>&#34;%d&#34;</span>, <span style=color:#f92672>&amp;</span>n);
</span></span><span style=display:flex><span>	fact[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; i <span style=color:#f92672>&lt;=</span> n; <span style=color:#f92672>++</span>i) fact[i] <span style=color:#f92672>=</span> (ll)fact[i <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>] <span style=color:#f92672>*</span> i <span style=color:#f92672>%</span> mod;
</span></span><span style=display:flex><span>	exgcd(fact[n], mod, ifact[n], ifact[<span style=color:#ae81ff>0</span>]), ifact[n] <span style=color:#f92672>=</span> (ifact[n] <span style=color:#f92672>%</span> mod <span style=color:#f92672>+</span> mod) <span style=color:#f92672>%</span> mod;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> n <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>; i <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span>; <span style=color:#f92672>--</span>i) ifact[i] <span style=color:#f92672>=</span> (ll)ifact[i <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>] <span style=color:#f92672>*</span> (i <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>) <span style=color:#f92672>%</span> mod;
</span></span><span style=display:flex><span>	fstdlib<span style=color:#f92672>::</span>poly f(n <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>), g(n <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;=</span> n; <span style=color:#f92672>++</span>i) g[i] <span style=color:#f92672>=</span> (i <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>?</span> mod <span style=color:#f92672>-</span> <span style=color:#ae81ff>1ll</span> <span style=color:#f92672>:</span> <span style=color:#ae81ff>1ll</span>) <span style=color:#f92672>*</span> ifact[i] <span style=color:#f92672>%</span> mod, f[i] <span style=color:#f92672>=</span> (ll)qpow(i, n) <span style=color:#f92672>*</span> ifact[i] <span style=color:#f92672>%</span> mod;
</span></span><span style=display:flex><span>	f <span style=color:#f92672>*=</span> g, f.resize(n <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;=</span> n; <span style=color:#f92672>++</span>i) printf(<span style=color:#e6db74>&#34;%d &#34;</span>, f[i]);
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=同一列第二类斯特林数的计算>同一列第二类斯特林数的计算</h2><p>即对 $i=0..n$，求出 $\begin{Bmatrix}i\k\end{Bmatrix}$。有两种常用的快速计算方法。</p><h3 id=方法-1-利用递推公式>方法 1. 利用递推公式</h3><p>第二类斯特林数的通项公式不适合计算列，我们考虑利用递推公式写出它的生成函数。设 $F_k(x)=\sum\limits_{i=0}^n\begin{Bmatrix}i\k\end{Bmatrix}x^i$，则</p><p>$$
F_k(x)=kxF_k(x)+xF_{k-1}(x)
$$</p><p>综合第二类斯特林数的定义解得</p><p>$$
F_k(x)=\begin{cases}\dfrac{x}{1-kx}F_{k-1}(x)&\text{if }k>0\1&\text{else}\end{cases}
$$</p><p>即 $F_k(x)=\prod\limits_{i=1}^k\dfrac{x}{1-ix}$</p><p>利用多项式分治乘和多项式乘法逆即可在 $O(k\log k\log n)$ 的时间内解出 $F_k(x)$。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(){
</span></span><span style=display:flex><span>	scanf(<span style=color:#e6db74>&#34;%d%d&#34;</span>, <span style=color:#f92672>&amp;</span>n, <span style=color:#f92672>&amp;</span>k);
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; i <span style=color:#f92672>&lt;=</span> k; <span style=color:#f92672>++</span>i) mask.emplace_back(std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>{<span style=color:#ae81ff>1</span>, mod <span style=color:#f92672>-</span> i});
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>while</span>((<span style=color:#66d9ef>int</span>)mask.size() <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>2</span>){
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>while</span>((<span style=color:#66d9ef>int</span>)mask.size() <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>2</span>){
</span></span><span style=display:flex><span>			tmp.push_back(mask[mask.size() <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>] <span style=color:#f92672>*</span> mask[mask.size() <span style=color:#f92672>-</span> <span style=color:#ae81ff>2</span>]);
</span></span><span style=display:flex><span>			mask.pop_back(), mask.pop_back();
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span>(<span style=color:#f92672>!</span>mask.empty()) tmp.push_back(mask[<span style=color:#ae81ff>0</span>]), mask.pop_back();
</span></span><span style=display:flex><span>		std<span style=color:#f92672>::</span>swap(mask, tmp);
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	fstdlib<span style=color:#f92672>::</span>poly f(mask[<span style=color:#ae81ff>0</span>].inv(n <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>));
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> f.size() <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>; i <span style=color:#f92672>&gt;=</span> k; <span style=color:#f92672>--</span>i) f[i] <span style=color:#f92672>=</span> f[i <span style=color:#f92672>-</span> k];
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span>min(k, (<span style=color:#66d9ef>int</span>)f.size()) <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>; i <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span>; <span style=color:#f92672>--</span>i) f[i] <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> (<span style=color:#66d9ef>int</span>)f.size(); <span style=color:#f92672>++</span>i) printf(<span style=color:#e6db74>&#34;%d &#34;</span>, f[i]);
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=方法-2-利用指数型生成函数>方法 2. 利用指数型生成函数</h3><p>一个盒子装 $i$ 个物品的方案是 $\begin{cases}1&\text{if }i>0\0&\text{else}\end{cases}$。我们可以写出它的指数型生成函数为 $F(x)=\sum\limits_{i=1}^{+\infty}\dfrac{x^i}{i!}$。经过之前的学习，我们明白 $F^k(x)$ 就是 $i$ 个有标号物品放到 $k$ 个有标号盒子里的指数型生成函数，$\exp F(x)=\sum\limits_{i=0}^{+\infty}\dfrac{F^i(x)}{i!}$ 就是 $i$ 个有标号物品放到任意多个无标号盒子里的指数型生成函数（指数函数通过每项除以一个 $i!$ 去掉了盒子的标号）。这里涉及到很多“有标号”“无标号”的内容，注意辨析。</p><p>那么 $\begin{Bmatrix}i\k\end{Bmatrix}=\dfrac{\left[\dfrac{x^i}{i!}\right]F^k(x)}{k!}$，$O(n\log n)$ 计算多项式幂即可。实际使用时比 $O(n\log^2n)$ 的方法 1 要慢。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(){
</span></span><span style=display:flex><span>	scanf(<span style=color:#e6db74>&#34;%d%d&#34;</span>, <span style=color:#f92672>&amp;</span>n, <span style=color:#f92672>&amp;</span>k);
</span></span><span style=display:flex><span>	fstdlib<span style=color:#f92672>::</span>poly f(n <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>	fact[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; i <span style=color:#f92672>&lt;=</span> n; <span style=color:#f92672>++</span>i) fact[i] <span style=color:#f92672>=</span> (ll)fact[i <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>] <span style=color:#f92672>*</span> i <span style=color:#f92672>%</span> mod;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; i <span style=color:#f92672>&lt;=</span> n; <span style=color:#f92672>++</span>i) f[i] <span style=color:#f92672>=</span> qpow(fact[i], mod <span style=color:#f92672>-</span> <span style=color:#ae81ff>2</span>);
</span></span><span style=display:flex><span>	f <span style=color:#f92672>=</span> fstdlib<span style=color:#f92672>::</span>exp(fstdlib<span style=color:#f92672>::</span>log(f <span style=color:#f92672>&gt;&gt;</span> <span style=color:#ae81ff>1</span>) <span style=color:#f92672>*</span> k) <span style=color:#f92672>&lt;&lt;</span> k, f.resize(n <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>int</span> inv <span style=color:#f92672>=</span> qpow(fact[k], mod <span style=color:#f92672>-</span> <span style=color:#ae81ff>2</span>);
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;=</span> n; <span style=color:#f92672>++</span>i) printf(<span style=color:#e6db74>&#34;%lld &#34;</span>, (ll)f[i] <span style=color:#f92672>*</span> fact[i] <span style=color:#f92672>%</span> mod <span style=color:#f92672>*</span> inv <span style=color:#f92672>%</span> mod);
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=第一类斯特林数>第一类斯特林数</h2><p>第一类斯特林数又称作斯特林轮换数，用 $\begin{bmatrix}n\m\end{bmatrix}$ 表示，读作“$n$ 轮换 $m$”。它的组合含义是，将 $n$ 个有标号物品分为 $m$ 个无标号轮换的方案数。</p><p>一个轮换就是一个首尾相接的环形排列。我们可以写出一个轮换$[A,B,C,D]$，并且我们认为 $[A,B,C,D]=[B,C,D,A]=[C,D,A,B]=[D,A,B,C]$，即，两个可以通过旋转而互相得到的轮换是等价的。注意，我们不认为两个可以通过翻转而相互得到的轮换等价，即 $[A,B,C,D]\neq[D,C,B,A]$。</p><p>不难发现，对于 $n>0$ 有 $\begin{bmatrix}n\1\end{bmatrix}=(n-1)!$；进一步，也有 $\begin{bmatrix}n\m\end{bmatrix}\geq \begin{Bmatrix}n\m\end{Bmatrix}$。</p><p>轮换和排列一一对应，如果对同一行的所有第二类斯特林数求和，我们也能得到排列的总数 $\sum\limits_{i=0}^k\begin{bmatrix}n\i\end{bmatrix}=n!$。这一点可以参考 <em>具体数学</em>。</p><p>类似第二类斯特林数，我们也可以写出第一类斯特林数的递推公式</p><p>$$
\begin{bmatrix}n\m\end{bmatrix}=(n-1)\begin{bmatrix}n-1\m\end{bmatrix}+\begin{bmatrix}n-1\m-1\end{bmatrix},n>0
$$</p><h2 id=同一行第一类斯特林数的计算>同一行第一类斯特林数的计算</h2><p>类似第二类斯特林数，我们构造同行第一类斯特林数的生成函数，即</p><p>$$
F_n(x)=\sum\limits_{i=0}^n\begin{bmatrix}n\i\end{bmatrix}x^i
$$</p><p>根据递推公式，不难写出</p><p>$$
F_n(x)=(n-1)F_{n-1}(x)+xF_{n-1}(x)
$$</p><p>于是</p><p>$$
F_n(x)=\prod\limits_{i=0}^{n-1}(x+i)=\dfrac{(x+n-1)!}{(x-1)!}
$$</p><p>这其实是 $x$ 的 $n$ 次上升阶乘幂，记做 $x^{\overline n}$。这个东西自然是可以暴力分治乘 $O(n\log^2n)$ 求出的，但用上升幂相关做法可以 $O(n\log n)$ 求出。具体见下面有关阶乘幂的部分。</p><h2 id=同一列第一类斯特林数的计算>同一列第一类斯特林数的计算</h2><p>仿照第二类斯特林数的计算，我们可以用指数型生成函数解决该问题。注意，由于递推公式和行有关，我们不能利用递推公式计算同列的第一类斯特林数。</p><p>显然，单个轮换的指数型生成函数为</p><p>$$
F(x)=\sum\limits_{i=1}^n\dfrac{(i-1)!x^i}{i!}=\sum\limits_{i=1}^n\dfrac{x^i}{i}
$$</p><p>它的 $k$ 次幂就是 $\begin{bmatrix}i\k\end{bmatrix}$ 的指数型生成函数，$O(n\log n)$ 计算即可。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(){
</span></span><span style=display:flex><span>	scanf(<span style=color:#e6db74>&#34;%d%d&#34;</span>, <span style=color:#f92672>&amp;</span>n, <span style=color:#f92672>&amp;</span>k);
</span></span><span style=display:flex><span>	fact[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; i <span style=color:#f92672>&lt;=</span> n; <span style=color:#f92672>++</span>i) fact[i] <span style=color:#f92672>=</span> (ll)fact[i <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>] <span style=color:#f92672>*</span> i <span style=color:#f92672>%</span> mod;
</span></span><span style=display:flex><span>	ifact[n] <span style=color:#f92672>=</span> qpow(fact[n], mod <span style=color:#f92672>-</span> <span style=color:#ae81ff>2</span>);
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> n <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>; i <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span>; <span style=color:#f92672>--</span>i) ifact[i] <span style=color:#f92672>=</span> (ll)ifact[i <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>] <span style=color:#f92672>*</span> (i <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>) <span style=color:#f92672>%</span> mod;
</span></span><span style=display:flex><span>	fstdlib<span style=color:#f92672>::</span>poly f(n <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; i <span style=color:#f92672>&lt;=</span> n; <span style=color:#f92672>++</span>i) f[i] <span style=color:#f92672>=</span> (ll)fact[i <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>] <span style=color:#f92672>*</span> ifact[i] <span style=color:#f92672>%</span> mod;
</span></span><span style=display:flex><span>	f <span style=color:#f92672>=</span> fstdlib<span style=color:#f92672>::</span>exp(fstdlib<span style=color:#f92672>::</span>log(f <span style=color:#f92672>&gt;&gt;</span> <span style=color:#ae81ff>1</span>) <span style=color:#f92672>*</span> k) <span style=color:#f92672>&lt;&lt;</span> k, f.resize(n <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;=</span> n; <span style=color:#f92672>++</span>i) printf(<span style=color:#e6db74>&#34;%lld &#34;</span>, (ll)f[i] <span style=color:#f92672>*</span> fact[i] <span style=color:#f92672>%</span> mod <span style=color:#f92672>*</span> ifact[k] <span style=color:#f92672>%</span> mod);
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=上升阶乘幂和下降阶乘幂>上升阶乘幂和下降阶乘幂</h2><p>之前我们提出了第一类斯特林数和上升阶乘幂的关系，即 $x$ 的 $n$ 次上升阶乘幂正是第 $n$ 行的第一类斯特林数的普通型生成函数。</p><p>$$
F_n(x)=x^{\overline n}
$$</p><p>接下来我们就介绍上升阶乘幂和与之类似的下降阶乘幂。</p><p>一般的，我们分别用 $x^{\overline n}$ 和 $x^{\underline n}$ 来表示 $x$ 的 $n$ 次上升阶乘幂和下降阶乘幂。它们可以被这样描述</p><p>$$
x^{\overline n}=\prod\limits_{i=0}^{n-1}(x+i)=\dfrac{(x+n-1)!}{(x-1)!},x^{\underline n}=\prod\limits_{i=0}^{n-1}(x-i)=\dfrac{x!}{(x-n)!}
$$</p><p>直观上看，上升幂和下降幂是对称的。我们可以写出</p><p>$$
\begin{aligned}(-x)^{\overline n}&=\prod\limits_{i=0}^{n-1}(-x+i)\&=(-1)^n\prod_{i=0}^{n-1}(x-i)\&=(-1)^nx^{\underline n}\end{aligned}
$$</p><p>同理，$(-x)^{\underline n}=(-1)^nx^{\overline n}$ 也是成立的。</p><p>我们还可以用下降阶乘幂表示二项式系数，这使得下降阶乘幂成为解决带组合数多项式的重要方法。</p><p>$$
\binom{n}{m}=\dfrac{n!}{(n-m)!m!}=\dfrac{n^{\underline m}}{m!}
$$</p><h2 id=阶乘幂和两类斯特林数的关系>阶乘幂和两类斯特林数的关系</h2><h3 id=阶乘幂和第二类斯特林数的关系>阶乘幂和第二类斯特林数的关系</h3><p>我们先研究阶乘幂与第二类斯特林数的关系。事实上它们之间有这样的关系</p><p>$$
x^n=\sum\limits_{i=0}^n\begin{Bmatrix}n\i\end{Bmatrix}x^{\underline{i}},n\geq 0
$$</p><p>我们用“生成函数”证明这一点。令</p><p>$$
F_n(x)=\sum\limits_{i=0}^n\begin{Bmatrix}n\i\end{Bmatrix}x^{\underline i}
$$</p><p>根据第二类斯特林数的递推公式 $\begin{Bmatrix}n\m\end{Bmatrix}=m\begin{Bmatrix}n-1\m\end{Bmatrix}+\begin{Bmatrix}n-1\m-1\end{Bmatrix}$ 可以写出</p><p>$$
\begin{aligned}F_n(x)&=\sum\limits_{i=0}^{n-1}i\begin{Bmatrix}n-1\i\end{Bmatrix}x^{\underline i}+\sum\limits_{i=1}^{n}\begin{Bmatrix}n-1\i-1\end{Bmatrix}x^{\underline {i}}\&=\sum\limits_{i=0}^{n-1}i\begin{Bmatrix}n-1\i\end{Bmatrix}x^{\underline i}+\sum\limits_{i=0}^{n-1}\begin{Bmatrix}n-1\i\end{Bmatrix}x^{\underline {i+1}}\&=\sum\limits_{i=0}^{n-1}\begin{Bmatrix}n-1\i\end{Bmatrix}(i\cdot x^{\underline i}+x^{\underline {i+1}})\end{aligned}
$$</p><p>由 $x^{\underline {i+1}}=(x-i)\cdot x^{\underline{i}}$ 知</p><p>$$
\begin{aligned}i\cdot x^{\underline i}+x^{\underline {i+1}}&=i\cdot x^{\underline{i}}+(x-i)x^{\underline{i}}\&=x \cdot x^{\underline i}\end{aligned}
$$</p><p>代入原式得</p><p>$$
\begin{aligned}F_n(x)&=\sum\limits_{i=0}^{n-1}\begin{Bmatrix}n-1\i\end{Bmatrix}x\cdot x^{\underline i}\&=x\cdot\sum\limits_{i=0}^{n-1}\begin{Bmatrix}n-1\i\end{Bmatrix}x^{\underline i}\&=x\cdot F_{n-1}(x)\end{aligned}
$$</p><p>由于 $F_0(x)=1$，因此 $F_n(x)=x^n$，得证。</p><p>当然，也可以根据上升、下降阶乘幂的关系，将其中的下降阶乘幂替换为上升阶乘幂</p><p>$$
(-x)^n=\sum\limits_{i=0}^n\begin{Bmatrix}n\i\end{Bmatrix}(-1)^{i}x^{\overline i}
$$</p><p>也就是</p><p>$$
x^n=\sum\limits_{i=0}^n\begin{Bmatrix}n\i\end{Bmatrix}(-1)^{n-i}x^{\overline i}
$$</p><p>第二类斯特林数建立了一般多项式向阶乘幂多项式转化的通道。它是一般多项式转上升、下降阶乘幂多项式的有力工具。</p><h3 id=阶乘幂和第一类斯特林数的关系>阶乘幂和第一类斯特林数的关系</h3><p>通过之前构造的生成函数，我们已经知道</p><p>$$
x^{\overline n}=\sum\limits_{i=0}^n\begin{bmatrix}n\i\end{bmatrix}x^i,n\ge 0
$$</p><p>同样，也可以写成下降幂的形式</p><p>$$
x^{\underline n}=\sum\limits_{i=0}^n\begin{bmatrix}n\i\end{bmatrix}(-1)^{n-i}x^i
$$</p><p>第一类斯特林数和第二类斯特林数的作用正好相反，用于将上升、下降幂多项式转化为一般多项式。</p><h2 id=下降阶乘幂在-oi-中的应用>下降阶乘幂在 OI 中的应用</h2><p>上升阶乘幂在 OI 中的应用较少，在此不做介绍；我们只研究下降阶乘幂。</p><h3 id=多项式下降阶乘幂表示与多项式点值表示的关系>多项式下降阶乘幂表示与多项式点值表示的关系</h3><p>在这里，多项式的下降阶乘幂表示就是用</p><p>$$
f(x)=\sum\limits_{i=0}^nb_i{x^\underline i}
$$</p><p>的形式表示一个多项式，而点值表示就是用 $n+1$ 个点</p><p>$$
(i,a_i),i=0..n
$$</p><p>来表示一个多项式。</p><p>显然，下降阶乘幂 $b$ 和点值 $a$ 间满足这样的关系：</p><p>$$
a_k=\sum\limits_{i=0}^{n}b_ik^{\underline i}
$$</p><p>即</p><p>$$
\begin{aligned}a_k&=\sum\limits_{i=0}^{n}\dfrac{b_ik!}{(k-i)!}\\dfrac{a_k}{k!}&=\sum\limits_{i=0}^kb_i\dfrac{1}{(k-i)!}\end{aligned}
$$</p><p>这显然是个卷积形式，我们可以在 $O(n\log n)$ 的时间复杂度内完成点值和下降阶乘幂的互相转化。</p></div></section></article></main><div class="w-full h-0 flex-none order-3"></div><aside role=contentinfo class="w-full md:w-2/5 xl:w-1/2 md:pr-12 lg:pr-20 xl:pr-24 order-4 md:order-3 md:sticky md:bottom-0 self-end max-w-2xl"><div class="md:float-right md:text-right leading-loose tracking-tight md:mb-2"><div class="md:max-w-xs flex flex-col md:items-end"><ul class="font-serif flex-grow-0 flex justify-between flex-wrap md:flex-col"><li class="px-1 md:px-0"><a href=https://blog.fei.ac/zh/posts/ title="归档 page">归档</a></li><li class="px-1 md:px-0"><a href=https://blog.fei.ac/zh/categories/ title="分类 page">分类</a></li><li class="px-1 md:px-0"><a href=https://blog.fei.ac/zh/tags/ title="标签 page">标签</a></li><li class="px-1 md:px-0"><a href=https://blog.fei.ac/zh/series/ title="系列 page">系列</a></li><li class="px-1 md:px-0"><a href=https://blog.fei.ac/zh/about/ title="关于 page">关于</a></li><li><a href=/en class="font-medium text-medium-red-violet-600 hover:text-medium-red-violet-400">English</a></li></ul><div class="flex flex-wrap-reverse md:justify-end content-end md:content-start justify-start items-start max-h-16"><a href=http://github.com/fei0319 target=_blank class="github icon pl-1 text-eucalyptus-400 hover:text-java-400" title="github link" rel=noopener aria-label="follow on github——Opens in a new window"><div class="fill-current h-8 w-8"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><g><path fill="none" d="M0 0h24v24H0z"/><path fill-rule="nonzero" d="M5.883 18.653c-.3-.2-.558-.455-.86-.816a50.32 50.32.0 01-.466-.579c-.463-.575-.755-.84-1.057-.949a1 1 0 01.676-1.883c.752.27 1.261.735 1.947 1.588-.094-.117.34.427.433.539.19.227.33.365.44.438.204.137.587.196 1.15.14.023-.382.094-.753.202-1.095C5.38 15.31 3.7 13.396 3.7 9.64c0-1.24.37-2.356 1.058-3.292-.218-.894-.185-1.975.302-3.192a1 1 0 01.63-.582c.081-.024.127-.035.208-.047.803-.123 1.937.17 3.415 1.096A11.731 11.731.0 0112 3.315c.912.0 1.818.104 2.684.308 1.477-.933 2.613-1.226 3.422-1.096.085.013.157.03.218.05a1 1 0 01.616.58c.487 1.216.52 2.297.302 3.19.691.936 1.058 2.045 1.058 3.293.0 3.757-1.674 5.665-4.642 6.392.125.415.19.879.19 1.38a300.492 300.492.0 01-.012 2.716 1 1 0 01-.019 1.958c-1.139.228-1.983-.532-1.983-1.525l.002-.446.005-.705c.005-.708.007-1.338.007-1.998.0-.697-.183-1.152-.425-1.36-.661-.57-.326-1.655.54-1.752 2.967-.333 4.337-1.482 4.337-4.66.0-.955-.312-1.744-.913-2.404a1 1 0 01-.19-1.045c.166-.414.237-.957.096-1.614l-.01.003c-.491.139-1.11.44-1.858.949a1 1 0 01-.833.135A9.626 9.626.0 0012 5.315c-.89.0-1.772.119-2.592.35a1 1 0 01-.83-.134c-.752-.507-1.374-.807-1.868-.947-.144.653-.073 1.194.092 1.607a1 1 0 01-.189 1.045C6.016 7.89 5.7 8.694 5.7 9.64c0 3.172 1.371 4.328 4.322 4.66.865.097 1.201 1.177.544 1.748-.192.168-.429.732-.429 1.364v3.15c0 .986-.835 1.725-1.96 1.528a1 1 0 01-.04-1.962v-.99c-.91.061-1.662-.088-2.254-.485z"/></g></svg></div></a><a href=mailto:pan-fei@outlook.com target=_blank class="mail icon pl-1 text-eucalyptus-400 hover:text-java-400" title="mail link" rel=noopener aria-label="follow on mail——Opens in a new window"><div class="fill-current h-8 w-8"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><g><path fill="none" d="M0 0h24v24H0z"/><path d="M3 3h18a1 1 0 011 1v16a1 1 0 01-1 1H3a1 1 0 01-1-1V4a1 1 0 011-1zm17 4.238-7.928 7.1L4 7.216V19h16V7.238zM4.511 5l7.55 6.662L19.502 5H4.511z"/></g></svg></div></a></div><div class="text-sm text-gray-500 leading-tight a-gray">Copyright © 2020 - 2023 Fei Pan<br>Licensed under <a href=https://creativecommons.org/licenses/by-nc-sa/4.0/>CC BY-NC-SA 4.0</a></div></div></div></aside><footer class="w-full md:w-3/5 xl:w-1/2 order-3 max-w-3xl md:order-4 pt-2"><hr class=double-line><div class="flex flex-wrap justify-between pb-2 leading-loose font-serif"><a class=flex-grow-0 href=/zh/posts/newtons-method/><svg class="fill-current inline-block h-4 w-4" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24"><path fill="none" d="M0 0h24v24H0z"/><path d="M7.828 11H20v2H7.828l5.364 5.364-1.414 1.414L4 12l7.778-7.778 1.414 1.414z"/></svg>多项式中的 Newton's Method</a>
<a class=flex-grow-0 href=/zh/posts/wc2021/>WC2021 爆零记<svg class="fill-current inline-block h-4 w-4" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24"><path fill="none" d="M0 0h24v24H0z"/><path d="M16.172 11l-5.364-5.364 1.414-1.414L20 12l-7.778 7.778-1.414-1.414L16.172 13H4v-2z"/></svg></a></div><div><div class="font-serif pb-2 flex align-start leading-loose"><span class="heading pr-6 leading-loose">Related</span>
<span><a href=/zh/posts/newtons-method/>多项式中的 Newton's Method</a>&nbsp;&nbsp;/&nbsp;
<a href=/zh/posts/polyinv/>多项式的逆</a>&nbsp;&nbsp;/&nbsp;
<a href=/zh/posts/arbitrary_modulo/>任意模数多项式乘法</a></span></div></div><hr><div class=pb-2></div><script src=https://utteranc.es/client.js repo=fei0319/fei0319.github.io.utterances issue-term=pathname theme=github-light crossorigin=anonymous async></script><hr></footer><script src=/dist/app.js></script></div></body></html>